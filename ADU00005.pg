.STRINGS
$revision_info = "26404dc00864"
.END
.*****************************************************************
.*                                                                
.* File Name : A00TB002.as                                        
.*                                                                
.* Function  : タブレット用ビジョンASプログラム                   
.*                                                                
.* Owner     : S.O-no                                             
.*                                                                
.* History   : 2015.10.02(新規作成)                               
.*             2015.12.23 タブレット並列作業時のインターロック追加
.*             2016.05.11 R4対応
.*                                                                
.*****************************************************************
.PROGRAM vcom_init(); ビジョン変数初期化
; FUNCTION: ビジョン変数初期化
; NOTE    : ver1.0.0[15/10/02]
; ---------------------------------------------------
;   変数定義されていない場合のみパラメータを設定する
;   変更したい場合は変数を直接変更する
; ---------------------------------------------------
;
  NOEXIST_SET_R vlog = 1;                                  ログ保存モード[0:保存なし,1:エラーログ保存,2:全ログ保存]
  NOEXIST_SET_R vlog_max = 1000;                           ログ最大数
  FOR .i = 1 TO 2
    NOEXIST_SET_R vlog_cnt[.i] = 1;                        ログカウンタ
  END
;
  NOEXIST_SET_R ascycle = 0.016;                           ASサイクル待ち時間
  NOEXIST_SET_R vsend_port = 50003;                        送信ポート番号
  NOEXIST_SET_R vrecv_port = 50002;                        受信ポート番号
  NOEXIST_SET_R vsend_ip[0] = 192;                         送信先IPアドレス
  NOEXIST_SET_R vsend_ip[1] = 168
  NOEXIST_SET_R vsend_ip[2] = 0
  NOEXIST_SET_R vsend_ip[3] = 10
  NOEXIST_SET_R vsend_num = 1;                             送信文字列数
  NOEXIST_SET_R vrecv_str_num = 32;                        受信文字列長
  NOEXIST_SET_R vsend_timeout = 0.5;                       送信タイムアウト時間(sec)
  NOEXIST_SET_R vrecv_timeout = 1;                         受信タイムアウト時間(sec)
  NOEXIST_SET_R ix_vcomm_start = 2101;                     通信開始信号
  NOEXIST_SET_R ix_vcomm_busy = 2102;                      通信中信号
  NOEXIST_SET_R ix_vcomm_comp = 2103;                      通信完了信号
  NOEXIST_SET_R ix_vcomm_error = 2104;                     通信エラー信号
  NOEXIST_SET_R ix_vrecv_start = 2105;                     受信開始信号
  NOEXIST_SET_R ix_vrecv_comp = 2106;                      受信完了信号
  NOEXIST_SET_R ix_pc_start = 2107;                        ＰＣプログラム起動確認信号
  NOEXIST_SET_R ix_vsend_only = 2108;                      通信時送信のみ(受信なし)信号
  NOEXIST_SET_R ix_vrecv_only = 2109;                      通信時受信のみ(送信なし)信号
  NOEXIST_SET_R vpc_start_time = 1;                        ＰＣプログラム起動待ちタイムアウト(sec)
  NOEXIST_SET_R vhandshake_time = 0.5;                     ハンドシェイクタイムアウト(sec)
  NOEXIST_SET_R vretry_max = 1;                            リトライ回数
  NOEXIST_SET_R vretry_wait = 0.2;                         リトライ前の待ち時間(sec)
  NOEXIST_SET_R verr_ok = 0;                               通信結果(ＯＫ, "0"以外はＮＧ)
  NOEXIST_SET_R verr_onlymode = 88;                        通信結果(片方向通信モードエラー)
  NOEXIST_SET_R verr_unknown = 89;                         通信結果(不明なエラー)
  NOEXIST_SET_R verr_init = 90;                            通信結果(初期値, 未計測)
  NOEXIST_SET_R verr_send = 91;                            通信結果(送信エラー)
  NOEXIST_SET_R verr_recv = 92;                            通信結果(受信エラー)
  NOEXIST_SET_R verr_timeout1 = 93;                        通信結果(受信開始待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout2 = 94;                        通信結果(受信完了待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout3 = 95;                        通信結果(受信ＰＧ起動待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout4 = 96;                        通信結果(送信ＰＧ起動待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout5 = 97;                        通信結果(通信完了(実行中)待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout6 = 98;                        通信結果(送信ＰＧ実行待ちタイムアウトエラー)
  NOEXIST_SET_R verr_timeout7 = 99;                        通信結果(通信完了待ちタイムアウトエラー)
  NOEXIST_SET_R vis_init = -99999;                         検出結果初期値
  NOEXIST_SET_R vis_err_vid = 2;                           検出結果(K-VFinderのエラーコード[2:画像取込エラー])
  NOEXIST_SET_R vis_err_num = 6;                           検出結果(K-VFinderのエラーコード[6:検出個数0個エラー])
.END
.PROGRAM vcommand(.$command); ビジョンコマンド送信
; FUNCTION: ビジョンコマンド送信[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vget_resultと合わせて使用する
; --------------------------------
;
  IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
    CALL vcom_init;                          ビジョン変数初期化
    SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
    PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
    CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
    IF .chk!=0 THEN
      CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
      RETURN;                                  送信ＰＧ起動待ちタイムアウトエラー
    END
  END
  SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
  SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
  .vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
  UTIMER .@vtime = 0;                        タイマーリセット
  DO;                                        条件ループ開始
    IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
    TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
  UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
  CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
  RETURN;                                    通信完了待ちタイムアウトエラー)
start:
  $vsend_data[0] = .$command;送信データ作成
  CALL vinit;                                計測結果クリア
  SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
  CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
  IF .chk!=0 THEN
    CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
    RETURN;                                  送信ＰＧ実行待ちタイムアウトエラー
  END
.END
.PROGRAM vcorrect(.&base_pos,.id2,.id3,.&adj_pos); 補正位置作成
; FUNCTION: 補正位置作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: 補正前の教示位置,ビジョンID2,ビジョンID3,補正後の教示位置(返却値)
;           ビジョンID2,3はタブレットに準拠
;
  IF .id2<>0 AND .id3<>0 THEN; id2とid3両方にIDが割り振られていた場合(固定カメラ把持ワーク(id2)＋ハンドアイカメラ置きワーク(id3))
    .result2 = vwork_res[.id2,1]; 結果番号(固定)
    .result3 = vwork_res[.id3,1]; 結果番号(ハンドアイ)
;
    POINT .have_m = .base_pos+v_master[.id2,.result2]; ティーチ位置でベースから見たマスターワーク把持位置
    POINT .rslt_m = -v_master[.id3,.result3]+.have_m; マスターハンドアイ計測結果から見たマスターワーク把持位置
;
    POINT .valfa = vwork[.id3,.result3]+.rslt_m; 現在ハンドアイ計測結果から見たマスターワーク把持位置
    POINT .adj_pos = .valfa-vwork[.id2,.result2]; 現在ワーク位置に対するロボット位置(ツール先端)
  ELSE
    IF .id2==0 THEN
      .id = .id3; id3だけIDが割り振られていた場合
    ELSE
      .id = .id2; id2だけIDが割り振られていた場合
    END
;
    .result = vwork_res[.id,1];   結果番号
    IF vc_handeye[.id]<>OFF THEN; ハンドアイフラグ(ハンドアイ:1, 固定:0)
      IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; ハンドアイカメラ・把持あり
        POINT .valfa = v_master[.id,.result]-vwork[.id,1]; マスターと現在のワーク位置差分
        POINT .adj_pos = .base_pos+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
      ELSE
; ハンドアイカメラ・把持なし
        POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
        POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
      END
    ELSE
      IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; 固定カメラ・把持あり
        POINT .valfa = .base_pos+v_master[.id,.result]; ティーチ位置でベースから見たマスターワーク把持位置
        POINT .adj_pos = .valfa-vwork[.id,1]; 現在ワーク位置に対するロボット位置(ツール先端)
      ELSE
; 固定カメラ・把持なし
        POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
        POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
      END
    END
  END
.END
.PROGRAM vget_result(); ビジョン結果取得
; FUNCTION: ビジョン結果取得
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vcommandと合わせて使用する
; --------------------------------
;
  v.error_cnt = 0;                           エラーカウント初期化
  .vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
  UTIMER .@vtime = 0;                        タイマーリセット
start:
  DO;                                        条件ループ開始
    IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
    TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
  UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
  CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
  GOTO end
check:
  IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
    CALL vstr_decode($vrecv_data[0]);        文字列分解
    $vres = $vst[0];                         計測結果代入
    SCASE $vres OF
     SVALUE "OK":;                           ビジョン結果ＯＫ
      v.err = verr_ok
     SVALUE "NG":;                           ビジョン計測ＮＧ
      v.err = VAL($vst[1]);                  エラーコード取得
      PRINT /X2,"ビジョンＮＧ : v.err = ",v.err
      SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
     ANY :;                                  不明なＮＧ
      CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
    END
  ELSE;                                      通信ＮＧ
    $vres = $vcom_res
    v.err = v.com_err
  END
end:
  SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vision(.cam_no,.mes_no); ビジョン計測
; FUNCTION: ビジョン計測[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: カメラ番号, 計測番号
;
  IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
    CALL vcom_init;                          ビジョン変数初期化
    SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
    PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
    CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
    IF .chk!=0 THEN
      CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
      RETURN;                                送信ＰＧ起動待ちタイムアウトエラー)
    END
  END
  SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
  SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
  .vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
  UTIMER .@vtime = 0;                        タイマーリセット
  DO;                                        条件ループ開始
    IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
    TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
  UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
  CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
  RETURN;                                    通信完了待ちタイムアウトエラー)
start:
  $vsend_data[0] = "VIS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+",";送信データ作成
  v.cam_no = .cam_no;                        カメラ番号代入
  v.mes_no = .mes_no;                        計測番号代入
  CALL vinit;                                計測結果クリア
  SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
  CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
  IF .chk!=0 THEN
    CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
    RETURN;                                  送信ＰＧ実行待ちタイムアウトエラー)
  END
.END
.PROGRAM vision_exe(.cam_no,.mes_no,.robot,.handeye,.have,.teach,.id,.calpos,.ret); ビジョン計測プログラム
; FUNCTION: ビジョン計測プログラム
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .cam_no  カメラ番号
;           .mes_no  計測番号
;           .robot   ロボット番号 下アーム:1, 上アーム:2
;           .handeye ハンドアイ:1, 固定:0
;           .have    把持あり:0, 把持なし:1
;           .teach   ティーチング用計測:1, 通常計測:0
;           .id      ビジョンID
;           .calpos  位置補正用計測:0, 装置補正1点目:1, 装置補正2点目:2, 3:ビジョンなし装置補正
;           .ret     計測結果
;
; ---------------------------------------------------------------------------------------
;   ※ビジョン計測プログラム実行条件（ロボット計測位置）
;   // 固定カメラ・把持なし      ：固定カメラ視野内にロボットがいないこと
;   // 固定カメラ・把持あり      ：把持ワークがカメラ視野内に写っている位置
;   // ハンドアイカメラ・把持なし：カメラ視野内にワークが写る位置
;   // ハンドアイカメラ・把持あり：位置不問・ワークを把持して視野内にワークがあること
; ---------------------------------------------------------------------------------------
;
  .ret = err_no_error
  .vid = .id
; ------------
; シミュレーション
; ------------
  IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    NOEXIST_SET_R vsim_result_ng[.vid] = OFF; シミュレータNGフラグ[ID]
    IF vsim_result_ng[.vid]==OFF THEN
; シミュレーションOK
      IF .teach<>OFF THEN
        POINT v_master[.vid,1] = TRANS(0,0,0,0,0,0)
        vc_cam[.vid] = .cam_no
        vc_mes[.vid] = .mes_no
        vc_rob[.vid] = .robot
        vc_handeye[.vid] = .handeye
        vc_have[.vid] = .have
        IF .calpos<>0 THEN
        ; 装置補正マスター登録ログ
          CALL vlog_cal(.vid,0,1,1)
        END
      ELSE
        .sx = vsim_x
        .sy = vsim_y
        .sz = vsim_z
        IF .calpos==2 THEN
          .sx = .sx+100; 装置補正２点目用
        END
        POINT vwork[.vid,1] = TRANS(.sx,.sy,.sz,0,0,0)
        ; 装置補正用計測実行フラグ
        IF .calpos==1 OR .calpos==2 THEN
          vequip_flg[.id] = ON
        END
      END
      vwork_res[.vid,1] = 1;
    ELSE
; シミュレーションNG (認識個数0個エラー)
      .ret = err_vis_recog0
      POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化
    END    
    RETURN
  END
;
; ------------
;   計測実施
; ------------
  CALL vision(.cam_no,.mes_no);                     ビジョン計測
  IF v.err==verr_init THEN;
    CALL vset_pos(.robot,.handeye,.have,.teach,.vid); 計測完了待兼補正位置作成
  END
  IF v.err<>0 THEN; 計測結果チェック
    PRINT /X2,"ビジョン計測エラー"
    .ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
    IF log_error_ena<>FALSE THEN
      CALL error_log(.ret)
    END
    RETURN; ビジョン計測エラー
  END
;
  IF .teach<>OFF THEN
; -----------------------------
;   ティーチ時はマスター登録
; -----------------------------
    IF v.num<>1 THEN
      PRINT /X2,"計測個数が複数あります"
      .ret = err_vis_teach; マスター登録時複数認識
      IF log_error_ena<>FALSE THEN
        CALL error_log(.ret)
      END
      RETURN; ビジョン計測エラー
    END
;
; ------------------------------
;   計測位置（フランジ）を記憶
; ------------------------------
    .temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
    POINT .tool_now = TRANS(,.temp_tool); ツール値作成
    POINT vis_point[.cam_no,.mes_no] = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
;
; ---------------------------------------
;   1個目の計測結果をマスターとして登録
; ---------------------------------------
    .res_no = v.result_no[1]; 結果番号
;
    .$cam = $ENCODE(/I1,.cam_no); カメラ番号
    IF .handeye<>OFF THEN
      .$chk = "vcam_tool["+.$cam+"]"
      IF EXISTDATA(.$chk,T)==OFF THEN
        .ret = err_vis_nocalib; キャリブレーションエラー
        RETURN;
      END
      IF .have==OFF THEN
; ハンドアイカメラ・把持あり
        POINT v_master[.vid,.res_no] = vcam_tool[.cam_no]+vision[1]; フランジから見たワーク位置
      ELSE
; ハンドアイカメラ・把持なし
        POINT v_master[.vid,.res_no] = vis_point[.cam_no,.mes_no]+vcam_tool[.cam_no]+vision[1]; ベースから見たワーク位置
      END
    ELSE
      .$chk = "vision_frm["+.$cam+"]"
      IF EXISTDATA(.$chk,T)==OFF THEN
        .ret = err_vis_nocalib; キャリブレーションエラー
        RETURN;
      END
      IF .have==OFF THEN
; 固定カメラ・把持あり
        POINT v_master[.vid,.res_no] = -vis_point[.cam_no,.mes_no]+vision_frm[.cam_no]+vision[1]; フランジから見たワーク把持位置
      ELSE
; 固定カメラ・把持なし
        POINT v_master[.vid,.res_no] = vision_frm[.cam_no]+vision[1]; ベースから見たワーク位置
      END
    END
;
; --------------------
;   補正番号に紐付け
; --------------------
    vc_cam[.vid] = .cam_no
    vc_mes[.vid] = .mes_no
    vc_rob[.vid] = .robot
    vc_handeye[.vid] = .handeye
    vc_have[.vid] = .have
    IF .calpos<>0 THEN
    ; 装置補正マスター登録ログ
      CALL vlog_cal(.vid,0,1,1)
    END
  ELSE
    ; 装置補正用計測実行フラグ
    IF .calpos==1 OR .calpos==2 THEN
      vequip_flg[.id] = ON
    END
  END
;
.END
.PROGRAM vset_pos(.robot,.handeye,.have,.teach,.id)
; FUNCTION: 補正位置データ作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .teach ティーチ時 -1, その他 -1以外
;
  v.error_cnt = 0;                           エラーカウント初期化
  .vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
  UTIMER .@vtime = 0;                        タイマーリセット
  POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化（１個目の結果のみ・複数対応時は必要認識個数分初期化する）
start:
  DO;                                        条件ループ開始
    IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
    TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
  UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
  CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
  GOTO end
check:
  IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
    CALL vstr_decode($vrecv_data[0]);        文字列分解
    $vres = $vst[0];                         計測結果代入
    SCASE $vres OF
     SVALUE "OK":;                           ビジョン計測ＯＫ
      v.err = verr_ok
      GOTO ok
     SVALUE "NG":;                           ビジョン計測ＮＧ
      v.err = VAL($vst[1]);                  エラーコード取得
      PRINT /X2,"ビジョン計測ＮＧ : v.err = ",v.err
      IF v.err==vis_err_vid OR v.err==vis_err_num GOTO ng;K-VFinderのエラーコード[2:画像取込エラー, 6:検出個数0個エラー]
      SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
     ANY :;                                  不明なＮＧ
      CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
    END
    GOTO end
ok:; 計測ＯＫの場合補正データ作成
    v.num = VAL($vst[1]);                    検出個数取得
    IF v.num>0 THEN
      FOR .i = 1 TO v.num;                     検出個数分繰り返す
        CALL vstr_decode($vrecv_data[.i]);   文字列分解
        .vres_no = VAL($vst[0]);             結果番号
        .vpos_x = VAL($vst[1]);              Ｘ座標
        .vpos_y = VAL($vst[2]);              Ｙ座標
        .vpos_t = 0
        .vpos_t = VAL($vst[3]);              θ
        v.result_no[.i] = .vres_no;          結果番号代入
        POINT vision[.i] = TRANS(.vpos_x,.vpos_y,0,.vpos_t); ビジョン座標値(mm)
;
        IF .teach==OFF THEN;                 補正位置計算
          .$cam = $ENCODE(/I1,v.cam_no);     カメラ番号文字列
          .temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
          POINT .tool_now = TRANS(,.temp_tool); ツール値作成
          POINT .h = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
          IF .handeye<>OFF THEN
            .$chk = "vcam_tool["+.$cam+"]"
            IF EXISTDATA(.$chk,T)==OFF THEN
              v.err = 5; キャリブレーションエラー
              GOTO end;
            END
            IF .have==OFF THEN
              POINT vwork[.id,.i] = vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持あり・フランジから見たワーク位置
            ELSE
              POINT vwork[.id,.i] = .h+vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持なし・ベースから見たワーク位置
            END
          ELSE
            .$chk = "vision_frm["+.$cam+"]"
            IF EXISTDATA(.$chk,T)==OFF THEN
              v.err = 5; キャリブレーションエラー
              GOTO end;
            END
            IF .have==OFF THEN
              POINT vwork[.id,.i] = -.h+vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持あり・フランジから見たワーク把持位置
            ELSE
              POINT vwork[.id,.i] = vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持なし・ベースから見たワーク位置
            END
          END
          vwork_res[.id,.i] = v.result_no[.i]; 結果番号
        END
      END
    END
  ELSE;                                      通信ＮＧ
    $vres = $vcom_res
    v.err = v.com_err
  END
  GOTO end
ng:; 計測ＮＧ[v.err=2(画像取込エラー) or v.err=6(検出個数0個エラー)]の場合リトライ処理
  v.error_cnt = v.error_cnt+1;               送受信エラーカウントアップ
  IF v.error_cnt>=vretry_max+1 THEN;         エラー回数確認
    PRINT /X2,"リトライ回数上限エラー"
    SIGNAL ix_vcomm_error;                   エラー信号ＯＮ
    GOTO end;                                リトライ回数上限超えの為終了
  ELSE
    PRINT /X2,"計測リトライ : "+$ENCODE(/I2,v.error_cnt)+" 回目"
    SIGNAL -ix_vcomm_comp;                   通信完了信号ＯＦＦ
    TWAIT vretry_wait;                       リトライ前待ち
    SIGNAL ix_vcomm_start;                   通信開始信号ＯＮ
    GOTO start;                              通信完了待ち
  END
end:
  SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vcorrect_table(.&base_pos,.id,.&adj_pos); 装置間補正
; FUNCTION: 装置間補正
; NOTE    : ver1.0.0[15/10/02]
;
; 1点目と2点目の装置IDを取得
  CALL convert_vid(mode_add,1,.id,.equip_id1)
  CALL convert_vid(mode_add,2,.id,.equip_id2)
;
  POINT vtable_m = FRAME(v_master[.equip_id1,1],v_master[.equip_id2,1],TRANS(,,100)+v_master[.equip_id1,1],v_master[.equip_id1,1])
  POINT vtable_m = vtable_m+RX(-90); マスター穴で作成したフレーム
;
  POINT/Z vwork[.equip_id1,1] = v_master[.equip_id1,1]
  POINT/Z vwork[.equip_id2,1] = v_master[.equip_id2,1]
  POINT vtable_w = FRAME(vwork[.equip_id1,1],vwork[.equip_id2,1],TRANS(,,100)+vwork[.equip_id1,1],vwork[.equip_id1,1])
  POINT vtable_w = vtable_w+RX(-90); 現在の穴で作成したフレーム
;
  POINT .valfa = -vtable_m+.base_pos; マスターフレームから見た教示位置
  POINT .adj_pos = vtable_w+.valfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
  .a = DEXT(.adj_pos,4)
  .t = DEXT(.adj_pos,6)
  POINT/OAT .adj_pos = TRANS(,,,.a+.t,,0)
;
.END
.PROGRAM vcalib_comp(.cam_no,.ret); キャリブレーション完了
; FUNCTION: キャリブ完了処理(フレーム作成)
; NOTE    : ver1.0.0[15/10/02]
;
  .ret = err_no_error
; ------------
; シミュレーション
; ------------
  IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    NOEXIST_SET_R vsim_result_ng[9999] = OFF; シミュレータNGフラグ[ID]
    IF vsim_result_ng[9999]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
      .ret = err_vis_calend
    END    
    RETURN
  END
;
  .$vsend = "CAE,"+$ENCODE(/I1,.cam_no)+",";送信データ作成
  CALL vcommand(.$vsend);
  CALL vget_result;
  IF v.err<>0 THEN
    PRINT /X2,"キャリブレーション完了エラー"
    .ret = err_vis_calend
  END
.END
.PROGRAM vcalib_exe(.robot,.cam_no,.mes_no,.handeye,.&target,.dist,.nige,.&tool_p,.ret); キャリブレーション実行
; FUNCTION: キャリブレーション
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .cam_no  カメラ番号
;           .mes_no  計測番号
;           .handeye ハンドアイ:1, 固定:0
;           .target  ターゲット位置
;           .dist    移動距離
;           .nige    逃げ高さ
;           .tool_p  ツール位置
;           .ret     計測結果
;
  .ret = err_no_error;
;
  .sp = 100
  ABS.SPEED .robot: ON
  SPEED .sp MM/S ALWAYS
;
  .accu = 1
  ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
  ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
  ACCURACY 1 ALWAYS
;
; ----------------------------------------------------
;   キャリブ原点はダイレクトティーチで教えておくこと
; ----------------------------------------------------
  POINT vcalib_o[.cam_no] = S_HERE(.robot); ダイレクトティーチの点を原点とする
;
; ----------------------------------------------------
;   K-VFinderへキャリブレーション開始を伝える
; ----------------------------------------------------
  CALL vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
  IF .ret!=err_no_error GOTO end
;
; -------------------------------------------
;   原点へ移動（変換値：フランジ位置を記憶）
; -------------------------------------------
  JMOVE vcalib_o[.cam_no]; O計測点
  BREAK
;
; ----------------------
;   原点でビジョン計測
; ----------------------
  TWAIT 1; ロボット停止待ち
  CALL vcalib_vis(.cam_no,1,.ret); 原点計測
  JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
  IF .ret!=err_no_error GOTO end
;  
; -----------------------------------------------------
;   ツールX+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
  POINT vcalib_x[.cam_no] = vcalib_o[.cam_no]+TRANS(.dist); 変換値の計算(X+)
  JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
  JMOVE vcalib_x[.cam_no]; X+計測点
  BREAK
;
; ----------------------
;   X点でビジョン計測
; ----------------------
  TWAIT 1; ロボット停止待ち
  CALL vcalib_vis(.cam_no,2,.ret); X点計測
  JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
  IF .ret!=err_no_error GOTO end
;
; -----------------------------------------------------
;   ツールY+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
  POINT vcalib_y[.cam_no] = vcalib_o[.cam_no]+TRANS(,.dist); 変換値の計算(Y+)
  JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
  JMOVE vcalib_y[.cam_no]; Y+計測点
  BREAK
;
; ----------------------
;   Y点でビジョン計測
; ----------------------
  TWAIT 1; ロボット停止待ち
  CALL vcalib_vis(.cam_no,3,.ret); Y点計測
  JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
  IF .ret!=err_no_error GOTO end
;
; ---------------------------------------------------------------
;   K-VFinderにキャリブレーション完了を伝え、フレームを作成する
; ---------------------------------------------------------------
  CALL vcalib_comp(.cam_no,.ret); キャリブレーション完了
  IF .ret!=err_no_error GOTO end
;
  IF .handeye==OFF THEN
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
    POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
    POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
    POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
    POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
    POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
    POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
  ELSE
; ----------------------------------------------------------------------------------------------
;   カメラツール位置の生成(ハンドアイ）
; ----------------------------------------------------------------------------------------------
    POINT vcalh[.cam_no] = .target
    POINT .v = vcalh[.cam_no]+.tool_p; ツール込みでのターゲット位置
    POINT vcam_o[.cam_no] = -vcalib_o[.cam_no]+.v
    POINT vcam_x[.cam_no] = -vcalib_x[.cam_no]+.v
    POINT vcam_y[.cam_no] = -vcalib_y[.cam_no]+.v
    POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
    POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
    POINT vcam_tool[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]);
  END
; ----------------------------------------------------------------------------------------------
;   キャリブレーションで使用したパラメータをカメラ番号ごとに保存(vcalib_checkで使用)
; ----------------------------------------------------------------------------------------------
  vcal_robot[.cam_no] = .robot;     ロボット番号
  vcal_mes[.cam_no] = .mes_no;      計測番号
  vcal_handeye[.cam_no] = .handeye; ハンドアイフラグ
  vcal_dist[.cam_no] = .dist;       移動距離記憶
  vcal_nige[.cam_no] = .nige;       逃げ量記憶
  POINT vcal_tool[.cam_no] = .tool_p; ツール記憶
;
end:
;
; -------------------------------------------
;   原点へ戻る
; -------------------------------------------
  JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
  JMOVE vcalib_o[.cam_no]; O計測点
  BREAK
  ABS.SPEED .robot: OFF
.END
.PROGRAM vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
; FUNCTION: キャリブ開始処理
; NOTE    : ver1.0.0[15/10/02]
;
  .ret = err_no_error
; ------------
; シミュレーション
; ------------
  IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    NOEXIST_SET_R vsim_result_ng[9997] = OFF; シミュレータNGフラグ[ID]
    IF vsim_result_ng[9997]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
      .ret = err_vis_calst
    END    
    RETURN
  END
;
  .$vsend = "CAS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+","+$ENCODE(/F6.2,.dist)+",";送信データ作成
  CALL vcommand(.$vsend);
  CALL vget_result;
  IF v.err<>0 THEN
    PRINT /X2,"キャリブレーション開始エラー"
    .ret = err_vis_calst;
  END
.END
.PROGRAM vcalib_vis(.cam_no,.count,.ret); キャリブレーション計測
; FUNCTION: キャリブ計測処理
; NOTE    : ver1.0.0[15/10/02]
;
  .ret = err_no_error
; ------------
; シミュレーション
; ------------
  IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    NOEXIST_SET_R vsim_result_ng[9998] = OFF; シミュレータNGフラグ[ID]
    IF vsim_result_ng[9998]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
      .ret = err_vis_calmeas
    END    
    RETURN
  END
;
  .$vsend = "CAL,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I1,.count)+",";送信データ作成
  CALL vcommand(.$vsend);
  CALL vget_result;
  IF v.err<>0 THEN
    PRINT /X2,"キャリブレーション計測エラー"
    .ret = err_vis_calmeas;
  END
.END
.PROGRAM vless_calmain(.rno,.id,.&tool_p,.&p1,.&p2,.recflg,.ret)
;-------------------------------- 
;機能：ビジョンなし装置補正メイン
;引数：ロボット番号、ビジョンID、ツール、１点目座標、２点目座標、マスター登録フラグ(1:マスター登録,2:補正実行）
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.VISION==TRUE THEN
        PRINT "vless_calmain()->.rno=",.rno
        PRINT "vless_calmain()->.id=",.id
        DECOMPOSE .buf1[1]=.tool_p
        PRINT "vless_calmain()->.tool_x=",.buf1[1]
        PRINT "vless_calmain()->.tool_y=",.buf1[2]
        PRINT "vless_calmain()->.tool_z=",.buf1[3]
        PRINT "vless_calmain()->.tool_o=",.buf1[4]
        PRINT "vless_calmain()->.tool_a=",.buf1[5]
        PRINT "vless_calmain()->.tool_t=",.buf1[6]
        DECOMPOSE .buf2[1]=.p1
        PRINT "vless_calmain()->.p1_x=",.buf2[1]
        PRINT "vless_calmain()->.p1_y=",.buf2[2]
        PRINT "vless_calmain()->.p1_z=",.buf2[3]
        PRINT "vless_calmain()->.p1_o=",.buf2[4]
        PRINT "vless_calmain()->.p1_a=",.buf2[5]
        PRINT "vless_calmain()->.p1_t=",.buf2[6]
        DECOMPOSE .buf3[1]=.p2
        PRINT "vless_calmain()->.p2_x=",.buf3[1]
        PRINT "vless_calmain()->.p2_y=",.buf3[2]
        PRINT "vless_calmain()->.p2_z=",.buf3[3]
        PRINT "vless_calmain()->.p2_o=",.buf3[4]
        PRINT "vless_calmain()->.p2_a=",.buf3[5]
        PRINT "vless_calmain()->.p2_t=",.buf3[6]
        PRINT "vless_calmain()->.recflg=",.recflg
    END
    ; ID変換
    CALL convert_vid(mode_add,TYPE_DEVICE3,.id,.vid);      calposに合わせてID変換 calpos=3:ID=3001〜3999
    IF .recflg == 1 THEN
      ; マスター登録 v_masterを流用　２つ目の引数要素で１点目２点目を判別（ビジョンありはIDで判別しているので注意）
      POINT v_master[.vid,1] = .p1
      POINT v_master[.vid,2] = .p2
      POINT vless_tool[.vid] = .tool_p
      CALL vlog_cal(.vid,0,0,1)
    ELSE
      POINT vwork[.vid,1] = .p1
      POINT vwork[.vid,2] = .p2
;
      NOEXIST_SET_R vc_chkflg[.id] = OFF
      IF vc_chkflg[.id]<>OFF THEN
        ; 位置ズレチェック
        .dist1 = DISTANCE(v_master[.vid,1],vwork[.vid,1]); 装置1点目の位置ズレ量
        .dist2 = DISTANCE(v_master[.vid,2],vwork[.vid,2]); 装置2点目の位置ズレ量
        NOEXIST_SET_R vc_poschk[.id] = 100
        IF .dist1>vc_poschk[.id] OR .dist2>vc_poschk[.id] THEN; 閾値判定
          .ret = err_vis_poschk
          IF log_error_ena<>FALSE THEN
            CALL error_log(.ret)
          END
          RETURN
        END
        ; 距離ズレチェック
        .dist1 = DISTANCE(v_master[.vid,1],v_master[.vid,2])
        .dist2 = DISTANCE(vwork[.vid,1],vwork[.vid,2])
        NOEXIST_SET_R vc_distchk = 5
        IF ABS(.dist1-.dist2)>vc_distchk THEN
          .ret = err_vis_distchk
          IF log_error_ena<>FALSE THEN
            CALL error_log(.ret)
          END
          RETURN
        END
      END
      ;第2、第3階層を探索
      FOR .i=1 TO DATA_L2NUM
          FOR .j=1 TO DATA_L3NUM[.i]
              IF DATA_L3TYPE[.i,.j]==L3TYPE_MOVE THEN
                  IF DATA_MODE[.i,.j]==MODE_JT THEN
                      ;各軸値
                  ELSE
                      ;変換値
                      IF .id==data_vision_id1[.i,.j] THEN; 計算実行する装置IDと動作の装置ID(DATA_VISION_ID)が一致
                          POINT .in_pos = TRANS(data_pos1[.i,.j],data_pos2[.i,.j],data_pos3[.i,.j],data_pos4[.i,.j],0,0); 変換値
                          CALL vless_calexe(.&in_pos,.&tool_p,.vid,.&out_pos); 装置補正実行
                          DECOMPOSE .out_p[1] = .out_pos; 補正後の変換値分解
                          ; 補正値を書き換え
                          data_pos1[.i,.j] = .out_p[1]
                          data_pos2[.i,.j] = .out_p[2]
                          data_pos3[.i,.j] = .out_p[3]
                          data_pos4[.i,.j] = .out_p[4]
                          data_pos5[.i,.j] = 0
                          data_pos6[.i,.j] = 0
                      END
                  END
              END
          END
      END
      ; ログのため前回マスター値バックアップ
      POINT vless_bk[.vid,1] = v_master[.vid,1]
      POINT vless_bk[.vid,2] = v_master[.vid,2]
      POINT vless_tool_bk[.vid] = vless_tool[.vid]
      ; 実行後、装置補正計測結果のマスターを現在値で上書き
      POINT v_master[.vid,1] = .p1
      POINT v_master[.vid,2] = .p2
      POINT vless_tool[.vid] = .tool_p
      CALL vlog_cal(.vid,0,0,0)
    END
.END
.PROGRAM vlog_cal(.id1,.id2,.vonoff,.master)
;-------------------------------- 
;機能：装置補正ログ
;引数：装置ＩＤ(1点目),装置ＩＤ(2点目), ビジョンあり(1)/なし(0),マスター登録(1)orNot(0)
;戻値：なし
;--------------------------------
  NOEXIST_SET_R vlog_cal_cnt = 0;  ログカウンタ
  NOEXIST_SET_R vlog_cal_max = 10; ログ最大数   
  .$log = $DATE(3)+" "+$TIME+" "; ログデータ作成
  IF .master==0 THEN
    .$mas = "[EXE]:"
  ELSE
    .$mas = "[MASTER]:"
  END
  IF .vonoff==0 THEN
; ビジョンなし
    .$vcal="VLESSCAL"
    .id2 = .id1; ２点目のIDはビジョンなしでは関係ない
    DECOMPOSE .temp1[1] = v_master[.id1,1]
    .$vmas1 = "v_master["+$ENCODE(/I4,.id1)+",1]= "
    DECOMPOSE .temp2[1] = v_master[.id1,2]
    .$vmas2 = "v_master["+$ENCODE(/I4,.id1)+",2]= "
  ELSE
; ビジョンあり
    .$vcal="VCAL"
    DECOMPOSE .temp1[1] = v_master[.id1,1]
    .$vmas1 = "v_master["+$ENCODE(/I4,.id1)+",1]= "
    IF .master==0 THEN; マスター登録の時は１点だけ
      DECOMPOSE .temp2[1] = v_master[.id2,1]
      .$vmas2 = "v_master["+$ENCODE(/I4,.id2)+",1]= "
    END
  END
  .$log = .$log+.$vcal+.$mas+.$vmas1
  .$log = .$log+$ENCODE(/F8.3,.temp1[1])+" "+$ENCODE(/F8.3,.temp1[2])+" "+$ENCODE(/F8.3,.temp1[3])+" "+$ENCODE(/F8.3,.temp1[4])+" "
  IF .vonoff==0 OR .master==0 THEN; ビジョンあり,マスター登録は１点だけ
    .$log = .$log+.$vmas2
    .$log = .$log+$ENCODE(/F8.3,.temp2[1])+" "+$ENCODE(/F8.3,.temp2[2])+" "+$ENCODE(/F8.3,.temp2[3])+" "+$ENCODE(/F8.3,.temp2[4])+" "
  END
  $vlog_cal[vlog_cal_cnt] = .$log
  vlog_cal_cnt = vlog_cal_cnt+1; 次のログへ
  IF vlog_cal_cnt>vlog_cal_max THEN
    vlog_cal_cnt = 0; 一定数超えたら最初から上書き
  END
.END
.PROGRAM vcalib_check(.cam_no,.mes_no,.robot_no,.handeye,.correct_no,.nige,.ret); キャリブレーション精度チェック
; FUNCTION: キャリブレーション精度チェック
; NOTE    : ver1.0.0[16/04/08]
;
  .ret = err_no_error;
; --------------------------------------
;   パラメータセット
; --------------------------------------
  IF .handeye==1 THEN
    .have = 0;
    .rot90 = -90
    .rot135 = -135
    .rot180 = -180
  ELSE
    .have = 1; 
    .rot90 = 90
    .rot135 = 135
    .rot180 = 180
  END
;
  .sp = 100
  .sp2 = 80
  ABS.SPEED .robot_no: ON
  SPEED .sp MM/S ALWAYS
;
  .accu = 1
  ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
  ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
  ACCURACY 1 ALWAYS
; --------------------------------------
;   リトライフラグリセット
; --------------------------------------
  vchk_retry = 0
start:
;
; --------------------------------------
;   ターゲット位置を基準登録＆計測実施
; --------------------------------------
  CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,1,.correct_no,0,.ret)
  IF .ret<>0 GOTO end
  CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
  IF .ret<>0 GOTO end
  POINT/OAT vwork[.correct_no,1] = v_master[.correct_no,1]; 計測結果はOAT回転していないものとする
;
; --------------------------------------
;   ロボット位置＆計測結果を保存
; --------------------------------------
  POINT vcheck_point1[.cam_no] = S_HERE(.robot_no)
  POINT vcheck_work1[.cam_no] = vwork[.correct_no,1]
;
; --------------------------------------------------
;  ターゲット位置を90°,180°回転させた補正位置を作成
; --------------------------------------------------
  POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot90)
  CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu[.cam_no]); 現在値を90°回転させた位置
  POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot135)
  CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu2[.cam_no]); 現在値を135°回転させた位置
  POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot180)
  CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_point2[.cam_no]); 現在値を180°回転させた位置
;
  IF .nige<>0 THEN
    POINT .app1[.cam_no] = TRANS(,,.nige)+vcheck_point1[.cam_no]
    POINT vcheck_tyuu[.cam_no] = TRANS(,,.nige)+vcheck_tyuu[.cam_no]
    POINT vcheck_tyuu2[.cam_no] = TRANS(,,.nige)+vcheck_tyuu2[.cam_no]
    POINT .app2[.cam_no] = TRANS(,,.nige)+vcheck_point2[.cam_no]
    ZL3LMOVE .app1[.cam_no],1,1; 現在位置上空
    BREAK
    ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
    BREAK
    ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
    BREAK
    ABS.SPEED .robot_no: ON
    SPEED .sp2 MM/S
    ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
  ELSE
    ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
    BREAK
    ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
  END
  BREAK
  ABS.SPEED .robot_no: ON
  SPEED .sp2 MM/S
  JMOVE vcheck_point2[.cam_no]; 180°回転した位置
  BREAK
; --------------------------------------------------
;  180°回転した位置で再度ビジョン計測
; --------------------------------------------------
  TWAIT 0.5
  CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
  IF .ret<>0 THEN
    vchk_retry = 0
    GOTO return;
  END    
;
; --------------------------------------------------
;  0°・180°での計測結果のXY座標のみを取り出し
; --------------------------------------------------
  IF .handeye==1 THEN
    POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
    POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
    POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
    vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
    vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
    IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
      POINT vcheck_temp[.cam_no] = vcam_tool[.cam_no]; 現在のキャリブデータをバックアップ
      POINT vcam_tool[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vcam_tool[.cam_no]; ズレ量を補正
    END
  ELSE
    POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
    POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
    POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
    vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
    vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
    IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
      POINT vcheck_temp[.cam_no] = vision_frm[.cam_no]; 現在のキャリブデータをバックアップ
      POINT vision_frm[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vision_frm[.cam_no]; ズレ量を補正
    END
  END
;
  PRINT /X2,"X ACCURACY = ",vcheck_x[.cam_no],"mm"
  PRINT /X2,"Y ACCURACY = ",vcheck_y[.cam_no],"mm"
  IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
    vchk_retry = vchk_retry+1;
    IF vchk_retry>=5 THEN
      PRINT /X2,"Calib check error. check vision recognition."
    ELSE
      PRINT /X2, "Execute calib re-check, because accuracy is over 0.1mm"
    END
  ELSE
    vchk_retry = 0;
    PRINT /X2, "Calib check OK."
  END
;
; --------------------------------------------------
;  元の位置に戻る
; --------------------------------------------------
return:
  IF .nige<>0 THEN
    ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
    BREAK
    ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
    BREAK
    ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
    BREAK
    ZL3LMOVE .app1[.cam_no],1,1; 開始位置上空
  ELSE
    ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
    BREAK
    ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
  END
  BREAK
  JMOVE vcheck_point1[.cam_no]; 開始位置
  BREAK
  IF vchk_retry>=5 THEN
    .ret = err_vis_chkng; 精度チェックエラー
    RETURN   
  END
  IF vchk_retry>0 GOTO start; リトライ実施
end:
  ABS.SPEED .robot_no: OFF
  vcalchk_nige[.cam_no] = .nige
.END
.*****************************************************************
.*                    UDP/IP通信標準プログラム                    
.*                                                                
.*   ■version                                                    
.*                                                   ATBU0000     
.*                                                                
.*   ■history                                                    
.*       2013/06/27                                               
.*                   新規作成                        Y.Fujimoto   
.*       2014/01/30                                               
.*       vcom_init, vision, vset_pos以外をvcom_udp.pgへ移動       
.*       (編集要PGと編集不要PGでファイル分けするため)             
.*                                                   S.O-no       
.*       2014/02/24                                               
.*                   ログ保存方法変更(種別フラグにて判断)         
.*                                                   Y.Fujimoto   
.*       2014/03/25                                               
.*       バージョン変数「$appli_ver_v」追加 ⇒ 正式出図           
.*                                                   S.O-no       
.*       2015/10/02                                               
.*       クリーンＤコン用にアプリ改良 ⇒ ATBU0000として出図       
.*                                                   S.O-no       
.*                                                                
.*****************************************************************
.PROGRAM pc3_handshake(.sig_no)
.*****************************************************************
; FUNCTION: ハンドシェイク待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .sig_no : 信号番号
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  WHILE SIG(-.sig_no) DO
    TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
  END
  SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc3_sig_change(.res,.sig_no,.timeout)
.*****************************************************************
; FUNCTION: タイムアウト付き信号状態変更待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .sig_no : 信号番号
.*          .timeout : タイムアウト時間(sec)
.* [RETURN]
.*          .res : 結果[0:OK,-1:NG(タイムアウト)]
.*////////////////////////////////////////////////////////////////
  .res = 0
  UTIMER .@vtime = 0;                        タイマーリセット
  DO;                                        条件ループ開始
    IF SIG(.sig_no) GOTO end
    TWAIT ascycle;                           信号の状態変更待ち
  UNTIL UTIMER(.@vtime)>=.timeout;           タイムアウトするまで
  .res = -1
end:
.END
.PROGRAM pc3_vcom_send()
.*****************************************************************
; FUNCTION: UDP/IP通信 送信[PC3]
; NOTE    : ver1.0.0[14/03/06]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          なし
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  v.com_err = verr_init;                     通信結果クリア(変数定義用)
  $vcom_res = "";                            エラー内容クリア(変数定義用)
  SIGNAL -ix_vcomm_comp,-ix_vcomm_error;     通信完了信号＆通信エラー信号ＯＦＦ
  SIGNAL -ix_vcomm_start,-ix_vcomm_busy;     通信開始信号＆通信中信号ＯＦＦ
  CALL pc3_vcom_log(0,"送信ＰＧ起動")
  SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
  CALL pc3_vcom_log(0,"通信開始信号待ち...")
  CALL pc3_handshake(ix_vcomm_start);        通信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
  IF SIG(ix_vsend_only) AND SIG (ix_vrecv_only) THEN
    CALL pc3_vcom_error(verr_onlymode,"片方向通信モードエラー");片方向通信モードエラー
    HALT;                                    停止(片方向通信モードエラー)
  END
  CALL pc3_vcom_log(0,"通信開始")
  SIGNAL ix_vcomm_busy;                      通信中信号ＯＮ
  IF SIG(ix_vsend_only) GOTO start;          送信のみ信号ＯＮ時は受信ＰＧ起動確認なし
  CALL pc3_vcom_log(0,"受信ＰＧ起動確認")
  IF TASK(1004)<>1 THEN;                     受信ＰＧ起動確認
    CALL pc3_vcom_log(0,"受信ＰＧ起動実行")
    SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
    PCEXECUTE 4: pc4_vcom_recv;              受信ＰＧ起動
    CALL pc3_vcom_log(0,"受信ＰＧ起動完了待ち...")
    CALL vchk_pc_start(.chk,1004);           受信ＰＧ[PC4]起動確認
    IF .chk!=0 THEN
      CALL pc3_vcom_error(verr_timeout3,"受信ＰＧ起動待ちタイムアウトエラー");受信ＰＧ待ちタイムアウトエラー
      HALT;                                  停止(受信ＰＧ起動待ちタイムアウトエラー)
    END
  END
  CALL pc3_vcom_log(0,"受信ＰＧ起動確認完了")
start:; 送受信開始
  v.com_err = verr_init;                     通信結果クリア
  $vcom_res = "";                            エラー内容クリア
  IF SIG(ix_vsend_only) GOTO send;           送信のみ信号ＯＮ時は受信ＰＧ起動なし
  SIGNAL -ix_vrecv_comp,ix_vrecv_start;      受信完了信号ＯＦＦ＆受信開始信号ＯＮ
  CALL pc3_vcom_log(0,"受信開始待ち...")
  CALL pc3_sig_change(.chk,-ix_vrecv_start,vhandshake_time);受信開始信号ＯＦＦ待ち
  IF .chk!=0 THEN
    CALL pc3_vcom_error(verr_timeout1,"受信開始待ちタイムアウトエラー");受信開始待ちタイムアウトエラー
    HALT;                                    停止(受信開始待ちタイムアウトエラー)
  END
  IF SIG(ix_vrecv_only) GOTO recv;           受信のみ信号ＯＮ時は送信なし
send:; 送信
  CALL pc3_vcom_log(0,"送信開始")
  UDP_SENDTO .vstatus_send,vsend_ip[0],vsend_port,$vsend_data[0],vsend_num,vsend_timeout
  IF .vstatus_send<>0 THEN;                  送信ステータス確認
    .$log = "送信エラー : "+$ENCODE(/I6,.vstatus_send)
    CALL pc3_vcom_error(verr_send,.$log);    送信エラー
    HALT;                                    停止(送信エラー)
  ELSE
    .$log = "送信完了 ["+$ENCODE(/I2,vsend_num)+"] -> "+$vsend_data[0]
    CALL pc3_vcom_log(0,.$log)
  END
  IF SIG(ix_vsend_only) GOTO end;            送信のみ信号ＯＮ時は受信完了待ちなし
recv:; 受信
  CALL pc3_vcom_log(0,"受信完了待ち...")
  CALL pc3_sig_change(.chk,ix_vrecv_comp,vrecv_timeout+0.2);受信完了信号ＯＮ待ち
  IF .chk!=0 THEN
    IF v.com_err==verr_init THEN
      CALL pc3_vcom_error(verr_timeout2,"受信完了待ちタイムアウトエラー");受信完了待ちタイムアウトエラー
    END
    HALT;                                    停止(受信完了待ちタイムアウトエラー)
  END
end:; 通信完了処理
  CALL pc3_vcom_log(0,"通信完了")
  v.com_err = verr_ok
  SIGNAL -ix_vcomm_busy,ix_vcomm_comp;       通信中信号ＯＦＦ＆通信完了信号ＯＮ
  GOTO loop
.END
.PROGRAM pc3_vcom_error(.err,.$res)
.*****************************************************************
; FUNCTION: エラーコード＆内容セット[PC3]
; NOTE    : ver1.0.0[14/02/24]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .err : エラー番号
.*          .$res : エラー内容
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  v.com_err = .err
  $vcom_res = .$res
  PRINT /X2,$vcom_res," in pc3_vcom_send : ",v.com_err;エラー内容表示
  CALL pc3_vcom_log(1,.$res);                ログ保存
  SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc3_vcom_log(.class,.$string)
.*****************************************************************
; FUNCTION: ログ作成[PC3]
; NOTE    : ver1.0.0[14/02/24]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .class : ログ種別[0:情報, 1:エラー]
.*          .$string : ログ内容
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
    .$log = $DATE(3)+" "+$TIME+" [pc3_vcom_send] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
    $vlog[1,vlog_cnt[1]] = .$log;            ログデータ保存
    vlog_cnt[1] = vlog_cnt[1]+1;             ログカウンタカウントアップ
    IF vlog_cnt[1]>vlog_max THEN;            ログカウンタ上限超えの為リセット
      vlog_cnt[1] = 1
    END
  END
.END
.PROGRAM pc4_handshake(.sig_no)
.*****************************************************************
; FUNCTION: ハンドシェイク待ち[PC4]
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .sig_no : 信号番号
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  WHILE SIG(-.sig_no) DO
    TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
  END
  SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc4_vcom_recv()
.*****************************************************************
; FUNCTION: UDP/IP通信 受信[PC4]
; NOTE    : ver1.0.0[14/02/24]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          なし
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  SIGNAL -ix_vrecv_start,-ix_vrecv_comp;     受信開始信号＆受信完了信号ＯＦＦ
  CALL pc4_vcom_log(0,"受信ＰＧ起動")
  SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
  CALL pc4_handshake(ix_vrecv_start);        受信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
  CALL pc4_vcom_log(0,"受信開始")
  UDP_RECVFROM .vstatus_recv,vrecv_port,$vrecv_data[0],vrecv_num,vrecv_timeout,vrecv_ip[0],vrecv_str_num
  IF .vstatus_recv<>0 THEN;                  受信ステータス確認
    IF v.com_err==verr_init THEN
      .$log = "受信エラー : "+$ENCODE(/I6,.vstatus_recv)
      CALL pc4_vcom_error(verr_recv,.$log);  受信エラー
    END
    HALT;                                    停止(受信エラー)
  ELSE
    .$log = "受信完了 ["+$ENCODE(/I2,vrecv_num)+"] <- "+$vrecv_data[0]
    CALL pc4_vcom_log(0,.$log)
  END
  SIGNAL ix_vrecv_comp;                      受信完了信号ＯＮ
  GOTO loop
.END
.PROGRAM pc4_vcom_error(.err,.$res)
.*****************************************************************
; FUNCTION: エラーコード＆内容セット[PC4]
; NOTE    : ver1.0.0[14/02/24]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .err : エラー番号
.*          .$res : エラー内容
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  v.com_err = .err
  $vcom_res = .$res
  PRINT /X2,$vcom_res," in pc4_vcom_recv : ",v.com_err;エラー内容表示
  CALL pc4_vcom_log(1,.$res);                ログ保存
  SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc4_vcom_log(.class,.$string)
.*****************************************************************
; FUNCTION: ログ作成[PC4]
; NOTE    : ver1.0.0[14/02/24]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .class : ログ種別[0:情報, 1:エラー]
.*          .$string : ログ内容
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
    .$log = $DATE(3)+" "+$TIME+" [pc4_vcom_recv] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
    $vlog[2,vlog_cnt[2]] = .$log;            ログデータ保存
    vlog_cnt[2] = vlog_cnt[2]+1;             ログカウンタカウントアップ
    IF vlog_cnt[2]>vlog_max THEN;            ログカウンタ上限超えの為リセット
      vlog_cnt[2] = 1
    END
  END
.END
.PROGRAM vchk_pc_start(.res,.task_no)
.*****************************************************************
; FUNCTION: ＰＣプログラム起動確認
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .task_no : タスク番号
.* [RETURN]
.*          .res : 結果[0:OK,-1:NG(タイムアウト)]
.*////////////////////////////////////////////////////////////////
  .res = 0
  UTIMER .@vtime = 0;                        タイマーリセット
  DO;                                        条件ループ開始
    IF TASK(.task_no)==1 GOTO next
    TWAIT ascycle;                           ＰＣプログラム起動待ち
  UNTIL UTIMER(.@vtime)>=vpc_start_time;     タイムアウトするまで
next:
  DO;                                        条件ループ開始
    IF SIG(-ix_pc_start) GOTO end
    TWAIT ascycle;                           ＰＣプログラム起動確認信号ＯＦＦ待ち
  UNTIL UTIMER(.@vtime)>=vpc_start_time;     タイムアウトするまで
  .res = -1
end:
.END
.PROGRAM vchk_sig_change(.res,.sig_no,.timeout)
.*****************************************************************
; FUNCTION: タイムアウト付き信号状態変更待ち
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .sig_no : 信号番号
.*          .timeout : タイムアウト時間(sec)
.* [RETURN]
.*          .res : 結果[0:OK,-1:NG(タイムアウト)]
.*////////////////////////////////////////////////////////////////
  .res = 0
  UTIMER .@vtime = 0;                        タイマーリセット
  DO;                                        条件ループ開始
    IF SIG(.sig_no) GOTO end
    TWAIT ascycle;                           信号の状態変更待ち
  UNTIL UTIMER(.@vtime)>=.timeout;           タイムアウトするまで
  .res = -1
end:
.END
.PROGRAM vinit()
.*****************************************************************
; FUNCTION: ビジョン計測結果クリア
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          なし
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  $vres = ""
  v.err = verr_init;                         計測結果クリア[90:未計測, 0:OK, 0<>:NG]
  v.num = 0;                                 検出個数クリア
  POINT vision[1] = TRANS(vis_init,vis_init);検出結果クリア
  POINT vpos[1] = vision[1]
.END
.PROGRAM vset_error(.err,.$res,.$print)
.*****************************************************************
; FUNCTION: エラーコード＆内容セット
; NOTE    : ver1.0.0[13/02/08]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .err : エラー番号
.*          .$res : エラー内容
.*          .$print : TP表示メッセージ
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  v.err = .err
  $vres = .$res
  PRINT /X2,.$print;                         エラー内容表示
  SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM vstr_decode(.$data)
.*****************************************************************
; FUNCTION: 文字列データ分解(区切り文字 [,])
; NOTE    : ver1.0.0[12/10/18]
.*****************************************************************
.*////////////////////////////////////////////////////////////////
.* [ARGUMENT]
.*          .$data : 文字列
.* [RETURN]
.*          なし
.*////////////////////////////////////////////////////////////////
  .$strings = .$data;                        文字列データ代入
  IF .$strings=="" GOTO end;                 文字列データが無い為終了
  .i = 0;                                    分解した個数クリア
  DO;                                        条件ループ開始
    $vst[.i] = $DECODE(.$strings,",",0);     ","までの文字列を取り出す
    IF .$strings=="" GOTO end;               文字列データが無くなれば終了
    .$temp = $DECODE(.$strings,",",1);       ","を取り出す
    .i = .i+1;                               分解した個数カウントアップ
  UNTIL .$strings=="";                       文字列データが無くなるまで
end:
  vdecode_num = .i;                          分解した個数代入
.END
.STRINGS
$appli_ver_v = "ATBU0000"
.END
.PROGRAM mainexe
;-------------------------------- 
;機能：作業実行メインEXE(マスター側実行専用)
;引数：なし
;戻値：なし
;--------------------------------
    FOR .i=1 TO DATA_L2NUM
        DATA_L2STATUS[.i]=FALSE
    END
    IF DISABLE_L2CHK==TRUE THEN
        ;順次実行
        ;FLG_SLAVE_MOVE = FALSE
        FOR .l2num=1 TO DATA_L2NUM
            CALL l2exec(.l2num,1,.ret)
            IF (.ret<>err_no_error) OR (G_LAST_ERROR<>err_no_error) THEN
                CALL update_error(.ret)
                RETURN
            END
        END
    ELSE
        ;第2階層条件チェック実行
        ;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
        IF FLG_BEFORE_EXEC<>FALSE THEN
            CALL BEFORE_EXEC(.ret)
            IF .ret<>err_no_error THEN
                CALL update_error(.ret)
                RETURN
            END
        END
        WHILE(1)
            DO
                CALL l2check(.l2num,.ret)
                IF .ret<>TRUE THEN
                    FLG_L2CHK_WAIT = TRUE
                END
            UNTIL(.ret==TRUE)
            FLG_L2CHK_WAIT = FALSE
            CALL l2exec(.l2num,1,.ret)
            IF (.ret<>err_no_error) OR (G_LAST_ERROR<>err_no_error) THEN
                CALL update_error(.ret)
                RETURN
            END
            IF DATA_WSET_ENA<>FALSE THEN
                ;作業グループ番号変更確認
                CALL get_workno(.work_no,.ret)
                IF .ret<>err_no_error OR DATA_CUR_WORKNO<>.work_no THEN
                    CALL update_error(err_work_unmatch)
                    RETURN
                END
            END
        END
    END
.END

.PROGRAM updatel2l3info(.flg_disp,.l2num,.l3num,.flg_full)
;-------------------------------- 
;機能：作業実行状態更新、内部制御用変数更新
;引数：タブレット用情報更新フラグ(ON/OFF)、第2階層番号(マイナス値の場合更新無し)、第3階層番号(マイナス値の場合更新無し)、完全初期化フラグ
;戻値：無し
;--------------------------------
    IF .flg_full==TRUE THEN
        ;完全初期化
        DATA_CUR_L2DISP=0
        DATA_CUR_L3DISP=0
        FOR .i=1 TO 2
            DATA_CUR_L2REC[.i]=0
            DATA_CUR_L3REC[.i]=0
            NOW_MOVE_L3NUM[.i]=0
        END
        FLG_MASTER_CON=FALSE
        FLG_SLAVE_CON=FALSE
        RETURN
    END
    IF TASKNO==PG_MASTER THEN
        .rno=ROBOT_MASTER
    ELSE
        .rno=ROBOT_SLAVE
    END
    IF .l2num>=0 THEN
        DATA_CUR_L2REC[.rno]=.l2num
        IF (.flg_disp==TRUE) AND (.rno==ROBOT_MASTER) THEN
            DATA_CUR_L2DISP=.l2num
        END
    END
    IF .l3num>=0 THEN
        DATA_CUR_L3REC[.rno]=.l3num
        IF (.flg_disp==TRUE) AND (.rno==ROBOT_MASTER) THEN
            DATA_CUR_L3DISP=.l3num
        END
    END
    IF .l2num==0 AND .l3num==0 THEN
        IF .flg_disp==TRUE THEN
            IF .rno==ROBOT_MASTER THEN
                FLG_MASTER_CON=FALSE
            ELSE
                FLG_SLAVE_CON=FALSE
            END
        END
        ; 作業リセット時記憶消去
        NOW_MOVE_L3NUM[ROBOT_MASTER] = 0
        NOW_MOVE_L3NUM[ROBOT_SLAVE] = 0
    END
.END

.PROGRAM BEFORE_EXEC(.ret)
;-------------------------------- 
;機能：実行前の処理
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    RETURN
.END

.PROGRAM l2exec(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：第2階層実行
;引数：第2階層、第3階層
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,",l2exec()->.l2num=",.l2num,",.l3num=",.l3num
    END
    FOR .i=.l3num TO DATA_L3NUM[.l2num]
        IF DEBUG.PRT.L2EXEC==TRUE THEN
            PRINT "TASKNO=",TASKNO,",l2exec()-> $data_l3name[",.l2num,",",.i,"]=",$data_l3name[.l2num,.i]
        END
        ;作業継続用情報更新
        CALL updatel2l3info(TRUE,.l2num,.i,FALSE)
        CALL exec_main(.l2num,.i,.ret)
        IF (.ret<>err_no_error) OR ((G_LAST_ERROR<>err_no_error) AND (G_LAST_ERROR<>err_l3type_stop)) THEN
            CASE .ret OF
                VALUE err_slave_actend:
                    ;戻り値：[内部制御用エラーコード]スレーブロボット並列作業完了検知
                    IF DEBUG.PRT.ACT==TRUE THEN
                        PRINT "TASKNO=",TASKNO,",l2exec()-> スレーブ作業完了しました .ret=",.ret,",G_LAST_ERROR=",G_LAST_ERROR
                    END
                    ;作業継続用情報初期化(スレーブ単体)
                    CALL updatel2l3info(FALSE,-1,0,FALSE)
                VALUE err_l3_actend:
                    ;戻り値：[内部制御用エラーコード]RETURNコマンド検知
                    IF DEBUG.PRT.L2EXEC==TRUE THEN
                        PRINT "TASKNO=",TASKNO,",l2exec()-> RETURNコマンド検知 .ret=",.ret,",G_LAST_ERROR=",G_LAST_ERROR
                    END
                    ;マスターロボット
                    IF TASKNO==PG_MASTER THEN
                        IF SYS_FORCE_CMODE==TRUE THEN
                            ;協調中は協調解除
                            CALL exec_cend(.l2num,.l3num,.ret)
                            IF (.ret<>err_no_error) THEN
                                IF DEBUG.PRT.ACT==TRUE THEN
                                    PRINT "detected error. tho.. sopping mainexe() .ret=",.ret
                                END
                                CALL update_error(.ret)
                                PRINT "TASKNO=",TASKNO,", 作業実行に失敗しました .ret=",.ret,",G_LAST_ERROR=",G_LAST_ERROR
                                RETURN
                            END
                        END
                        ;作業自体をRETURNする
                        IF DEBUG.PRT.L2EXEC==TRUE THEN
                            PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
                        END
                        .ret = err_no_error
                        SYS_FORCE_CMODE=FALSE
                        FLG_SLAVE_PARALLEL_REQ = FALSE
                        RETURN
                    ELSE
                        ;スレーブロボット動作のみRETURNする
                        IF DEBUG.PRT.L2EXEC==TRUE THEN
                            PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
                        END
                        .ret = err_no_error
                        RETURN
                    END
                VALUE err_bat_value
                    PRINT "TASKNO=",TASKNO,", 範囲外の数値を設定した為作業が実行出来ませんでした .ret=",.ret,",G_LAST_ERROR=",G_LAST_ERROR
                    ;作業継続用情報初期化(マスター、スレーブ両方)
                    CALL updatel2l3info(FALSE,0,0,TRUE)
                ANY
                    PRINT "TASKNO=",TASKNO,", 作業実行に失敗しました .ret=",.ret,",G_LAST_ERROR=",G_LAST_ERROR
            END
            RETURN
        END
    END
    ;第2階層条件起動用作業完了フラグON
    IF TASKNO==PG_MASTER THEN
        DATA_L2STATUS[.l2num]=TRUE
    END
    ;作業継続用情報初期化(マスター、スレーブ両方)
    CALL updatel2l3info(FALSE,0,0,FALSE)
.END

.PROGRAM l2check(.l2num,.ret)
;-------------------------------- 
;機能：第2階層作業条件の成立チェック
;引数：無し
;戻値：成立した第2階層番号、成立有無(FALSE/TRUE)
;-------------------------------- 
    .ret=FALSE
    .l2num=-1
    ;.i=第2階層番号、.j=テーブル番号、.cnt=成立条件数
    FOR .i=1 TO DATA_L2NUM
        .cnt=0
        IF DATA_L2EXETBLNUM[.i]<=0 THEN
            ;実行条件なし
        ELSE
            ;実行条件確認
            FOR .j=1 TO DATA_L2EXETBLNUM[.i]
                IF DATA_L2TBL_SIGNUM[.i,.j]=<3000 THEN
                    IF DATA_L2TBL_STATUS[.i,.j]==1 THEN
                        IF SIG(DATA_L2TBL_SIGNUM[.i,.j])==ON THEN
                            .cnt=.cnt+1
                        END
                    ELSE
                        IF SIG(DATA_L2TBL_SIGNUM[.i,.j])==OFF THEN
                            .cnt=.cnt+1
                        END
                    END
                ELSE
                    IF DATA_L2TBL_STATUS[.i,.j]==1 THEN
                        IF DATA_L2STATUS[DATA_L2TBL_SIGNUM[.i,.j]-3000]==TRUE THEN
                            .cnt=.cnt+1
                        END
                    ELSE
                        IF DATA_L2STATUS[DATA_L2TBL_SIGNUM[.i,.j]-3000]==FALSE THEN
                            .cnt=.cnt+1
                        END
                    END
                END
            END
        END
        IF .cnt==DATA_L2EXETBLNUM[.i] THEN
            IF (DATA_L2WORKNO[.i]==DATA_CUR_WORKNO AND DATA_CUR_WORKNO<>0 AND DATA_WSET_ENA==1) OR DATA_WSET_ENA==0 THEN; 作業グループ番号一致または作業グルーピング設定無効
                ;実行条件成立
                .l2num=.i
                .ret=TRUE
                RETURN
            END
        END
    END
.END

.PROGRAM selfcheck(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：呼び出しTASKと作業データのロボット種別比較
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret=err_bad_rno
    IF (TASKNO==PG_MASTER) AND (DATA_ROBOTTYPE[.l2num,.l3num]==ROBOT_MASTER) THEN
        .ret = err_no_error
    END
    IF (TASKNO==PG_SLAVE) AND (DATA_ROBOTTYPE[.l2num,.l3num]==ROBOT_SLAVE) THEN
        .ret = err_no_error
    END
.END

.PROGRAM exec_main(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：作業シーケンス実行処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .l3type=DATA_L3TYPE[.l2num,.l3num]
    CASE .l3type OF
        VALUE L3TYPE_MOVE,L3TYPE_IO_WAIT,L3TYPE_IO_CHANGE,L3TYPE_VISION,L3TYPE_HAND_CHANGE,L3TYPE_RETURN,L3TYPE_IFGOTO,L3TYPE_COLCHK,L3TYPE_CNT,L3TYPE_CNTSET,L3TYPE_STOP,L3TYPE_CALVISION:
            ;ロボット別にコマンドを処理したい場合は↑VALUEに追加
            IF FLG_SLAVE_PARALLEL_REQ==TRUE THEN
                CALL selfcheck(.l2num,.l3num,.ret)
                IF .l3type==L3TYPE_HAND_CHANGE THEN
                    IF (TASKNO==PG_MASTER) AND (DATA_ROBOTTYPE[.l2num,.l3num]==ROBOT_ALL) THEN
                        ;ハンド操作の場合、両アーム指定はスキップしない
                        .ret = err_no_error
                    END
                END
                IF .ret <> err_no_error THEN
                    ;スキップは正常扱いにする
                    .ret = err_no_error
                    RETURN
                END
            END
        VALUE L3TYPE_CSTART,L3TYPE_CEND,L3TYPE_WSTART,L3TYPE_WEND:
            ;マスター専用コマンドとして扱いたい場合は↑VALUEに追加
            IF (TASKNO==PG_SLAVE) AND (.l3type==L3TYPE_WEND) THEN
                .ret=err_slave_actend
                RETURN
            END
            ;マスター専用
            IF TASKNO<>PG_MASTER THEN
                RETURN
            END
    END
    ;登録作業実行
    CASE .l3type OF
        VALUE L3TYPE_MOVE:
            IF FLG_EXEC_FIRST_MOVE==TRUE THEN
                IF SLOWLIMIT_ENA<>FALSE THEN
                  UTIMER @SLOWLIMIT_TIMER = 0
                  FLG_SLOWLIMIT=TRUE
                END
                FLG_EXEC_FIRST_MOVE=FALSE
            END
            CALL exec_move(.l2num,.l3num,.ret)
        VALUE L3TYPE_IO_WAIT:
            CALL exec_iowait(.l2num,.l3num,.ret)
            IF DEBUG.PRT.ITEM==TRUE THEN
                PRINT "TASKNO=",TASKNO, ", iowait()->Signal Number=",DATA_SIGNUM[.l2num,.l3num], ", Signal Status=",-(DATA_SIGSTATUS[.l2num,.l3num]), ", Time= ", $TIME
            END
        VALUE L3TYPE_IO_CHANGE:
            CALL exec_iochange(.l2num,.l3num,.ret)
        VALUE L3TYPE_VISION:
            CALL exec_vision(.l2num,.l3num,.ret)
        VALUE L3TYPE_CSTART:
            IF FLG_SLAVE_PARALLEL_REQ==FALSE THEN
                CALL exec_cstart(.l2num,.l3num,.ret)
            END
        VALUE L3TYPE_CEND:
            IF FLG_SLAVE_PARALLEL_REQ==FALSE THEN
                CALL exec_cend(.l2num,.l3num,.ret)
            END
        VALUE L3TYPE_WSTART:
           CALL exec_wstart(.l2num,.l3num,.ret)
        VALUE L3TYPE_WEND:
           CALL exec_wend(.l2num,.l3num,.ret)
        VALUE L3TYPE_L2RESET:
            DATA_L2STATUS[DATA_L2RESETNUM[.l2num,.l3num]] = FALSE
        VALUE L3TYPE_HAND_CHANGE:
            CALL exec_hand(.l2num,.l3num,.ret)
        VALUE L3TYPE_CALVISION:
            CALL exec_calvision(.l2num,.l3num,.ret)
        VALUE L3TYPE_COLCHK:
            IF DATA_COLCHK[.l2num,.l3num] == FALSE THEN
                ;アーム間干渉チェック機能無効化
                INTFCHK OFF
            ELSE
                ;アーム間干渉チェック機能有効化
                INTFCHK ON
            END
            IF DEBUG.PRT.ITEM==TRUE THEN
                PRINT "TASKNO=",TASKNO,", intfchk()->Check Status=", DATA_COLCHK[.l2num,.l3num], ", INTFCHK=", SWITCH(INTFCHK), ", Time= ", $TIME
            END
        VALUE L3TYPE_RETURN:
            IF FLG_SLAVE_PARALLEL_REQ==FALSE THEN
                .ret=err_l3_actend
            END
        VALUE L3TYPE_IFGOTO:
            CALL exec_ifgoto(.l2num,.l3num,.ret)
        VALUE L3TYPE_IFLABEL:
            ;何もしない
        VALUE L3TYPE_CNT:
            CALL exec_cnt(.l2num,.l3num,.ret)
        VALUE L3TYPE_CNTSET:
            ;カウンタ値セットはカウンタ値リセットと兼用
            ;全カウンタリセット時はexec_cntset関数に[.l2num,.l3num,.val]を0指定
            NOEXIST_SET_R DATA_CNTVAL[.l2num,.l3num] = 0
            .val=DATA_CNTVAL[.l2num,.l3num]
            CALL exec_cntset(.l2num,.l3num,.val,.ret)
        VALUE L3TYPE_STOP:
            BREAK
            DATA_EXECUTE = FALSE
            CALL update_error(err_l3type_stop)
            DO
                IF DATA_RESTART_FLG[.l2num,.l3num]==0 THEN
                    ;再開不可
                    NO_RESTART_FLG = TRUE
                    CALL updatel2l3info(TRUE,0,0,TRUE)
                    robot_status = sta_nomove
                END
                TWAIT ascycle
            UNTIL(DATA_EXECUTE==TRUE)
    END
    IF (.ret<>err_no_error) AND (.ret<>err_l3_actend) THEN
        IF DEBUG.PRT.ACT==TRUE THEN
            PRINT "detected error. tho.. sopping mainexe() .ret=",.ret
        END
        CALL update_error(.ret)
        RETURN
    END
.END

.PROGRAM exec_cnt(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：カウンタ値加算実行 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;カウンタＩＤ及びカウンタタイプの有無と「0」じゃないことの確認
    .$chk = "DATA_CNTID["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
    IF EXISTDATA(.$chk,R)==OFF THEN
        .ret = err_bat_value
        RETURN
    END
    .$chk = "DATA_CNTTYPE["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
    IF EXISTDATA(.$chk,R)==OFF THEN
        .ret = err_bat_value
        RETURN
    END
    IF DATA_CNTID[.l2num,.l3num]==0 OR DATA_CNTTYPE[.l2num,.l3num]==0 THEN
        .ret = err_bat_value
        RETURN
    END
    IF DATA_CNTID[.l2num,.l3num]==-1 THEN
        FOR .i=1 TO MAX_CNTNUM
            ;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
            NOEXIST_SET_R DATA_CNTNUM[.i] = 0
            DATA_CNTNUM[.i] = DATA_CNTNUM[.i] + DATA_CNTTYPE[.l2num,.l3num]
            .maxnum=32767
            .minnum=-32768
            IF DATA_CNTNUM[.i]>=.maxnum THEN
                DATA_CNTNUM[.i]=.maxnum
            END
            IF DATA_CNTNUM[.i]<=.minnum THEN
                DATA_CNTNUM[.i]=.minnum
            END
        END
    ELSE
        NOEXIST_SET_R DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]] = 0
        DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]] = DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]] + DATA_CNTTYPE[.l2num,.l3num]
        .maxnum=32767
        .minnum=-32768
        IF DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]]>=.maxnum THEN
            DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]]=.maxnum
        END
        IF DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]]<=.minnum THEN
            DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]]=.minnum
        END
    END
.END

.PROGRAM exec_cntset(.l2num,.l3num,.val,.ret)
;-------------------------------- 
;機能：カウンタ値設定実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)、カウンタ値
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;カウンタＩＤの有無と「0」じゃないことの確認
    .$chk = "DATA_CNTID["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
    IF EXISTDATA(.$chk,R)==OFF THEN
        .ret = err_bat_value
        RETURN
    END
    IF DATA_CNTID[.l2num,.l3num]==0 THEN
        .ret = err_bat_value
        RETURN
    END
    .maxnum=32767
    .minnum=-32768
    IF .val>=.maxnum THEN
        .val=.maxnum
    END
    IF .val<=.minnum THEN
        .val=.minnum
    END
    IF DATA_CNTID[.l2num,.l3num]==-1 THEN
        FOR .i=1 TO MAX_CNTNUM
            ;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
            DATA_CNTNUM[.i]=.val
        END
    ELSE
        DATA_CNTNUM[DATA_CNTID[.l2num,.l3num]]=.val
    END
.END

.PROGRAM exec_ifgoto(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO動作コア 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL exec_ifchk(.l2num,.l3num,.jump_flg)
    IF .jump_flg==TRUE THEN
        CALL exec_ifjump(.l2num,.l3num,.ret)
    END
.END

.PROGRAM exec_ifchk(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO成立条件判定
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：JUMP可否(FALSE:JUMP不可、TRUE:JUMP可)
;-------------------------------- 
    .ret = FALSE
    PRINT "exec_ifchk()-> Condition number is DATA_L3IFGOTO_ID[",.l2num,",",.l3num,"]=",DATA_L3IFGOTO_ID[.l2num,.l3num]
    ;DATA_IFCONTBLNUM:条件総数
    IF DATA_L3IFGOTO_ID[.l2num,.l3num]<=0 THEN
        ;条件が存在しない場合はJUMPしない
        RETURN
    END
    ;条件成立数カウント(このチェックの瞬間に全条件が揃ってる場合のみJUMPする)
    .cnt=0
    FOR .i=1 TO DATA_L3IFGOTO_ID[.l2num,.l3num]
        CASE DATA_IFMODE[.l2num,.l3num,.i] OF
            VALUE IFCON_CNT:
                CASE DATA_IFTYPE[.l2num,.l3num,.i] OF
                    VALUE INEQ_SIGN_EQ:
                        ;[=]equal
                        IF DATA_CNTNUM[DATA_IFITEM[.l2num,.l3num,.i]]==DATA_IFCNT[.l2num,.l3num,.i] THEN
                            .cnt=.cnt+1
                        END
                    VALUE ineq_sign_noteq:
                        ;[<>]not equal
                        IF DATA_CNTNUM[DATA_IFITEM[.l2num,.l3num,.i]]<>DATA_IFCNT[.l2num,.l3num,.i] THEN
                            .cnt = .cnt+1
                        END
                    VALUE INEQ_SIGN_LTEQ:
                        ;[<=]less than or equal
                        IF DATA_CNTNUM[DATA_IFITEM[.l2num,.l3num,.i]]<=DATA_IFCNT[.l2num,.l3num,.i] THEN
                            .cnt=.cnt+1
                        END
                    VALUE INEQ_SIGN_GTEQ:
                        ;[>=]greater than or equal
                        IF DATA_CNTNUM[DATA_IFITEM[.l2num,.l3num,.i]]>=DATA_IFCNT[.l2num,.l3num,.i] THEN
                            .cnt=.cnt+1
                        END
                END
            VALUE IFCON_IO:
                ;OFF=0,ON=0以外
                IF DATA_IFTYPE[.l2num,.l3num,.i]<>OFF THEN    
                    IF SIG(DATA_IFITEM[.l2num,.l3num,.i])<>OFF THEN
                        .cnt=.cnt+1
                    END
                ELSE
                    IF SIG(DATA_IFITEM[.l2num,.l3num,.i])==OFF THEN
                        .cnt=.cnt+1
                    END
                END
            VALUE IFCON_FLG:
                ;0以外の数値をDATA_IFITEMに設定している場合、符号を無視してTRUE扱い
                IF DATA_IFTYPE[.l2num,.l3num,.i]<>0 THEN
                    .cnt=.cnt+1
                END
        END
    END
    IF .cnt==DATA_L3IFGOTO_ID[.l2num,.l3num] THEN
        ;JUMP条件数OK
        .ret=TRUE
        RETURN
    END
.END

.PROGRAM exec_ifjump(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTOJUMP動作 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;指定L2階層内でラベルが見つかった場合.l3num数を更新する
    PRINT "exec_ifjump()-> Start serch for DATA_L3IFGOTO_LABEL[",.l2num,",",.l3num,"]=",DATA_L3IFGOTO_LABEL[.l2num,.l3num]
    FOR .i=1 TO DATA_L3NUM[.l2num]
        IF DATA_L3TYPE[.l2num,.i]==L3TYPE_IFLABEL THEN
            ;探索指定文字列    =$DATA_L3IFGOTO_LABEL[IFGOTO第2階層,IFGOT第3階層]
            ;ラベル設定済文字列=$DATA_L3LABEL[LABEL第2階層,LABEL第3階層]
            IF DATA_L3IFGOTO_LABEL[.l2num,.l3num]==DATA_L3LABEL[.l2num,.i] THEN
                .l3num=.i
                NOW_MOVE_L3NUM[TASKNO] = .l3num
                IF TASKNO==ROBOT_MASTER THEN
                    IF SYS_FORCE_CMODE==TRUE OR FLG_SLAVE_PARALLEL_REQ==FALSE THEN
                        NOW_MOVE_L3NUM[ROBOT_SLAVE] = 0; 協調動作または単体動作の時はスレーブ側の記憶は消去
                    END
                END
                PRINT "exec_ifjump()-> Target-label was found in .l2num=",.l2num,",.l3num=",.l3num
                RETURN
            END
        END
    END
    PRINT "exec_ifjump()-> Target-label wasn't found in .l2num=",.l2num
.END

.PROGRAM exec_hand(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ハンド操作実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_hand()->ハンド操作実行"
    END
    CALL hand(DATA_ROBOTTYPE[.l2num,.l3num],DATA_HAND_CTL[.l2num,.l3num],.ret)
.END

.PROGRAM exec_wstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_WCMD==TRUE THEN
        RETURN
    END
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_wstart()->      マスター・スレーブ並列動作開始"
    END
    BREAK; 並列動作開始の為BREAK
    ;連続動作要求
    FLG_SLAVE_PARALLEL_REQ = TRUE
    GS_l2num=.l2num
    GS_l3num=.l3num
    ;動作開始指示
    FLG_SLAVE_MOVE = TRUE
.END

.PROGRAM exec_wend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_WCMD==TRUE THEN
        RETURN
    END
    DO
        IF DEBUG.PRT.ACT==TRUE THEN
            PRINT "TASKNO=",TASKNO,", exec_wend()-> ....waiting SLAVE actioon"
        END
    UNTIL(FLG_SLAVE_MOVE==FALSE)
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO," ,exec_wend()->      マスター・スレーブ並列動作終了"
    END
    ;連続動作要求
    FLG_SLAVE_PARALLEL_REQ = FALSE
.END

.PROGRAM exec_cstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_cstart()->      同期開始"
    END
    BREAK; 同期開始の為BREAK
    SYS_FORCE_CMODE=TRUE
    SYN_MODE_START = TRUE; 同期開始処理実行フラグ
.END

.PROGRAM exec_cend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_cend()->      同期終了"
    END
    SYS_FORCE_CMODE=FALSE
    SYN_MODE_END = TRUE; 同期終了処理実行フラグ
    ; 同期終了処理
    FLG_REQ_MAMODE = FALSE
    CALL exec_alone(.ret)
.END

.PROGRAM exec_vision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_vision()"
    END
;
    CALL vcom_init;                              ビジョン変数初期化
    .vtimeout = (vsend_timeout+vrecv_timeout)*2; インターロックタイムアウト時間(sec)
    .rno = DATA_ROBOTTYPE[.l2num,.l3num];        ロボット番号取得
    IF .rno==1 THEN
      SIG ix_vloc_mas;                           マスター計測処理中ON
      UTIMER @vtime_mas = 0;                    タイマーリセット
      DO;                                        条件ループ開始
        IF SIG(-ix_vloc_sla)==ON GOTO loc;       スレーブ側が計測していなければ
        IF SIG(ix_vloc_now)==ON GOTO loc;        スレーブ側がロック確認中（デッドロックになったらマスター優先で抜ける）
        TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
      UNTIL UTIMER(@vtime_mas)>=.vtimeout;      タイムアウトするまで
      .ret = err_vis_locmas;                     インターロックタイムアウトエラー(マスター)
      SIG -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
      SIG ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
      RETURN;
    ELSE
      SIG ix_vloc_sla,ix_vloc_now;               スレーブ計測処理中ON,スレーブロック確認中ON
      UTIMER @vtime_sla = 0;                    タイマーリセット
      DO;                                        条件ループ開始
        IF SIG(-ix_vloc_mas)==ON GOTO loc;       マスター側が計測していなければ 
        TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
      UNTIL UTIMER(@vtime_sla)>=.vtimeout;      タイムアウトするまで
      .ret = err_vis_locsla;                     インターロックタイムアウトエラー(スレーブ) 
      SIG -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
      SIG ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
      RETURN;
    END
loc:
    IF .rno==2 THEN
      SIG -ix_vloc_now;                          スレーブロック確認中OFF
    END
;
retry:
    NOEXIST_SET_R DATA_VISION_CNT[.l2num,.l3num]=0
    ;作業実行時はマスター登録フラグは常にOFF
    .recflg=FALSE
    CALL get_vision_info(DATA_ROBOTTYPE[.l2num,.l3num],DATA_VISION_ID[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.ret)
    IF .ret==err_no_error THEN
        CALL vision_main(DATA_ROBOTTYPE[.l2num,.l3num],DATA_VISION_ID[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
        IF .ret<>err_no_error AND DATA_VISION_CNT[.l2num,.l3num]==1 THEN
          .ret = err_no_error; ビジョンNG続行フラグONの場合エラーにしない(ログはvision_exeで取っている)
        END
    END
    IF .ret<>err_no_error THEN
        DATA_EXECUTE = FALSE
        CALL update_error(.ret)
        DO
            TWAIT ascycle
        UNTIL(DATA_EXECUTE==TRUE)
        FLG_EXEC_FIRST_MOVE = TRUE
        GOTO retry; エラー停止/再開
    END
;
    IF .rno==1 THEN
      SIG -ix_vloc_mas;                          マスター処理完了
    ELSE
      SIG -ix_vloc_sla;                          スレーブ処理完了
    END
.END

.PROGRAM exec_calvision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン計算実行（装置補正実行）
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_calvision()"
    END
    NOEXIST_SET_R DATA_VISION_CNT[.l2num,.l3num]=0
    ; calposはcalvision内で未使用
    CALL calvision(DATA_ROBOTTYPE[.l2num,.l3num],DATA_VISION_ID[.l2num,.l3num],1,.ret)
    IF .ret<>err_no_error AND DATA_VISION_CNT[.l2num,.l3num]==1 THEN
      .ret = err_no_error; ビジョンNG続行フラグONの場合エラーにしない(ログはcal_visionで取っている)
    END
.END

.PROGRAM exec_move(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：移動処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_move()"
    END
    IF FLG_SINGLE_MOVE==FALSE THEN
      .sp=DATA_REPSPEED[.l2num,.l3num]
      NOEXIST_SET_R DATA_ACCEL[.l2num,.l3num]=DATA_ACC
      NOEXIST_SET_R DATA_DECEL[.l2num,.l3num]=DATA_DEC
      NOEXIST_SET_R DATA_ACCURACY[.l2num,.l3num]=DATA_ACCU
      NOEXIST_SET_R DATA_ABSSP_MODE[.l2num,.l3num]=0
      .acc=DATA_ACCEL[.l2num,.l3num]
      .dec=DATA_DECEL[.l2num,.l3num]
      .accu=DATA_ACCURACY[.l2num,.l3num]
      .sp_mode=DATA_ABSSP_MODE[.l2num,.l3num]
    ELSE; 個別実行の時は速度固定
      .sp = SAFTY_MOVE_SP
      .acc = DATA_ACC
      .dec = DATA_DEC
      .accu = DATA_ACCU
      .sp_mode = 3
    END
    CALL getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
    IF .ret == err_no_error THEN
        IF DATA_WAIT_BEFORE[.l2num,.l3num] >= 1 THEN
            TWAIT DATA_WAIT_BEFORE[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
            BREAK
        END
        .rno=DATA_ROBOTTYPE[.l2num,.l3num]
        .t[1]=0
        .t[2]=0
        CASE .rno OF
            VALUE 1:
                .t[1]=DATA_TOOL[.l2num,.l3num]
            VALUE 2:
                .t[2]=DATA_TOOL[.l2num,.l3num]
        END
        POINT .#t =#PPOINT(.t[ROBOT_MASTER],.t[ROBOT_SLAVE],0,0,0,0)
        IF SYS_FORCE_CMODE==TRUE THEN
            .rno = 0
            IF DEBUG.PRT.ACT==TRUE THEN
                PRINT "exec_move()->強制協調動作モード"
            END
        END
        ;ビジョン処理結果反映
        CALL update_vspos(.l2num,.l3num,.#pos,.#outpos,.ret)
        IF .ret<>err_no_error THEN
          ; 再開不可エラーとする
          RETURN
        END
        ; 動作中作業番号記憶用
        IF .rno==ROBOT_SLAVE THEN
          TMP_MOVE_L3NUM[ROBOT_SLAVE] = .l3num
        ELSE
          TMP_MOVE_L3NUM[ROBOT_MASTER] = .l3num
        END
        ; 動作後break有無確認
        IF .accu<=1 THEN; 精度が1mm以下の場合はBREAK有
          .bflag = TRUE
        ELSE
          ; 先読み防止のための動作後BREAK有無確認
          CALL chk_break(.l2num,.l3num,.bflag)
        END
        ;movepos関数のBREAK有無フラグをFALSEにしてBREAK無しで実行する
        CALL movepos(.rno,.#t,.mode,.type,.#outpos,.bflag,.sp,.acc,.dec,.accu,.sp_mode,.ret)
        IF DATA_WAIT_AFTER[.l2num,.l3num] >= 1 THEN
            ;完全停止後に待ち始める
            BREAK
            TWAIT DATA_WAIT_AFTER[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
            BREAK
        END
    END
.END

.PROGRAM exec_iowait(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO待ち処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_iowait()"
    END
    IF DATA_SIGNUM[.l2num,.l3num] <= 0 THEN
        ;エラーにするかは上位の実装を考慮したほうが良い
        ;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
        RETURN
    END
    IF DATA_WAIT_BEFORE[.l2num,.l3num] >= 1 THEN
        IF DEBUG.PRT.ACT==TRUE THEN
            PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",DATA_WAIT_BEFORE[.l2num,.l3num]
        END
        TWAIT DATA_WAIT_BEFORE[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
        BREAK
    END
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "START WAITING DATA_SIGNUM[.l2num,.l3num]=",DATA_SIGNUM[.l2num,.l3num]
    END
    .rno = DATA_ROBOTTYPE[.l2num,.l3num]; ロボット番号取得
    SIGNAL -ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＦＦ
    NOEXIST_SET_R DATA_WAIT_TOCON[.l2num,.l3num] = 0
    FLG_WAIT_END=FALSE
    UTIMER .@NowTime = 0
    WHILE(TRUE)
        EXOUT_START_FLASH_MODE = TRUE
        IF FLG_WAIT_END==TRUE THEN
            FLG_WAIT_END=FALSE
            EXOUT_START_FLASH_MODE = FALSE
            RETURN
        END
        IF DATA_WAIT_TIMEOUT[.l2num,.l3num]>0 AND (SIG(DATA_SIGNUM[.l2num,.l3num]) <> -(DATA_SIGSTATUS[.l2num,.l3num])) AND FLG_IOWAIT_DEBUG<>TRUE THEN
            IF UTIMER(.@NowTime)>DATA_WAIT_TIMEOUT[.l2num,.l3num]/1000 THEN  ; @@@ 20140926 m ミリ秒に変更 A.Kobayashi
                IF DEBUG.PRT.ACT==TRUE THEN
                    PRINT "TIMEOUT"
                END
                SIGNAL ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＮ
                IF DATA_WAIT_TOCON[.l2num,.l3num]==1 THEN; 信号待ちＮＧ(タイムアウト)続行フラグＯＮの場合はエラーにしない
                    RETURN
                END
                DATA_EXECUTE = FALSE     ; @@@ 20140926 A.Kobayashi
                EXOUT_START_FLASH_MODE = FALSE
                CALL update_error(err_sig_timeout)
                DO
                    TWAIT ascycle
                UNTIL(DATA_EXECUTE==TRUE)
                SIGNAL -ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＦＦ
                ;タイマーリセット
                UTIMER .@NowTime = 0
                FLG_EXEC_FIRST_MOVE = TRUE
            END
        END
        IF SIG(DATA_SIGNUM[.l2num,.l3num]) == -(DATA_SIGSTATUS[.l2num,.l3num]) THEN
            IF DEBUG.PRT.ACT==TRUE THEN
                PRINT "DETECTED INPUT SIGNAL=",DATA_SIGNUM[.l2num,.l3num]," CHANGE TO =",-(DATA_SIGSTATUS[.l2num,.l3num])
            END
            IF DATA_WAIT_AFTER[.l2num,.l3num] >= 1 THEN
                IF DEBUG.PRT.ACT==TRUE THEN
                    PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",DATA_WAIT_AFTER[.l2num,.l3num]
                END
                TWAIT DATA_WAIT_AFTER[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
                BREAK
            END
            EXOUT_START_FLASH_MODE = FALSE
            RETURN
        END
    END
.END

.PROGRAM exec_iochange(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO変更処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "TASKNO=",TASKNO,", exec_iochange()"
    END
    IF DATA_SIGNUM[.l2num,.l3num] <= 0 THEN
        ;エラーにするかは上位の実装を考慮したほうが良い
        ;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
        RETURN
    END
    IF DATA_WAIT_BEFORE[.l2num,.l3num] >= 1 THEN
        IF DEBUG.PRT.ACT==TRUE THEN
            PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",DATA_WAIT_BEFORE[.l2num,.l3num]
        END
        TWAIT DATA_WAIT_BEFORE[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
        BREAK
    END
    IF DEBUG.PRT.ACT==TRUE THEN
        PRINT "CHANGEING SIGNAL DATA_SIGNUM[.l2num,.l3num]=",DATA_SIGNUM[.l2num,.l3num]," DATA_SIGSTATUS[.l2num,.l3num]=",DATA_SIGSTATUS[.l2num,.l3num]
    END

    CALL iochange(DATA_SIGNUM[.l2num,.l3num],DATA_SIGSTATUS[.l2num,.l3num],DATA_KEEP_WAIT[.l2num,.l3num],.ret)

    IF DATA_WAIT_AFTER[.l2num,.l3num] >= 1 THEN
        IF DEBUG.PRT.ACT==TRUE THEN
            PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",DATA_WAIT_AFTER[.l2num,.l3num]
        END
        TWAIT DATA_WAIT_AFTER[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
        BREAK
    END
.END

.PROGRAM getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
;-------------------------------- 
;機能：1点分の位置情報の取得
;引数：第2階層番号、第3階層番号
;戻値：動作方法(.mode->0;JT、1:XYZR1EXT1)、教示点構成要素(.data実数配列)、補間方法(.type->0:LMOVE、1:JMOVE)、成否
;-------------------------------- 
    .ret = err_no_error
    .dtype = DATA_L3TYPE[.l2num,.l3num]
    IF .dtype != L3TYPE_MOVE THEN
        .ret=err_bad_l3type
        RETURN
    END
    
    .mode = DATA_MODE[.l2num,.l3num]
    .type = DATA_POSTYPE[.l2num,.l3num]

    .pos[1]=DATA_POS1[.l2num,.l3num]
    .pos[2]=DATA_POS2[.l2num,.l3num]
    .pos[3]=DATA_POS3[.l2num,.l3num]
    .pos[4]=DATA_POS4[.l2num,.l3num]
    .pos[5]=DATA_POS5[.l2num,.l3num]
    .pos[6]=DATA_POS6[.l2num,.l3num]
    POINT .#pos =#PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
.END

.PROGRAM chk_break(.l2num,.l3num,.bflag)
;-------------------------------- 
;機能：動作後BREAK有無確認
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：動作後BREAK有無
;-------------------------------- 
  .bflag = FALSE; BREAK無
  IF (.l3num+1)<=DATA_L3NUM[.l2num] THEN
    .rno = DATA_ROBOTTYPE[.l2num,.l3num]; 動作ロボット番号取得
    FOR .i=.l3num+1 TO DATA_L3NUM[.l2num]
      ; 次の動作までに協調開始または協調終了がある場合はBREAK有
      IF DATA_L3TYPE[.l2num,.i]==L3TYPE_CSTART OR DATA_L3TYPE[.l2num,.i]==L3TYPE_CEND THEN
        .bflag = TRUE
        RETURN
      END
      ; 次の動作までに並列開始または並列終了がある場合はBREAK有
      IF DATA_L3TYPE[.l2num,.i]==L3TYPE_WSTART OR DATA_L3TYPE[.l2num,.i]==L3TYPE_WEND THEN
        .bflag = TRUE
        RETURN
      END
      ; 次の動作までに条件分岐がある場合はBREAK有
      IF DATA_L3TYPE[.l2num,.i]==L3TYPE_IFGOTO THEN
        .next_rno = DATA_ROBOTTYPE[.l2num,.i]
        IF .rno==.next_rno THEN
          .bflag = TRUE
          RETURN
        END
      END
      ; 次の動作でアームが切り替わる場合はBREAK有(並列動作の時以外)
      IF DATA_L3TYPE[.l2num,.i]==L3TYPE_MOVE THEN
        .next_rno = DATA_ROBOTTYPE[.l2num,.i]
        IF .rno==.next_rno THEN
          RETURN
        ELSE
          IF (FLG_SLAVE_PARALLEL_REQ==FALSE AND TASKNO==ROBOT_MASTER) THEN
            .bflag = TRUE
            RETURN
          END
        END
      END
      ; 次の動作までに作業停止か作業終了がある場合はBREAK有
      IF DATA_L3TYPE[.l2num,.i]==L3TYPE_RETURN OR DATA_L3TYPE[.l2num,.i]==L3TYPE_STOP THEN
        .next_rno = DATA_ROBOTTYPE[.l2num,.i]
        IF .rno==.next_rno THEN
          .bflag = TRUE
          RETURN
        END
      END
    END
  END
.END

.PROGRAM cmdmain(.cmd,.$res,.ret)
;-------------------------------- 
;機能：コマンド実行
;引数：コマンド、コマンド引数
;戻値：成否
;-------------------------------- 
    .ret = err_no_error 
    .$res=""

    IF DEBUG.PRT.CMD==TRUE THEN
        IF TASKNO==1006 AND (OPE_COMMANDPC<>CMD_GET_INFO OR OPE_COMMANDPC<>CMD_GET_MONSP) THEN
            ;描画しない
        ELSE
            PRINT "TASKNO=",TASKNO," ->cmdmain() OPE_COMMAND=",OPE_COMMAND,".cmd=",.cmd
        END
    END
    IF MODE_CUSTOMER==TRUE THEN
        CASE .cmd OF
            VALUE CMD_EXE_START,CMD_EXE_MOVE,CMD_EXE_RESTART,CMD_EXE_HOLD,CMD_EXE_ABORT,CMD_EXE_L2EXE:
                ;VALUEに追加すればコマンドを無視する
                ;誤操作時にエラーリセットするのが手間なのでエラーにしないで抜ける
                GOTO 10
        END
    END
    CASE .cmd OF
        VALUE CMD_EXE_RESET:
            CALL cmdreset(.ret)
            CALL exec_alone(.ret)
        VALUE CMD_EXE_GEN:
            ;引数：動作速度(.sp)
            CALL cmdgen(.ret)
            break
        VALUE CMD_EXE_CON:
            ;引数：動作速度(.sp)、第2階層番号(.id)
            CALL cmdcon(.ret)
        VALUE CMD_EXE_ONE:
            ;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
            CALL cmdone(.ret)
        VALUE CMD_EXE_TEACH:
            ;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
            CALL cmdteach(.ret)
        VALUE CMD_SET_TNUM,CMD_SET_SP,CMD_SET_PITCH,CMD_SET_CORD,CMD_SET_TOOL,CMD_SET_HOME,CMD_SET_SIGNAME,CMD_SET_SIGNUM,CMD_SET_L2EXETBL:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdsetparam(.cmd,.ret)
        VALUE CMD_SET_HANDIO,CMD_SET_VTBNUM,CMD_SET_VTB,CMD_SET_LOWSPAREA,CMD_SET_LOWSPSETTING,CMD_SET_ZEROING,CMD_SET_COLCHKMOVE,CMD_SET_SLOWLIMIT,CMD_SET_INTFPARAM,CMD_SET_GENPARAM,CMD_SET_COLR:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdsetparam(.cmd,.ret)
        VALUE CMD_SET_WSET,CMD_SET_WSPEC,CMD_SET_WNO:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdsetparam(.cmd,.ret)
        VALUE CMD_GET_TNUM,CMD_GET_INFO,CMD_GET_L1INFO,CMD_GET_L2INFO,CMD_GET_L3INFO,CMD_GET_SP,CMD_GET_PITCH,CMD_GET_CORD,CMD_GET_TOOL,CMD_GET_POS,CMD_GET_IO,CMD_GET_HOME:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdgetparam(.cmd,.$res,.ret)
        VALUE CMD_GET_SIGNAME,CMD_GET_SIGNUM,CMD_GET_MONSP,CMD_GET_L2EXETBL,CMD_GET_INFOEX,CMD_GET_HAND,CMD_GET_HANDIO,CMD_GET_VTBNUM,CMD_GET_VTB,CMD_GET_VRESULT,CMD_GET_ROBOTMODE:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdgetparam(.cmd,.$res,.ret)
        VALUE CMD_GET_LOWSPAREA,CMD_GET_LOWSPSETTING,CMD_GET_GRAVITYADJMOVE,CMD_GET_COLCHKMOVE,CMD_GET_SLOWLIMIT,CMD_GET_SA,CMD_GET_VERSION,CMD_GET_IOSTAT,CMD_GET_COUNT,CMD_GET_INTFPARAM,CMD_GET_GENPARAM,CMD_GET_COLR:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdgetparam(.cmd,.$res,.ret)
        VALUE CMD_GET_WSET,CMD_GET_WSPEC,CMD_GET_WINFO,CMD_GET_WNO:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdgetparam(.cmd,.$res,.ret)
        VALUE CMD_SET_L1INFO,CMD_SET_L2INFO,CMD_SET_L3INFO,CMD_SET_WINFO:
            ;CMD_SET_PARAM設定機能は実数配列専用として文字列設定はこちらで実行する
            ;引数：名前種類[]、名称
            CALL cmdnameset(.cmd,.ret)
        VALUE CMD_EXE_START:
            CALL cmdexe(.ret)
        VALUE CMD_SET_STEPPOS:
            ;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
            CALL cmdsetsteppos(.ret)
        VALUE CMD_SET_STEP:
            ;引数：作業情報種類、作業情報配列
            CALL cmdsetstep(.ret)
        VALUE CMD_SET_STEPIFGOTO:
            ;引数：作業情報種類、作業情報配列
            CALL cmdsetstepifgot(.ret)
        VALUE CMD_GET_STEP:
            ;引数：第2階層番号、第3階層番号
            CALL cmdgetstep(.$res,.ret)
        VALUE CMD_GET_STEPPOS:
            ;引数：第2階層番号、第3階層番号
            CALL cmdgetsteppos(.$res,.ret)
        VALUE CMD_GET_STEPIFGOTO:
            ;引数：第2階層番号、第3階層番号
            CALL cmdgetstepifgot(.$res,.ret)
        VALUE CMD_EXE_MOVE:
            ;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
            CALL cmdmove(.ret)
        VALUE CMD_EXE_IO:
            ;信号番号、信号状態、状態保持時間
            CALL cmdchgio(.ret)
        VALUE CMD_EXE_VISION:
            ;引数；ビジョンID
            CALL cmdvision(.ret)
        VALUE CMD_EXE_RESTART:
            CALL cmdrestart(.ret)
        VALUE CMD_EXE_HOLD:
            CALL cmdhold(.ret)
        VALUE CMD_EXE_ABORT:
            CALL cmdabort(.ret)
        VALUE CMD_EXE_MONSP:
            CALL cmdmonsp(.ret)
        VALUE CMD_EXE_L2EXE:
            ;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
            CALL cmdl2exe(.ret)
        VALUE CMD_EXE_HAND:
            ;引数：ハンド状態
            CALL cmdhand(.ret)
        VALUE CMD_EXE_RESETIO:
            FOR .i=1 TO 128
                ;非常停止割当IOとハンド制御IOは操作しない
                IF .i<>SIG_EMG_OUTPUT AND .i<>SIG_EXT_REBOOT AND .i<>DATA_HAND_IO[ROBOT_MASTER,1] AND .i<>DATA_HAND_IO[ROBOT_MASTER,2] AND .i<>DATA_HAND_IO[ROBOT_MASTER,3] AND .i<>DATA_HAND_IO[ROBOT_MASTER,4] THEN
                    IF .i<>DATA_HAND_IO[ROBOT_SLAVE,1] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,2] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,3] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,4] THEN
                        SIG -(.i)
                    END
                END
            END
            FOR .i=1 TO 256
                ;非常停止割当IOとハンド制御IOは操作しない
                IF .i<>SIG_EMG_OUTPUT AND .i<>SIG_EXT_REBOOT AND .i<>DATA_HAND_IO[ROBOT_MASTER,1] AND .i<>DATA_HAND_IO[ROBOT_MASTER,2] AND .i<>DATA_HAND_IO[ROBOT_MASTER,3] AND .i<>DATA_HAND_IO[ROBOT_MASTER,4] THEN
                    IF .i<>DATA_HAND_IO[ROBOT_SLAVE,1] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,2] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,3] AND .i<>DATA_HAND_IO[ROBOT_SLAVE,4] THEN
                        SIG -(2000+.i)
                    END
                END
            END
        VALUE CMD_EXE_WAITEND:
            FLG_WAIT_END=TRUE
        VALUE CMD_EXE_ROBOTMODE:
            ;引数：ロボットモード(0:タブレット、1:ダイレクトティーチ)、ON/OFFフラグ
            CALL cmdchgrobotmode(.ret)
        VALUE CMD_EXE_GRAVITYADJ:
            CALL cmdgravityadj(.ret)
        VALUE CMD_EXE_VSCALIB:
            CALL cmdexevscalib(.ret)
        VALUE CMD_EXE_SA:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdsetparam(.cmd,.ret)
        VALUE CMD_EXE_FLASH:
            ;引数：変数種類(.ptype)、値(.value)
            CALL cmdsetparam(.cmd,.ret)
        VALUE CMD_EXE_VLESCAL:
            CALL cmdvlesscalib(.ret)
        VALUE CMD_EXE_VCALCHK:
            ; キャリブレーション精度チェック
            CALL cmdexevcalchk(.ret)
        ANY
            PRINT "TASKNO=",TASKNO," ->cmdmain() Error occuerd. You try to execute unsupport command." 
            .ret=err_cmd_type
    END
10
    IF .ret<>err_no_error THEN
        IF TASKNO==PG_COM_ACT THEN
            CALL sendresp(.cmd,"",.ret)
        END
    END
.END

.PROGRAM cmdvlesscalib(.ret)
;-------------------------------- 
;機能：ビジョンなし装置補正コマンド
;引数：
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF VAL($prm[TASKNO,2])>999 OR VAL($prm[TASKNO,2])<1 THEN
        .ret = err_bat_value
        RETURN
    END
    POINT .t = TRANS(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]))
    POINT .p1 = TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]))
    POINT .p2 = TRANS(VAL($prm[TASKNO,9]),VAL($prm[TASKNO,10]),VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]))
    CALL vless_calmain(VAL($prm[TASKNO,1]),VAL($prm[TASKNO,2]),.&t,.&p1,.&p2,VAL($prm[TASKNO,13]),.ret)
.END


.PROGRAM cmdchgrobotmode(.ret)
;-------------------------------- 
;機能：ロボットモード変更
;引数：ロボットモード(0:タブレット、1:ダイレクト)、ON/OFFフラグ(0:OFF、1:ON)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;モードチェンジ可否判定
    IF ROBOT_MODE==MODE_TABLET AND ROBOT_MODE_FLG<>FALSE AND (FLG_MASTER_MOVE==TRUE OR FLG_SLAVE_MOVE==TRUE) THEN
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdchgrobotmode() Can not change robot-mode, because still moving any robot."
        END
        .ret=err_robot_busy
        RETURN
    END
    .robot_mode=VAL($prm[TASKNO,2])
    .flg_onoff=VAL($prm[TASKNO,3])
    ROBOT_MODE = .robot_mode
    ;動作プログラム起動要否判定
    .flg_execute=FALSE
    IF .flg_onoff==1 THEN
        ;衝突検知感度自動調整設定OFF
        CALL chg_colcalflg(OFF)
    END
    CASE .robot_mode OF
        VALUE MODE_TABLET:
            IF .flg_onoff==1 THEN
                .flg_execute=TRUE
            END
        VALUE MODE_DIRECT:
            IF .flg_onoff==1 THEN
                .flg_execute=TRUE
            END
            ;ダイレクトティーチ
            NOEXIST_SET_R mode_sa = 0
            NOEXIST_SET_R sa_tool[1] = 1
            NOEXIST_SET_R sa_tool[2] = 1
            FOR .i=1 TO 2
                FOR .j=1 TO 4
                    NOEXIST_SET_R sa_param[.i,.j] = 1
                END
            END
            NOEXIST_SET_S $sa_param = "0,1,1,1,1,1,1,1,1"
            FLG_SA_CHANGE = 3
        ANY
            .ret=err_bad_mode
            RETURN
    END
    ;ﾛﾎﾞｯﾄﾓｰﾄﾞ変更後は再開不可
    CALL updatel2l3info(TRUE,0,0,TRUE)
    EXOUT_START_FLASH_MODE=FALSE
    IF .flg_execute==TRUE THEN
        ROBOT_MODE_FLG=.flg_onoff
        CALL exec_pg(.ret)
        IF .ret<>err_no_error THEN
            ROBOT_MODE_FLG=FALSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdchgrobotmode() Can not execute program."
            END
            RETURN
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdchgrobotmode() Executed program successfully."
            END
        END
    ELSE
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdchgrobotmode() Start abort program automatically."
        END
        CALL RdyBoot(FALSE,.ret)
        IF .ret<>err_no_error THEN
            ROBOT_MODE_FLG=FALSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdchgrobotmode() Can not abort program."
            END
            RETURN
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdchgrobotmode() Aborted program successfully."
            END
            ROBOT_MODE_FLG = .flg_onoff
        END
    END
    EXOUT_START_FLASH_MODE=FALSE
.END

.PROGRAM cmdreset(.ret)
;-------------------------------- 
;機能：エラーリセットコマンド
;引数：なし
;戻値：成否
;-------------------------------- 
    IF g_last_error==err_no_error THEN
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdreset() skipped reset command." 
        END
        RETURN
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdreset() Starting reset command." 
    END
    ;システム管理のエラー情報の初期化のみのためロボット別処理不要
    .ret = err_no_error   
    CALL update_error(.ret)
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdreset() Done reset command." 
    END
.END

.PROGRAM cmdgen(.ret)
;-------------------------------- 
;機能：ホーム移動コマンド
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;ロボット状態遷移
    robot_status = sta_gen
    ;停止位置記憶有効フラグ
    FLG_ENABLE_STOPPOS=FALSE
    EXOUT_START_FLASH_MODE=FALSE
    ;全作業実行状態初期化
    CALL updatel2l3info(TRUE,0,0,TRUE)
    CALL gen(.ret)
    ;ロボット状態遷移
    robot_status = sta_nomove
.END

.PROGRAM cmdchgio(.ret)
;-------------------------------- 
;機能：IO変更コマンド
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;-------------------------------- 
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT ".rno=",$prm[TASKNO,1]
        PRINT "Signal Number=",$prm[TASKNO,2],", Signal Status=",$prm[TASKNO,3],", Keed Signal Time=",$prm[TASKNO,4]
    END
    CALL iochange(VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),.ret)
.END

.PROGRAM cmdvision(.ret)
;-------------------------------- 
;機能：ビジョンコマンド
;引数：ビジョンID
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF VAL($prm[TASKNO,2])>999 THEN
        .ret = err_bat_value
        RETURN
    END
    ;ビジョンID変換
    CALL convert_vid(MODE_ADD,VAL($prm[TASKNO,7]),VAL($prm[TASKNO,2]),.vision_id)
    CALL vision_main(VAL($prm[TASKNO,1]),.vision_id,VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),.ret)
.END

.PROGRAM cmdexevscalib(.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;ロボット状態遷移
    robot_status = sta_vscalib
    .rno = VAL($prm[TASKNO,1])
    ;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
    CALL updatel2l3info(TRUE,0,0,TRUE)
    CASE .rno OF
    VALUE ROBOT_ALL:
        .ret=err_bad_rno
        RETURN
    VALUE ROBOT_MASTER:
        .camno = VAL($prm[TASKNO,2])
        .calno = VAL($prm[TASKNO,3])
        IF .calno<1 OR 999<.calno THEN
            .ret = err_bat_value
            RETURN
        END
        .camtype = VAL($prm[TASKNO,4])
        POINT .target=TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),0,0)
        .len = VAL($prm[TASKNO,9])
        IF .len==0 THEN
            .ret = err_bat_value
            RETURN
        END
        .height = VAL($prm[TASKNO,10])
        POINT .tool_p=TRANS(VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]),0,0,0,0)
        CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
    VALUE ROBOT_SLAVE:
        ;パラメータ設定
        GS_RNO = VAL($prm[TASKNO,1])
        GS_CAMNO = VAL($prm[TASKNO,2])
        GS_CALNO = VAL($prm[TASKNO,3])
        IF GS_CALNO<1 OR 999<GS_CALNO THEN
            .ret = err_bat_value
            RETURN
        END
        GS_CAMTYPE = VAL($prm[TASKNO,4])
        POINT GS_POSXYZR1=TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),0,0)
        GS_LEN = VAL($prm[TASKNO,9])
        IF GS_LEN==0 THEN
            .ret = err_bat_value
            RETURN
        END
        GS_HEIGHT = VAL($prm[TASKNO,10])
        POINT GS_TOOLP=TRANS(VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]),0,0,0,0)
        ;スレーブロボット実行
        FLG_SLAVE_MOVE = TRUE
        ;スレーブロボット終了待ち
        WHILE(1)
            IF FLG_SLAVE_MOVE==FALSE THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
                END
                ;ロボット状態遷移
                .ret = gs_excalib_err
                robot_status = sta_nomove
                RETURN
            ELSE
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
                END
            END
        END
    END
    ;ロボット状態遷移
    robot_status = sta_nomove
.END

.PROGRAM cmdmonsp(.ret)
;-------------------------------- 
;機能：モニタ速度変更コマンド
;引数：速度
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL monsp(.ret)
.END

.PROGRAM cmdone(.ret)
;-------------------------------- 
;機能：作業番号、教示点番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_READJ_POS==TRUE THEN
        ;停止位置記憶有効フラグ
        FLG_ENABLE_STOPPOS=FALSE
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdone() .rno=",$prm[TASKNO,1]
    END
    .sp =VAL($prm[TASKNO,2])
    .id =VAL($prm[TASKNO,3])
    .num=VAL($prm[TASKNO,4])
    CALL chg_move_param(0,.sp,DATA_ACC,DATA_DEC,DATA_ACCU,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    CALL getposdata(.id,.num,.mode,.type,.#pos,.ret)
    ;移動方法は指定の方法で上書き
    CALL exec_move(.id,.num,.ret)
.END

.PROGRAM cmdcon(.ret)
;-------------------------------- 
;機能：作業番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_READJ_POS==TRUE THEN
        ;停止位置記憶有効フラグ
        FLG_ENABLE_STOPPOS=FALSE
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdcon() .rno=",$prm[TASKNO,1]
    END
    .sp=VAL($prm[TASKNO,2])
    .id=VAL($prm[TASKNO,3])
    CALL chg_move_param(0,.sp,DATA_ACC,DATA_DEC,DATA_ACCU,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    FOR .i=1 TO DATA_L3NUM[.id]
        CALL exec_move(.id,.i,.ret)
    END
    BREAK
.END

.PROGRAM cmdmove(.ret)
;-------------------------------- 
;機能：指定位置移動コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_READJ_POS==TRUE THEN
        ;停止位置記憶有効フラグ
        FLG_ENABLE_STOPPOS=FALSE
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdmove() .rno=",$prm[TASKNO,1]
    END
    .rno = VAL($prm[TASKNO,1])
    .mode=VAL($prm[TASKNO,2])
    .t[ROBOT_MASTER]=0
    .t[ROBOT_SLAVE]=0
    CASE .rno OF
        VALUE ROBOT_ALL:
            ;協調動作
            IF TASKNO==PG_MASTER THEN
              ;開始処理
              SYS_FORCE_CMODE=TRUE
              SYN_MODE_START = TRUE
            END
            IF 1 THEN
                .t[ROBOT_MASTER]= VAL($prm[TASKNO,3])
            ELSE
                ;タブレット側UIの都合でこのコマンドでは個別にしか動かせない
                .ret = err_bad_rno
                RETURN
            END
        VALUE ROBOT_MASTER:
            .t[ROBOT_MASTER]= VAL($prm[TASKNO,3])
        VALUE ROBOT_SLAVE:
            .t[ROBOT_SLAVE]= VAL($prm[TASKNO,3])
        ANY
            .ret = err_bad_rno
            RETURN
    END
    POINT .#t =#PPOINT(.t[ROBOT_MASTER],.t[ROBOT_SLAVE],0,0,0,0)
    .type=VAL($prm[TASKNO,4])
    ;位置情報
    IF .mode == MODE_JT THEN
        .cpos[1]=VAL($prm[TASKNO,5]);JT1
        .cpos[2]=VAL($prm[TASKNO,6]);JT2
        .cpos[3]=VAL($prm[TASKNO,7]);JT3
        .cpos[4]=VAL($prm[TASKNO,8]);JT4
        .cpos[5]=0;xxx外部軸仕様未確定xxx
        .cpos[6]=0;xxx外部軸仕様未確定xxx
    ELSE
        .cpos[1]=VAL($prm[TASKNO,5]);X
        .cpos[2]=VAL($prm[TASKNO,6]);Y
        .cpos[3]=VAL($prm[TASKNO,7]);Z
        .cpos[4]=VAL($prm[TASKNO,8]);R1
        .cpos[5]=0;xxx外部軸仕様未確定xxx
        .cpos[6]=0;xxx外部軸仕様未確定xxx
    END
    POINT .#cpos =#PPOINT(.cpos[1],.cpos[2],.cpos[3],.cpos[4],.cpos[5],.cpos[6])
    POINT .#offsetpos =#PPOINT(0,0,0,0,0,0)
;   FOR .i=1 TO 6
;       .offsetpos[.i]=0
;   END
    CALL shift_pos(.rno,.mode,MODE_BASE,.#cpos,.#offsetpos,.#outpos,.ret)
    CALL chk_pos(.rno,.mode,.#outpos,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    IF .mode == MODE_JT THEN;JMOVE
        .sp=SAFTY_MOVE_SP
    ELSE;LMOVE
        .sp=SAFTY_LMOVE_SP;指定位置移動とティーチ移動のLMOVEのみに使用
    END
    ;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    IF SYSDATA(ZSIMENV)<>2 THEN
        INTFCHK ON
    ELSE
        IF KROSET==TRUE THEN
            INTFCHK ON
        END
    END
    CALL movepos(.rno,.#t,.mode,.type,.#outpos,TRUE,.sp,DATA_ACC,DATA_DEC,DATA_ACCU,3,.ret)
    IF TASKNO==PG_MASTER THEN
      IF SYS_FORCE_CMODE==TRUE THEN
        SYS_FORCE_CMODE = FALSE
        SYN_MODE_END = TRUE
        ;終了処理
        FLG_REQ_MAMODE = FALSE
        CALL exec_alone(.ret)
      END
    END
.END

.PROGRAM get_jttype(.rno,.mode,.#axis_type)
;-------------------------------- 
;機能：軸構成情報取得
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)
;戻値：成否
;-------------------------------- 
    ;初期化
    ;MODE_LIN = 0
    ;MODE_ROT = 1
    IF .mode==MODE_JT THEN
        .axis_type[1]=MODE_ROT;JT1
        .axis_type[2]=MODE_ROT;JT2
        .axis_type[3]=MODE_LIN;JT3
        .axis_type[4]=MODE_ROT;JT4
        .axis_type[5]=MODE_ROT;xxx外部軸仕様未確定xxx
        .axis_type[6]=MODE_ROT;xxx外部軸仕様未確定xxx
    ELSE
        .axis_type[1]=MODE_LIN;X
        .axis_type[2]=MODE_LIN;Y
        .axis_type[3]=MODE_LIN;Z
        .axis_type[4]=MODE_ROT;R1
        .axis_type[5]=MODE_ROT;xxx外部軸仕様未確定xxx
        .axis_type[6]=MODE_ROT;xxx外部軸仕様未確定xxx
    END
    ;設定反映
    IF 1 THEN
        ;xxx外部軸仕様未確定xxx
        POINT .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6])
        RETURN
    END
    .temp_rno=.rno
    IF .temp_rno==0 THEN
        .temp_rno=1
    END
    IF .mode==MODE_JT THEN
        .target_axis=0;xxx外部軸仕様未確定xxx
        CASE DATA_EXTTYPE[.temp_rno] OF
            VALUE EXTTYPE_LINEAR:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->各軸動作、外部軸=直動軸"
                END
                .axis_type[.target_axis]=MODE_LIN
            VALUE EXTTYPE_ROT:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->各軸動作、外部軸=回転"
                END
                .axis_type[.target_axis]=MODE_ROT
            VALUE EXTTYPE_NONE:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->各軸動作、外部軸=切断"
                END
                .axis_type[.target_axis]=MODE_NONE
        END
    ELSE
        .target_axis=0;xxx外部軸仕様未確定xxx
        CASE DATA_EXTTYPE[.temp_rno] OF
            VALUE EXTTYPE_LINEAR:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->XYZR1EXT1動作、外部軸=直動"
                END
                .axis_type[.target_axis]=MODE_LIN
            VALUE EXTTYPE_ROT:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->XYZR1EXT1動作、外部軸=回転"
                END
                .axis_type[.target_axis]=MODE_ROT
            VALUE EXTTYPE_NONE:
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "get_jttype()->XYZR1EXT1動作、外部軸=切断"
                END
                .axis_type[.target_axis]=MODE_NONE
        END
    END
    POINT .#axis_type =#PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6])
.END

.PROGRAM adj_pos(.rno,.mode,.#inpos,.#outpos)
;-------------------------------- 
;機能：目標位置が動作範囲上下限を超えている場合に目標位置を動作範囲ギリギリに上書きする
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)、目標位置(実数配列)
;戻値：調整後位置(実数配列)
;--------------------------------
;    FOR .i=1 TO 6
;        .outpos[.i]=.inpos[.i]
;        .calpos[.i]=.inpos[.i]
;    END
    DECOMPOSE .inpos[1]  = .#inpos
    DECOMPOSE .calpos[1] = .#inpos
    DECOMPOSE .outpos[1] = .#inpos
    .mergin=0.1
    ;動作範囲取得
    GETULIMIT 1: .#ulimit[ROBOT_MASTER]
    GETLLIMIT 1: .#llimit[ROBOT_MASTER]
    GETULIMIT 2: .#ulimit[ROBOT_SLAVE]
    GETLLIMIT 2: .#llimit[ROBOT_SLAVE]
    DECOMPOSE .ulim_master[1]=.#ulimit[ROBOT_MASTER]
    DECOMPOSE .llim_master[1]=.#llimit[ROBOT_MASTER]
    DECOMPOSE .ulim_slave[1]=.#ulimit[ROBOT_SLAVE]
    DECOMPOSE .llim_slave[1]=.#llimit[ROBOT_SLAVE]
    ;XYZR1EXT1値から各軸値算出
    IF .mode==MODE_XYZR1EXT1 THEN
        IF .rno==ROBOT_SLAVE THEN
            ZL3JNT 2: .#tpos=.inpos[1],#S_HERE(2),1;逆変換
        ELSE
            ZL3JNT 1: .#tpos=.inpos[1],#S_HERE(1),1;逆変換
        END
        DECOMPOSE .outpos[1]=.#tpos
        DECOMPOSE .calpos[1]=.#tpos
    END
    ;各軸値で動作範囲チェック
    FOR .i=1 TO 6
        IF .rno==ROBOT_SLAVE THEN
            IF .calpos[.i]>.ulim_slave[.i]-.mergin THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_slave[.i]-.mergin
                END
                .outpos[.i]=.ulim_slave[.i]-.mergin
            END
            IF .calpos[.i]<.llim_slave[.i]+.mergin THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_slave[.i]+.mergin
                END
                .outpos[.i]=.llim_slave[.i]+.mergin
            END
        ELSE
            IF .calpos[.i]>.ulim_master[.i]-.mergin THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_master[.i]-.mergin
                END
                .outpos[.i]=.ulim_master[.i]-.mergin
            END
            IF .calpos[.i]<.llim_master[.i]+.mergin THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_master[.i]+.mergin
                END
                .outpos[.i]=.llim_master[.i]+.mergin
            END
        END
    END
    ;各軸値からXYZR1EXT1値算出
    IF .mode==MODE_XYZR1EXT1 THEN
        POINT .temp= #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
        DECOMPOSE .outpos[1]=.temp
    END
    POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
.END

.PROGRAM chk_pos(.rno,.mode,.#inpos,.ret)
;-------------------------------- 
;機能：目標位置が動作範囲内かチェック
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)、目標位置(実数配列)
;戻値：成否
;--------------------------------
    .ret = err_no_error
    ;位置情報生成
    DECOMPOSE .inpos[1] = .#inpos
    IF .mode==MODE_JT THEN
        POINT .#move_pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
        POINT .move_pos = .#move_pos
    ELSE
        POINT .move_pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
    END
    IF .rno==2 THEN
      .res = INRANGE:2(.move_pos,#S_HERE(2))
    ELSE
      .res = INRANGE(.move_pos,#S_HERE(1))
    END
    IF .res<>0 THEN
        .ret = err_out_range
    END
    IF .rno==0 AND .ret==err_no_error THEN
        ;協調動作の時はスレーブ側の目標位置もチェック
        POINT .temp = -S_HERE(1)+S_HERE(2)
        POINT .slave_pos = .move_pos+.temp
        .res = INRANGE:2(.slave_pos,#S_HERE(2))
        IF .res<>0 THEN
            .ret = err_out_range
        END
    END
.END

.PROGRAM cmdteach(.ret)
;-------------------------------- 
;機能：手動移動操作コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DISABLE_READJ_POS==TRUE THEN
        ;停止位置記憶有効フラグ
        FLG_ENABLE_STOPPOS=FALSE
    END
    ;ロボット番号
    .rno=VAL($prm[TASKNO,1])
    ;動作方法
    .mode=VAL($prm[TASKNO,2])
    ;ツール変換値MASTER
    .t[ROBOT_MASTER]=VAL($prm[TASKNO,3])
    ;ツール変換値SLAVE
    .t[ROBOT_SLAVE]=VAL($prm[TASKNO,4])
    POINT .#t =#PPOINT(.t[ROBOT_MASTER],.t[ROBOT_SLAVE],0,0,0,0)
    ;補間方法
    .type=VAL($prm[TASKNO,5])
    ;位置情報(実機調整が必要な可能性有)
    IF .mode == MODE_JT THEN
        ;位置情報MASTER
        .flag[1,1]=VAL($prm[TASKNO,6]);JT1
        .flag[1,2]=VAL($prm[TASKNO,7]);JT2
        .flag[1,3]=VAL($prm[TASKNO,8]);JT3
        .flag[1,4]=VAL($prm[TASKNO,9]);JT4
        .flag[1,5]=0;xxx外部軸仕様未確定xxx
        .flag[1,6]=0;xxx外部軸仕様未確定xxx
        ;位置情報SLAVE
        .flag[2,1]=VAL($prm[TASKNO,11]);JT1
        .flag[2,2]=VAL($prm[TASKNO,12]);JT2
        .flag[2,3]=VAL($prm[TASKNO,13]);JT3
        .flag[2,4]=VAL($prm[TASKNO,14]);JT4
        .flag[2,5]=0;xxx外部軸仕様未確定xxx
        .flag[2,6]=0;xxx外部軸仕様未確定xxx
    ELSE
        ;X,Y,Z,R1,EXT
        ;位置情報MASTER
        .flag[1,1]=VAL($prm[TASKNO,6]);X
        .flag[1,2]=VAL($prm[TASKNO,7]);Y
        .flag[1,3]=VAL($prm[TASKNO,8]);Z
        .flag[1,4]=VAL($prm[TASKNO,9]);R1
        .flag[1,5]=0;xxx外部軸仕様未確定xxx
        .flag[1,6]=0;xxx外部軸仕様未確定xxx
        ;位置情報SLAVE
        .flag[2,1]=VAL($prm[TASKNO,11]);X
        .flag[2,2]=VAL($prm[TASKNO,12]);Y
        .flag[2,3]=VAL($prm[TASKNO,13]);Z
        .flag[2,4]=VAL($prm[TASKNO,14]);R1
        .flag[2,5]=0;xxx外部軸仕様未確定xxx
        .flag[2,6]=0;xxx外部軸仕様未確定xxx
    END
    CALL get_jttype(.rno,.mode,.#axis_type)
    DECOMPOSE .axis_type[1] = .#axis_type
    FOR .i=1 TO 6
        CASE .rno OF
            VALUE ROBOT_ALL:
                ;協調動作
                IF TASKNO==PG_MASTER THEN
                  ;開始処理
                  SYS_FORCE_CMODE=TRUE
                  SYN_MODE_START = TRUE
                END
                CASE .axis_type[.i] OF
                    VALUE MODE_LIN:
                        .offsetpos[.i]=DATA_TEACHPITCH*.flag[1,.i]
                    VALUE MODE_ROT:
                        .offsetpos[.i]=DATA_TEACHROT*.flag[1,.i]
                    ANY
                        .offsetpos[.i]=0
                END
            VALUE ROBOT_MASTER:
                CASE .axis_type[.i] OF
                    VALUE MODE_LIN:
                        .offsetpos[.i]=DATA_TEACHPITCH*.flag[1,.i]
                    VALUE MODE_ROT:
                        .offsetpos[.i]=DATA_TEACHROT*.flag[1,.i]
                    ANY
                        .offsetpos[.i]=0
                END
            VALUE ROBOT_SLAVE:
                CASE .axis_type[.i] OF
                    VALUE MODE_LIN:
                        .offsetpos[.i]=DATA_TEACHPITCH*.flag[2,.i]
                    VALUE MODE_ROT:
                        .offsetpos[.i]=DATA_TEACHROT*.flag[2,.i]
                    ANY
                        .offsetpos[.i]=0
                END
        END
    END
    ;基準用現在値取得
    CALL GetCurrentPos(.rno,.mode,.#cpos,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    POINT .#offsetpos = #PPOINT(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6])
    CALL shift_pos(.rno,.mode,DATA_TEACHCOORDINATE,.#cpos,.#offsetpos,.#outpos,.ret)
    CALL chk_pos(.rno,.mode,.#outpos,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    IF .mode == MODE_JT THEN;JMOVE
        .sp=SAFTY_MOVE_SP
    ELSE;LMOVE
        .sp=SAFTY_LMOVE_SP;指定位置移動とティーチ移動のLMOVEのみに使用
    END
    INTFCHK OFF
    CALL movepos(.rno,.#t,.mode,.type,.#outpos,TRUE,.sp,DATA_ACC,DATA_DEC,DATA_ACCU,3,.ret)
    IF TASKNO==PG_MASTER THEN
      IF SYS_FORCE_CMODE==TRUE THEN
        SYS_FORCE_CMODE = FALSE
        SYN_MODE_END = TRUE
        ;終了処理
        FLG_REQ_MAMODE = FALSE
        CALL exec_alone(.ret)
      END
    END
.END

.PROGRAM GetCurrentPos(.rno,.mode,.#pos,.ret)
;-------------------------------- 
;機能：現在値を指定モードで取得してDECOMPOSEした値を返す
;引数：モード(MODE_JT,MODE_XYZR1EXT1)
;戻値：DECOMPOSEした位置要素配列、成否
;-------------------------------- 
    .ret = err_no_error
    CASE .mode OF
        VALUE MODE_JT:
            IF .rno==0 OR .rno==1 THEN
                ;両方のロボットを動かすときはMASTER側が基準
                POINT .#pos1=#S_HERE(1)
            ELSE
                POINT .#pos1=#S_HERE(2)
            END
            DECOMPOSE .pos[1]=.#pos1
        VALUE MODE_XYZR1EXT1:
            IF .rno==0 OR .rno==1 THEN
                ;両方のロボットを動かすときはMASTER側が基準
                IF 0 THEN
                    ;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
                    ZL3TRN 1: .pos[1]=#S_HERE(1),1
                ELSE
                    ;ツール変換値考慮
                    DECOMPOSE .pos[1]=S_HERE(1)
                END    
;                POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
            ELSE
                IF 0 THEN
                    ;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
                    ZL3TRN 2: .pos[1]=#S_HERE(2),1
                ELSE
                    ;ツール変換値考慮
                    DECOMPOSE .pos[1]=S_HERE(2)
                END    
 ;               POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
            END
;            DECOMPOSE .pos[1]=.pos
        ANY
            .ret=err_bad_mode
            RETURN
    END
    POINT .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
.END

.PROGRAM cmdsetparam(.cmd,.ret)
;-------------------------------- 
;機能：変数設定コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL setparam(.cmd,.ret)
.END

.PROGRAM cmdgetparam(.cmd,.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
    .ret = err_no_error
    CALL getparam(.cmd,.$res,.ret)
.END

.PROGRAM cmdnameset(.cmd,.ret)
;-------------------------------- 
;機能：名称設定
;引数：文字列配列
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL nameset(.cmd,.ret)
.END

.PROGRAM chk_exe_staus(.ret)
;-------------------------------- 
;機能：作業実行中か判定
;引数：無し
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    FOR .rno=1 TO 2
        IF DATA_CUR_L2REC[.rno]<>0 OR DATA_CUR_L3REC[.rno]<>0 THEN
            .ret=err_still_working
            RETURN
        END
    END
.END

.PROGRAM get_workno(.work_no,.ret)
;-------------------------------- 
;機能：作業グループ番号取得
;引数：作業グループ番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .work_no = 0
    ; 作業グループ設定確認(信号入力の場合)
    IF DATA_WSET_SPEC==0 THEN
        CALL get_iotype(DATA_WSET_SET[1],.sigtype,.ret)
        IF .ret<>err_no_error OR .sigtype==IO_DO OR DATA_WSET_SET[2]<1 OR 8<DATA_WSET_SET[2] THEN; 信号番号範囲外または出力信号または信号数が1〜8ではない場合はエラー
            .ret = err_work_set
            GOTO end
        END
    END
    ; 作業グループ番号取得
    IF DATA_WSET_SPEC==1 THEN
        .work_no = DATA_WSET_NO; タブレット
    ELSE
        .work_no = BITS(DATA_WSET_SET[1],DATA_WSET_SET[2]); 信号入力
    END
    IF .work_no==0 THEN; 取得した作業グループ番号が「0」の場合はエラー
        .ret = err_work_set
        GOTO end
    END
    ;取得した作業グループが最大作業グループ数を超えている場合はエラー
    IF .work_no>data_cur_maxnum THEN
        .ret = err_work_set
        GOTO end
    END
    ; 取得した作業グループ番号が第２階層で使用されていない場合はエラー
    FOR .i=1 TO DATA_L2NUM
        IF DATA_L2WORKNO[.i]==.work_no THEN
            GOTO end
        END
    END
    .ret = err_work_set
end:
    RETURN
.END

.PROGRAM cmdexe(.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;ロボット状態遷移
    robot_status = sta_exe
    ;個別実行記憶フラグ
    FLG_SINGLE_MOVE=FALSE
    ;停止位置記憶有効フラグ
    FLG_ENABLE_STOPPOS=FALSE
    ; 作業グルーピング設定確認
    IF DATA_WSET_ENA<>FALSE THEN
        CALL get_workno(.work_no,.ret)
        DATA_CUR_WORKNO = .work_no
        IF .ret<>err_no_error THEN
            RETURN
        END
    ELSE
        DATA_CUR_WORKNO = -999; 作業グルーピング設定無効
    END
    ; ビジョン結果ＮＧ信号初期化
    SIGNAL -ix_result_vng[1]
    SIGNAL -ix_result_vng[2]
    ; 信号待ちＮＧ(タイムアウト)信号初期化
    SIGNAL -ix_iowait_to[1]
    SIGNAL -ix_iowait_to[2]
    IF DISABLE_CONTINUE==FALSE THEN
        CALL chk_exe_staus(.ret)
        IF .ret<>err_no_error THEN
            RETURN
        END
    END
    ;位置チェック
    CALL check_pos(VAL($prm[TASKNO,1]),CMD_EXE_START,.ret)
    IF .ret<>err_no_error THEN
        CALL update_error(.ret)
        RETURN
    END
    CALL cmdexecore(.ret)
    ;実行完了後は再開不可
    CALL updatel2l3info(TRUE,0,0,TRUE)
    ;ロボット状態遷移
    robot_status = sta_nomove
.END

.PROGRAM cmdexecore(.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdexe() .rno=",$prm[TASKNO,1]
    END
    .exe_num = VAL($prm[TASKNO,2])
    IF .exe_num <= 0 THEN
        .ret=err_bad_num
        RETURN
    END
    IF $DATA_PGNAME == "" THEN
        .ret=err_exe_name
        RETURN
    END
    DATA_EXECUTE = TRUE
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdexe() STARTING $DATA_PGNAME=",$DATA_PGNAME
    END
    ;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    IF SYSDATA(ZSIMENV)<>2 THEN
        INTFCHK ON
    ELSE
        IF KROSET==TRUE THEN
            INTFCHK ON
        END
    END
    FOR .i=1 TO .exe_num
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdexe() Executing.... ",$DATA_PGNAME,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
        END
        ;作業連続実行開始
        CALL MAINEXE
        BREAK
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdexe() Done ",$DATA_PGNAME,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
        END
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdexe() DONE $DATA_PGNAME=",$DATA_PGNAME
    END
    .ret=G_LAST_ERROR
.END

.PROGRAM cmdsetstep(.ret)
;-------------------------------- 
;機能：作業情報の設定
;引数：実数配列
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL setstep(.ret)
.END

.PROGRAM cmdgetstep(.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
    .ret = err_no_error
    CALL getstep(.$res,.ret)
.END

.PROGRAM cmdsetsteppos(.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL setsteppos(.ret)
.END

.PROGRAM cmdgetsteppos(.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
    .ret = err_no_error
    CALL getsteppos(.$res,.ret)
.END

.PROGRAM cmdsetstepifgot(.ret)
;-------------------------------- 
;機能：作業用条件分岐詳細設定
;引数：2:第2階層番号、3:第3階層番号、4:条件番号、
;      5:分岐指定、6:分岐判断種類、7:分岐判断材料、8:分岐判定閾値
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  CALL setstepifgoto(.ret)
.END

.PROGRAM cmdgetstepifgot(.$res,.ret)
;-------------------------------- 
;機能：条件分岐詳細取得
;引数：第2階層番号、第3階層番号、条件番号
;戻値：取得データ文字列、成否
;-------------------------------- 
    .ret = err_no_error
    CALL getstepifgoto(.$res,.ret)
.END

.PROGRAM get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
;-------------------------------- 
;機能：データを遡って協調開始コマンド、並列実行コマンドが無いかチェックする
;引数：第2階層、第3階層
;戻値：並列実行再要求フラグ、協調動作再実行フラグ
;-------------------------------- 
    .req_cstart=FALSE
    .req_wstart=FALSE
    FOR .i=.l3num TO 1 STEP -1
        IF DATA_L3TYPE[.l2num,.i]==L3TYPE_CEND THEN
            ;STARTの前にENDを見つけたら探索中断、再実行不要
            GOTO 10
        END
        IF DATA_L3TYPE[.l2num,.i]==L3TYPE_CSTART THEN
            ;再度必要
            .req_cstart = TRUE
            GOTO 10
        END
    END
10
    FOR .i=.l3num TO 1 STEP -1
        IF DATA_L3TYPE[.l2num,.i]==L3TYPE_WEND THEN
            ;STARTの前にENDを見つけたら探索中断、再実行不要
            IF DATA_CUR_L2REC[ROBOT_SLAVE]<>0 AND DATA_CUR_L3REC[ROBOT_SLAVE] THEN
                ;スレーブロボット動作中のため再度必要
                .req_wstart = TRUE
            END
            GOTO 20
        END
        IF DATA_L3TYPE[.l2num,.i]==L3TYPE_WSTART THEN
            ;再度必要
            .req_wstart = TRUE
            GOTO 20
        END
    END
20
.END

.PROGRAM chk_slow_start()
;-------------------------------- 
;機能：スロースタート判定
;引数：無し
;戻値：無し
;-------------------------------- 
  IF SLOWLIMIT_ENA<>FALSE AND FLG_SINGLE_MOVE==FALSE THEN; スロースタート有効かつ個別実行ではない時
    ; スロースタート用タイマーリセット
    UTIMER @SLOWLIMIT_TIMER = 0
    ; 現在のプログラム速度を取得
    .now_pg_sp = SYSDATA(P.SPEED,ROBOT_MASTER); %
    .now_pg_sp_m = SYSDATA(P.SPEED.M,ROBOT_MASTER); mm/sec
    .sp_m_max = .now_pg_sp_m/(.now_pg_sp/100)
    ; スロースタートの速度を算出(mm/sec⇒%)
    .slowstart_sp = (SLOWLIMIT_SPEED/.sp_m_max)*100
    ; 現在のモニタ速度を取得
    .now_mon_sp = SYSDATA(M.SPEED,ROBOT_MASTER)
    IF .now_mon_sp>.slowstart_sp THEN
      ; 初期化(変更確認用)
      CHG_BEF_MSPEED[ROBOT_MASTER] = 0
      CHG_BEF_MSPEED[ROBOT_SLAVE] = 0
      ; 速度変更確認
      IF FLG_SLOWLIMIT==FALSE THEN; スロースタート中ではない時
        FLG_SLOWLIMIT = TRUE; スロースタートON
        CHG_BEF_MSPEED[ROBOT_MASTER] = .now_mon_sp
        IF FLG_SLAVE_MOVE==TRUE THEN
          CHG_BEF_MSPEED[ROBOT_SLAVE] = SYSDATA(M.SPEED,ROBOT_SLAVE)
        END
      ELSE; スロースタート中の時
        ; 現在のプログラム速度がSLOWLIMIT_SPEEDの時はモニタ速度を変更しない
        IF .now_pg_sp_m<(SLOWLIMIT_SPEED-ROBOT_MASTER) OR (SLOWLIMIT_SPEED+1)<.now_pg_sp_m THEN
          CHG_BEF_MSPEED[ROBOT_MASTER] = .now_mon_sp
        END
        IF FLG_SLAVE_MOVE==TRUE THEN
          ; 現在のプログラム速度を取得
          .now_pg_sp_m2 = SYSDATA(P.SPEED.M,ROBOT_SLAVE)
          IF .now_pg_sp_m2<(SLOWLIMIT_SPEED-1) OR (SLOWLIMIT_SPEED+1)<.now_pg_sp_m2 THEN
            CHG_BEF_MSPEED[ROBOT_SLAVE] = SYSDATA(M.SPEED,ROBOT_SLAVE)
          END
        END
      END
      ; 速度変更(プログラム速度は変更出来ないのでモニタ速度で調整)
      FOR .rno=ROBOT_MASTER TO ROBOT_SLAVE
        IF CHG_BEF_MSPEED[.rno]<>0 THEN
          .chg_mon_sp = INT((.slowstart_sp*100)/SYSDATA(P.SPEED,.rno))
          IF .chg_mon_sp>CHG_BEF_MSPEED[.rno] THEN
            .chg_mon_sp = CHG_BEF_MSPEED[.rno]
          END
          MC SPEED .rno:.chg_mon_sp
          IF DEBUG.PRT.SP==TRUE THEN
              PRINT "chk_slow_start() -> M.SPEED",SYSDATA(M.SPEED,.rno), "[%], P.SPEED",SYSDATA(P.SPEED,.rno),"[%], TASKNO =",TASKNO,", rno =",.rno
          END
          CHG_AFT_MSPEED[.rno] = SYSDATA(M.SPEED,.rno)
        END
      END
    END
  END
.END

.PROGRAM cmdrestart(.ret)
;-------------------------------- 
;機能：CONTINUEコマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;外部制御盤操作を許容する
    IF 0 THEN
        IF TASKNO<>PG_COM_NOACT THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "TASKNO=",TASKNO,"->cmdrestart() 非動作コマンドポートからの実行指示のみ可能"
            END
            RETURN
        END
    END
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "cmdrestart()->TASKNO=",TASKNO,",ROBOT_NUM=",$prm[TASKNO,1]
    END
    ;動作プログラム実行要否確認
    CALL check_exec_pg(.flg_exec_main)
    IF .flg_exec_main==FALSE THEN
        RETURN; 再開出来ない状態(プログラムが実行中!?)
    END
    ;個別実行再開ではない場合
    IF flg_single_move==FALSE THEN
        ;作業グループ番号変更確認
        IF DATA_WSET_ENA<>FALSE THEN
            CALL get_workno(.work_no,.ret)
            IF .ret<>err_no_error OR DATA_CUR_WORKNO<>.work_no THEN
                .ret = err_work_unmatch
                CALL update_error(.ret)
                RETURN
            END
        END
    END
    ;PCプログラムから実行するためこのタイミングでOPE_COMMANDを更新する
    OPE_COMMAND=CMD_EXE_RESTART
    IF DISABLE_CONTINUE==FALSE THEN
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "cmdrestart()->START CHECK ROBOT-ACTION STATUS"
        END
        EXOUT_START_FLASH_MODE=FALSE
        CALL chk_exe_staus(.exe_status)
        IF .exe_status<>err_no_error THEN
            IF FLG_MASTER_MOVE==TRUE OR FLG_SLAVE_MOVE==TRUE THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "cmdrestart()->ロボットの動作中のため再開操作を実行できません。"
                END
                RETURN
            END
            ;モータOFFしている場合はモータONする
            IF SWITCH(POWER,1)==OFF OR SWITCH(POWER,2)==OFF THEN
                UTIMER .@NowTime = 0 
                DO
                    MC ZPOWER ON
                    IF UTIMER(.@NowTime)>POWER_TIMEOUT THEN
                        IF SWITCH(POWER,1)==OFF THEN
                            PRINT "Can NOT motor-on on MASTER-ROBOT."
                        END
                        IF SWITCH(POWER,2)==OFF THEN
                            PRINT "Can NOT motor-on on SLAVE-ROBOT."
                        END
                        .ret=err_poweron
                        CALL update_error(.ret)
                        RETURN
                    END
                    TWAIT ascycle
                UNTIL (SWITCH(POWER,1)==ON AND SWITCH(POWER,2)==ON)
            END
            ;位置チェック
            IF FLG_ENABLE_STOPPOS==TRUE THEN
                CALL check_pos(VAL($prm[TASKNO,1]),CMD_EXE_RESTART,.ret)
            END
            IF .ret<>err_no_error THEN
                CALL update_error(.ret)
                RETURN
            END
            EXOUT_START_FLASH_MODE=FALSE
            ;作業実行フラグ
            DATA_EXECUTE = TRUE
            ;中断された作業を継続実行する
            .l2num=DATA_CUR_L2REC[ROBOT_MASTER]
            .l3num=DATA_CUR_L3REC[ROBOT_MASTER]
            CALL get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
            IF .req_wstart==TRUE THEN
                ;並列中のスレーブロボット動作
                IF DATA_CUR_L2REC[ROBOT_SLAVE]<>0 AND DATA_CUR_L3REC[ROBOT_SLAVE]<>0 THEN
                    ;スレーブロボット並列動作継続実行
                    FLG_SLAVE_MOVE = TRUE
                END
            END
            IF .l2num<>0 AND .l3num<>0 THEN
                ;マスターロボット動作継続実行
                FLG_MASTER_MOVE = TRUE
                ;非並列中のスレーブロボット単独動作
                IF NOW_MOVE_L3NUM[ROBOT_MASTER]<>0 THEN
                    IF NOW_MOVE_L3NUM[ROBOT_SLAVE]==0 AND DATA_ROBOTTYPE[.l2num,NOW_MOVE_L3NUM[ROBOT_MASTER]]==ROBOT_SLAVE THEN
                        IF DATA_L3TYPE[.l2num,.l3num]==L3TYPE_MOVE THEN
                            ;スレーブロボット動作継続実行
                            FLG_SLAVE_MOVE = TRUE
                            ;マスターロボットスレーブ動作待ちタイマーリセット
                            UTIMER @SlaveTime = 0
                        END
                    END
                END
            END
            ; ビジョン並列インターロックタイマー初期化
            UTIMER @vtime_mas = 0
            UTIMER @vtime_sla = 0
            ;スロースタート確認
            CALL chk_slow_start
            ;status_check関数でエラーを発生させないようにフラグを操作
            FLG_RESTART = TRUE
            ;エラー状態を一旦解除する
            G_LAST_ERROR = err_no_error
            ;status_check関数でエラーを発生させないように操作したフラグを戻す
            FLG_MAIN_RUN = TRUE
            FLG_TABLET_RUN[1] = TRUE
            FLG_TABLET_RUN[2] = TRUE
            ;中断された状態から再開
            UTIMER .@NowTime = 0
            .comp_flag = FALSE
            MC CONTINUE
            IF .req_cstart==FALSE THEN
                MC CONTINUE 2:; 協調動作中は必要ない！！
            END
            DO
                IF (SWITCH(CS,1)==ON AND TASK(1)==1) AND (SWITCH(CS,2)==ON AND TASK(2)==1) THEN
                  .comp_flag = TRUE
                END
            UNTIL(.comp_flag==TRUE OR UTIMER(.@NowTime)>BOOT_TIMEOUT)
            IF SWITCH(CS,1)==OFF OR SWITCH(CS,2)==OFF THEN
                IF SWITCH(CS,1)==OFF THEN
                    PRINT "Can NOT continue program on MASTER-ROBOT."
                END
                IF SWITCH(CS,2)==OFF THEN
                    PRINT "Can NOT continue program on SLAVE-ROBOT."
                END
                .ret=err_main_start
                CALL update_error(.ret)
                RETURN
            END
            ;ロボット状態遷移
            IF flg_single_move==FALSE THEN
                robot_status = sta_exe
            ELSE
                robot_status = sta_l2exe
            END
            ;status_check関数でエラーを発生させないように操作したフラグを戻す
            FLG_RESTART = FALSE
            RETURN
        ELSE
            PRINT "cmdrestart()->再開できません。"
        END
    END
.END

.PROGRAM cmdhold(.ret)
;-------------------------------- 
;機能：一時停止コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;2015/10/2機能削除
    RETURN
.END

.PROGRAM cmdabort(.ret)
;-------------------------------- 
;機能：中断コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;外部制御盤操作を許容する
    IF 0 THEN
        IF TASKNO<>PG_COM_NOACT THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "TASKNO=",TASKNO,"->cmdabort() 非動作コマンドポートからの実行指示のみ可能"
            END
            RETURN
        END
    END
    IF FLG_MASTER_MOVE==TRUE OR FLG_SLAVE_MOVE==TRUE OR SWITCH(CS,1)==ON OR SWITCH(CS,2)==ON THEN
        EXOUT_START_FLASH_MODE=FALSE
        ;status_check関数でエラーを発生させないようにフラグ操作する
        FLG_MAIN_RUN=FALSE
        IF ROBOT_MODE==MODE_DIRECT AND ROBOT_MODE_FLG<>FALSE AND FLG_DIRECT_RUN==TRUE THEN
            FLG_DIRECT_RUN = FALSE
        END
        ;HOLD後、PCプログラムがエラーを検知する←status_check関数でエラーを発生させないように仕様変更する20151006
        UTIMER .@NowTime = 0
        .comp_flag = FALSE
        MC HOLD 1:
        MC HOLD 2:
        DO
            IF (SWITCH(CS,1)==OFF) AND (SWITCH(CS,2)==OFF) THEN
              .comp_flag = TRUE
            END
        UNTIL(.comp_flag==TRUE OR UTIMER(.@NowTime)>BOOT_TIMEOUT)
        IF SWITCH(CS,1)==ON OR SWITCH(CS,2)==ON THEN
            IF SWITCH(CS,1)==ON THEN
              PRINT "Can NOT abort program on MASTER-ROBOT."
            END
            IF SWITCH(CS,2)==ON THEN
              PRINT "Can NOT abort program on SLAVE-ROBOT."
            END
            .ret=err_main_stop
            RETURN
        END
        IF DATA_EXECUTE==TRUE THEN
            CALL update_holdpos
        END
        CALL reset_mon_sp(ROBOT_ALL); モニタ速度を変更している場合は元に戻す
        ;status_check関数でエラーを発生させないため、本来status_check関数で初期化するパラメータをここで初期化する
        CALL chk_robot_stop_status
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "cmdabort()->ROBOT_NUM=",$prm[TASKNO,1]
            PRINT "cmdabort()->SENDING REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
        END
    ELSE
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "cmdabort()->ROBOT_NUM=",$prm[TASKNO,1]
            PRINT "cmdabort()->NO NEED SEND REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
        END
    END
.END

.PROGRAM cmdl2exe(.ret)
;-------------------------------- 
;機能：第2階層指定個別実行コマンド
;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;ロボット状態遷移
    robot_status = sta_l2exe
    ;個別実行記憶フラグ
    FLG_SINGLE_MOVE=TRUE
    ;停止位置記憶有効フラグ
    FLG_ENABLE_STOPPOS=FALSE
    ; ビジョン結果ＮＧ信号初期化
    SIGNAL -ix_result_vng[1]
    SIGNAL -ix_result_vng[2]
    ; 信号待ちＮＧ(タイムアウト)信号初期化
    SIGNAL -ix_iowait_to[1]
    SIGNAL -ix_iowait_to[2]
    .l2num=VAL($prm[TASKNO,2])
    .flg_l2chk=VAL($prm[TASKNO,3])
    .repeat_num=VAL($prm[TASKNO,4])
    PRINT "TASKNO=",TASKNO,",cmdl2exe()->.rno=",VAL($prm[TASKNO,1]),",.l2num=",.l2num,",.flg_l2chk=",.flg_l2chk,",.repeat_num=",.repeat_num
    FOR .i=1 TO DATA_L2NUM
        DATA_L2STATUS[.i]=FALSE
    END
    DATA_EXECUTE = TRUE
    ;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    IF SYSDATA(ZSIMENV)<>2 THEN
        INTFCHK ON
    ELSE
        IF KROSET==TRUE THEN
            INTFCHK ON
        END
    END
    FOR .i=1 TO .repeat_num
        IF DISABLE_L2CHK==TRUE THEN
            ;順次実行
            FLG_SLAVE_MOVE = FALSE
            CALL l2exec(.l2num,1,.ret)
            IF (.ret<>err_no_error) OR (G_LAST_ERROR<>err_no_error) THEN
                CALL update_error(.ret)
                RETURN
            END
        ELSE
            IF .flg_l2chk==1 THEN
                ;第2階層条件チェック実行
                ;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
                DO
                    CALL l2check(.l2num_ok,.ret)
                    IF ((.ret<>TRUE) OR (.l2num_ok<>.l2num)) THEN
                        FLG_L2CHK_WAIT = TRUE
                    END
                UNTIL((.ret==TRUE) AND (.l2num_ok==.l2num))
            END
            FLG_L2CHK_WAIT = FALSE
            CALL l2exec(.l2num,1,.ret)
            IF (.ret<>err_no_error) OR (G_LAST_ERROR<>err_no_error) THEN
                CALL update_error(.ret)
                RETURN
            END
        END
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "->cmdl2exe() DONE .l2num=",.l2num,",.repeat_num=",.i
        END
    END
    ;個別実行完了後は再開不可
    CALL updatel2l3info(TRUE,0,0,TRUE)
    ;ロボット状態遷移
    robot_status = sta_nomove
.END

.PROGRAM cmdhand(.ret)
;-------------------------------- 
;機能：ハンド操作コマンド
;引数：ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .rno=VAL($prm[TASKNO,1])
    .status=VAL($prm[TASKNO,2])
    CALL hand(.rno,.status,.ret)
.END

.PROGRAM cmdgravityadj(.ret)
;-------------------------------- 
;重力補償自動調整コマンド
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
    .ret=err_no_error
    ;ロボット状態遷移
    robot_status = sta_gravityadj
    .rno=VAL($prm[TASKNO,1])
    ;モード(0:自動、1:手動)
    .mode=VAL($prm[TASKNO,2])
    ;マスタ設定値
    .master_setval=VAL($prm[TASKNO,3])
    ;スレーブ設定値
    .slave_setval=VAL($prm[TASKNO,4])
    IF .mode==0 THEN
        ;重力補償自動調整実行後は再開不可
        CALL updatel2l3info(TRUE,0,0,TRUE)
        ;自動調整の場合は原点確認
        CALL check_pos(VAL($prm[TASKNO,1]),CMD_EXE_GRAVITYADJ,.ret)
    ELSE
        IF .rno==1 AND (.master_setval>200 OR .master_setval<-200) THEN
            .ret=err_bat_value
        END
        IF .rno==2 AND (.slave_setval>200 OR .slave_setval<-200) THEN
            .ret=err_bat_value
        END
    END
    IF .ret<>err_no_error THEN
        robot_status = sta_nomove
        CALL update_error(.ret)
        RETURN
    END
    FLG_GRAVITYADJ_ACTIVE=TRUE
    CALL gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
    BREAK
    FLG_GRAVITYADJ_ACTIVE=FALSE
    ;ロボット状態遷移
    robot_status = sta_nomove
    
.END

.PROGRAM cmdzero(.rno,.jtno,.val,.ret)
;-------------------------------- 
;ゼロイング設定コマンド
;引数：ロボット番号、軸番号、軸設定値
;戻値：成否
;-------------------------------- 
    .ret=err_no_error
    ;エラー中実行不可
    IF G_LAST_ERROR<>err_no_error THEN
        .ret=G_LAST_ERROR
        RETURN
    END
    ;サイクル中実行不可
    IF SWITCH(CS,1)==ON OR SWITCH(CS,2)==ON THEN
        .ret=err_robot_busy
        RETURN
    END
    ;モータ電源は自動OFF(モータ電源ONは他のシーケンスに任せる)
    IF SWITCH(POWER,1)==ON OR SWITCH(POWER,2)==ON THEN
        CALL cmdabort(.ret)
        UTIMER .@NowTime = 0 
        DO
            MC ZPOWER OFF
            IF UTIMER(.@NowTime)>POWER_TIMEOUT THEN
                PRINT "->RdyBoot() Can NOT motor-off."
                .ret=err_motor_off
                RETURN
            END
            TWAIT ascycle
        UNTIL (SWITCH(POWER,1)==OFF AND SWITCH(POWER,2)==OFF)
    END
    CASE .rno OF
        VALUE ROBOT_ALL:
            .ret=err_bad_rno
            RETURN
        VALUE ROBOT_MASTER,ROBOT_SLAVE:
            IF .jtno>=5 THEN
                .ret=err_bad_axesno
                RETURN
            ELSE
                IF .jtno<=0 THEN
                    FOR .i=1 TO 4
                        ZJZERO .rno: .i,.val
                    END
                ELSE
                    ZJZERO .rno: .jtno,.val
                END
            END
        ANY
            .ret=err_bad_rno
            RETURN
    END
    RETURN
.END

.PROGRAM cmdexevcalchk(.ret)
;-------------------------------- 
;機能：カメラキャリブレーション精度チェック実行
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;ロボット状態遷移
    robot_status = sta_vscalib; カメラキャリブレーションと共通の状態遷移変数
    .camno = VAL($prm[TASKNO,2]); カメラ番号
    .$cam = $ENCODE(/I1,.camno); カメラ番号
    .$chk_r = "vcal_robot["+.$cam+"]"
    IF EXISTDATA(.$chk_r,R)==OFF THEN
      .ret = err_vis_nocalib; キャリブレーション未実施
      CALL error_log(.ret)
      robot_status = sta_nomove
      RETURN
    END
    .rno = vcal_robot[.camno]; キャリブレーション時のロボット番号を使用
    .height = VAL($prm[TASKNO,3])
    ;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
    CALL updatel2l3info(TRUE,0,0,TRUE)
    CASE .rno OF
    VALUE ROBOT_ALL:
        .ret=err_bad_rno
        robot_status = sta_nomove
        RETURN
    VALUE ROBOT_MASTER:
        CALL vision_excalchk(.rno,.camno,.height,.ret)
    VALUE ROBOT_SLAVE:
        ;パラメータ設定
        GS_RNO = .rno
        GS_CAMNO = .camno
        GS_HEIGHT = .height
        FLG_SLAVE_MOVE = TRUE; スレーブロボット実行
        ;スレーブロボット終了待ち
        WHILE(1)
            IF FLG_SLAVE_MOVE==FALSE THEN
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
                END
                ;ロボット状態遷移
                .ret = gs_excalchk_err
                robot_status = sta_nomove
                RETURN
            ELSE
                IF DEBUG.PRT.CMD==TRUE THEN
                    PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
                END
            END
        END
    END
    ;ロボット状態遷移
    robot_status = sta_nomove
.END

.PROGRAM check_exec_pg(.flg_exec_main)
;-------------------------------- 
;機能：動作プログラム実行要否判定
;引数：無し
;戻値：動作プログラム実行要否
;--------------------------------
    .flg_exec_main=FALSE
    ;サイクルランプが落ちてる場合
    IF (SWITCH(CS,1)==OFF OR SWITCH(CS,2)==OFF) THEN
        .flg_exec_main=TRUE
        RETURN
    END
    ;要求ロボットモードと動作中のプログラムが異なる場合
    IF (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE) AND (FLG_MAIN_RUN==TRUE) THEN
        .flg_exec_main=TRUE
        RETURN
    END
    ;要求ロボットモードと動作中のプログラムが異なる場合
    IF (ROBOT_MODE==MODE_TABLET) AND (ROBOT_MODE_FLG<>FALSE) AND (FLG_DIRECT_RUN==TRUE) THEN
        .flg_exec_main=TRUE
        RETURN
    END
.END

.PROGRAM exec_pg(.ret)
;-------------------------------- 
;機能：プログラム実行
;引数：無し
;戻値：成否
;--------------------------------
    .ret=err_no_error
    CALL check_exec_pg(.flg_exec_main)
    IF .flg_exec_main==TRUE THEN
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->exec_pg() Start execute program automatically."
        END
        CALL ExecMain(ROBOT_MODE,ROBOT_MODE_FLG,.ret)
        
        UTIMER .@NowTime = 0
        DO
            IF UTIMER(.@NowTime)>5 THEN
                .ret=err_main_start
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "->exec_pg() ExecMain timeout occured."
                END
                RETURN
            END
        UNTIL(.ret<>err_no_error OR (((FLG_MAIN_RUN==TRUE) OR (FLG_DIRECT_RUN==TRUE)) AND (SWITCH(CS,1)==ON AND FLG_MASTER_MOVE==FALSE) AND (SWITCH(CS,2)==ON) AND FLG_SLAVE_MOVE==FALSE))
        IF .ret<>err_no_error THEN
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "->exec_pg() Can not executed program."
            END
        ELSE
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "->exec_pg() Executed program successfully."
            END
        END
    ELSE
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->exec_pg() Skipped executed program."
        END
    END
.END

.PROGRAM check_exec_cmd(.cmd,.flg_exec_cmd)
;-------------------------------- 
;機能：コマンド実行制限
;引数：無し
;戻値：可否
;--------------------------------
    .flg_exec_cmd=TRUE
    IF (ROBOT_MODE==MODE_TABLET) AND (ROBOT_MODE_FLG==FALSE) THEN
        ;タブレットモード(手動教示)OFF
        CASE .cmd OF
            VALUE CMD_EXE_TEACH,CMD_EXE_MOVE:
                ;ティーチ系禁止
                .flg_exec_cmd=FALSE
        END
    END
    IF (ROBOT_MODE_FLG<>FALSE) THEN
        ;タブレットモード(手動教示)/ダイレクトモードON
        ;作業実行系、原点復帰禁止
        CASE .cmd OF
            VALUE CMD_EXE_GEN,CMD_EXE_START,CMD_EXE_RESET,CMD_EXE_L2EXE,CMD_EXE_GRAVITYADJ,CMD_EXE_VSCALIB,CMD_EXE_VCALCHK:
                ;ティーチ系以外の動作系コマンド禁止
                .flg_exec_cmd=FALSE
            VALUE CMD_EXE_TEACH,CMD_EXE_MOVE:
                ;ダイレクトモードON
                ;ティーチ系禁止
                IF (ROBOT_MODE==MODE_DIRECT) THEN
                    .flg_exec_cmd=FALSE
                END
            VALUE CMD_EXE_RESTART,CMD_SET_HOME,CMD_SET_ZEROING,CMD_SET_TOOL,CMD_SET_HANDIO,CMD_SET_LOWSPAREA,CMD_SET_LOWSPSETTING,CMD_SET_SLOWLIMIT:
                ;(非動作系)再開、ゼロイング禁止
                .flg_exec_cmd=FALSE
        END
    END
    IF (SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON) AND (ROBOT_MODE_FLG==FALSE) THEN
        ;実行中
        CASE .cmd OF
            VALUE CMD_EXE_GEN,CMD_EXE_START,CMD_EXE_RESET,CMD_EXE_L2EXE,CMD_EXE_GRAVITYADJ,CMD_EXE_VSCALIB,CMD_EXE_TEACH,CMD_EXE_MOVE,CMD_EXE_VCALCHK:
                ;動作系コマンド禁止
                .flg_exec_cmd=FALSE
            VALUE CMD_SET_HOME,CMD_SET_ZEROING,CMD_SET_TOOL,CMD_SET_HANDIO,CMD_SET_LOWSPAREA,CMD_SET_LOWSPSETTING,CMD_SET_SLOWLIMIT,CMD_SET_INTFPARAM,CMD_SET_WSPEC,CMD_SET_WNO:
                ;(非動作系)手動設定系
                .flg_exec_cmd=FALSE
            VALUE CMD_EXE_RESTART,CMD_EXE_IO,CMD_EXE_HAND,CMD_EXE_ROBOTMODE,CMD_EXE_VISION,CMD_EXE_VLESCAL:
                ;(非動作系)制御系
                .flg_exec_cmd=FALSE
            VALUE CMD_SET_L2EXETBL,CMD_SET_WSET,CMD_SET_L1INFO,CMD_SET_L2INFO,CMD_SET_L3INFO,CMD_SET_WINFO,CMD_SET_STEP,CMD_SET_STEPPOS,CMD_SET_STEPIFGOTO:
                ;(非動作系)作業設定系
                .flg_exec_cmd = FALSE
        END
    END
    IF (SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON) THEN
        ;AUTO中
        CASE .cmd OF
            VALUE CMD_SET_PITCH,CMD_SET_TOOL,CMD_SET_HOME,CMD_SET_HANDIO,CMD_SET_LOWSPAREA,CMD_SET_LOWSPSETTING,CMD_SET_ZEROING:
                ;設定2禁止
                .flg_exec_cmd=FALSE
            VALUE CMD_SET_SLOWLIMIT,CMD_SET_INTFPARAM,CMD_SET_GENPARAM,CMD_SET_WSPEC:
                ;設定2禁止
                .flg_exec_cmd=FALSE
            VALUE CMD_EXE_GRAVITYADJ,CMD_EXE_VSCALIB,CMD_EXE_VLESCAL,CMD_EXE_VCALCHK:
                ;設定3禁止
                .flg_exec_cmd=FALSE
        END
    END
    IF robot_status_out<>sta_nomove THEN
        ;停止（再開不可）中以外
        CASE .cmd OF
            VALUE CMD_SET_WNO:
                ;作業グループ番号設定禁止
                .flg_exec_cmd=FALSE
        END
    END
.END

.PROGRAM pccomcore(.flg_force,.num,.ret)
;-------------------------------- 
;機能：通信制御(動作プログラム実行用、コマンド受信後の処理)
;-------------------------------- 
    ;コマンド受信有り
    .$res=""
    ;コマンドを取得する
    FOR .i=1 TO .num
        $OPE_PARAM[.i]=$prm[TASKNO,.i]
        $prm[PG_MASTER,.i] = $prm[TASKNO,.i]
    END
    
    ;動作命令系コマンドのみ実行する
    IF .flg_force==FALSE THEN
        IF CMD_EXEC_TYPE[VAL($prm[TASKNO,0])]==CMD_TYPE_PCPG THEN
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "->pccomcore() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
            END
            GOTO 10
        END
    END
    
    ;エラー発生中はエラーリセットコマンド以外はエラー応答する
    IF (VAL($prm[TASKNO,0])<>CMD_EXE_RESET) AND (G_LAST_ERROR<>err_no_error) THEN
        .ret=G_LAST_ERROR
        CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "TASKNO=",TASKNO,",pccomcore()-> Cannot execute command=",VAL($prm[TASKNO,0]),",G_LAST_ERROR=",G_LAST_ERROR
        END
        GOTO 10
    END

    ;リセット操作を受付ける(タブレットがポート変更するまでの暫定)
    ;ﾀﾞｲﾚｸﾄ/ﾀﾌﾞﾚｯﾄﾓｰﾄﾞ中はｴﾗｰﾘｾｯﾄ受け付けない
    ;サイクル中はｴﾗｰﾘｾｯﾄ受け付けない
    IF VAL($prm[TASKNO,0])==CMD_EXE_RESET AND FLG_START_REBOOT==FALSE AND ROBOT_MODE_FLG==FALSE THEN
        IF SWITCH(CS ,1)==OFF AND SWITCH(CS ,2)==OFF THEN
            IF FLG_MASTER_MOVE==FALSE AND FLG_SLAVE_MOVE==FALSE THEN
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "->pccomcore() Start execute reset-command."
                END
                IF (G_LAST_ERROR==err_bad_position) AND (DISABLE_READJ_POS==TRUE) THEN
                    FLG_ENABLE_STOPPOS=FALSE
                END
                ;status_check()でエラーを起こさないようにする
                CALL reset_error(.ret)
            ELSE
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "->pccomcore() Can not start execute reset-command,because robot is busy."
                END
                .ret=err_robot_busy
            END
            CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
            GOTO 10
        END
    END
    
    ;コマンド実行可能条件が未成立はエラー応答する
    ;ロボット動作中にOPE_COMMANDを更新するとエラーになるため受信文字列で判定する
    CALL check_exec_cmd(VAL($prm[TASKNO,0]),.flg_exec_cmd)
    IF .flg_exec_cmd==FALSE THEN
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->pccomcore() Result of judgement by check_exec_cmd() is not authorizing."
        END
        .ret=err_robotmode
        CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
        GOTO 10
    END

    ;OPE_COMMAND更新タイミング注意
    OPE_COMMAND=VAL($prm[TASKNO,0])
    
    ;プログラム実行要否判定後に自動的にプログラムを実行する
    CALL exec_pg(.ret)
    IF .ret<>err_no_error THEN
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->pccomcore() Can not execute program(exec_pg(.ret))."
        END
        CALL sendresp(OPE_COMMAND,"",.ret)
        GOTO 10
    END

    ;動作プログラム(main関数)未実行状態中はエラー応答する
    IF FLG_MAIN_RUN==FALSE THEN
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->pccomcore() Not ready for main-program(FLG_MAIN_RUN==FALSE)."
        END
        .ret=err_main_start
        CALL sendresp(OPE_COMMAND,"",.ret)
    END

    ;コマンド実行中はエラー応答する
    IF FLG_MASTER_MOVE==TRUE THEN
        ;動作中エラー応答
        .ret=err_robot_busy
        CALL sendresp(OPE_COMMAND,"",.ret)
        GOTO 10
    END
    
    ;動作プログラム起動中はエラー応答する
    IF FLG_START_REBOOT==TRUE THEN
        IF DEBUG.PRT.COM==TRUE THEN
            PRINT "->pccomcore() REBOOTING...."
        END
        .ret = err_robot_busy
        CALL sendresp(OPE_COMMAND,"",.ret)
        GOTO 10
    END
    
    ;コマンドを実行する
    FLG_MASTER_MOVE=TRUE

    ;コマンド種別が終了確認タイプで無ければ実行完了応答する
    IF CMD_WAIT_TYPE[OPE_COMMAND]==CMD_TYPE_NO_WAIT THEN
        .ret=err_no_error
        CALL sendresp(OPE_COMMAND,"",.ret)
    END
10
.END

.PROGRAM pccom()
;-------------------------------- 
;機能：通信制御(動作プログラム実行用)
;-------------------------------- 
    IF MODE_CTYPE==MODE_TCP THEN
        ;TCPポート接続、再接続
        CALL tcp_open(0,.ret)
    END
    ;外部制御盤からの操作機能を追加するが、通信バッファ溜まり防止のため通信ループは常時回す
    CALL getcmd(.num,.ret)
    IF .ret==0 THEN
        IF SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==OFF THEN
            ;タブレット操作許可、ボタン操作禁止
            CALL pccomcore(FALSE,.num,.ret)
        ELSE
            ;ｴﾗｰﾘｾｯﾄ以外のタブレット操作禁止、ボタン操作許可
            IF (VAL($prm[TASKNO,0])==cmd_exe_reset) THEN
                CALL pccomcore(FALSE,.num,.ret)
                GOTO 10
            END
            ;操作パネルのティーチ／リピート入力が不正な場合はエラー応答
            IF (SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==ON) OR (SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==OFF) THEN
                .ret=err_extio_unknown
                CALL update_error(.ret)
            ELSE
                ;外部制御盤操作中エラー応答
                .ret=err_extio_disable
            END
            CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
        END
    ELSE
        ;タブレット操作禁止、ボタン操作許可
        ;通信処理乗っ取りコマンド実行
        CALL chk_extin(.status,.num)
        IF .status==TRUE THEN
            ;入力検知
            IF (VAL($prm[TASKNO,0])<>CMD_EXE_RESET) AND (G_LAST_ERROR<>err_no_error) THEN
                ;エラー発生中はエラーリセットしか受け付けない
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "TASKNO=",TASKNO,",pccom:extin()-> Cannot execute command=",VAL($prm[TASKNO,0]),",G_LAST_ERROR=",G_LAST_ERROR
                END
                GOTO 10
            END
            ;コマンド種類(動作、非動作)に併せた実行方法が必要
            CASE VAL($prm[TASKNO,0]) OF
                VALUE CMD_EXE_START,CMD_EXE_RESET,CMD_EXE_GEN:

                    IF (FLG_MASTER_MOVE==TRUE OR FLG_SLAVE_MOVE==TRUE) THEN
                        IF DEBUG.PRT.COM==TRUE THEN
                            PRINT "pccom()-> Can not execute command,Because still moving any robot."
                        END
                        GOTO 10
                    END
                    ;動作系コマンドのためPCCOMのように動作プログラム(main関数)経由で実行する
                    CALL pccomcore(TRUE,.num,.ret)
                VALUE CMD_EXE_RESTART:
                    ;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
                    ;コマンド実行
                    CALL cmdmain(CMD_EXE_RESTART,.$res,.ret)
                VALUE CMD_EXE_ABORT:
                    ;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
                    CALL cmdabort(.ret)
                VALUE CMD_EXE_ROBOTMODE:
                    IF (ROBOT_MODE==MODE_TABLET) AND (ROBOT_MODE_FLG<>FALSE) THEN
                        ;操作禁止
                    ELSE
                        ;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
                        CALL cmdchgrobotmode(.ret)
                    END
            ANY
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "pccom()-> Not Support command for extin_ctl()"
                END
            END
        END
    END
10
    ;再起動プログラムが停止している場合に自動再起動する
    IF (TASK(1001)<>1) THEN
        PCEX rebootsystem
        PRINT ".......Restart rebootsystem() in task 1001(PC-PROGRAM no.1)"
    END
    ;エラー発生時はログに残す
    IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
      CALL error_log(.ret)
    END
.END

.PROGRAM chk_extin(.status,.num)
;-------------------------------- 
;機能：外部制御盤入力信号状態チェック
;引数：無し
;戻値：信号状態(0:入力無し、1:入力有)、コマンド
;--------------------------------
    .status=FALSE
    FOR .i=0 TO 20
        $prm[TASKNO,.i]=""
    END
    ;操作パネルのティーチ／リピート入力が不正な場合は実行禁止
    IF ((SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==ON) OR (SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==OFF)) AND SIG(EXTIN_START_BUTTON)==ON THEN
        CALL update_error(err_extio_unknown)
        RETURN
    END
    .wait_extin_time=WAIT_EXTIN_TIME
    ;STARTを先に押した場合だけSTOPが押されてるか確認する
    ;STOPが先に押されてる場合は停止指示の可能性があるので即次の処理に移る
    IF SIG(EXTIN_START_BUTTON)==ON THEN
        UTIMER .@NowTime = 0
        DO
            IF SIG(EXTIN_START_BUTTON)==ON AND SIG(EXTIN_STOP_BUTTON)==ON THEN
                IF ROBOT_MODE==MODE_DIRECT THEN
                    ;ダイレクトモード中は実行禁止
                    RETURN
                END
                IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
                    IF FLG_EXTIN_GEN<>FALSE THEN
                        ;AUTO時緑/赤ボタン（原点復帰）の無効
                        RETURN
                    END
                    IF DEBUG.PRT.EXTIO==ON THEN
                        PRINT "chk_extin()-> START CMD_EXE_GEN"
                    END
                    $prm[TASKNO,0]=$ENCODE(CMD_EXE_GEN)
                    $prm[TASKNO,1]="0"
                    $prm[TASKNO,2]="0"
                    $prm[TASKNO,3]="1"
                    $prm[TASKNO,4]="1234"
                    .num=3
                    .status=TRUE
                    RETURN
                END
            END
        UNTIL (UTIMER(.@NowTime)>wait_extin_time)
    END
    IF (SW_EXTIN_GENA==ON AND SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON) OR (SW_EXTIN_GENM==ON AND SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==OFF) THEN
        IF SIG(SIG_EXTIN_GEN) THEN
            IF (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
                ;外部I/Oから原点復帰
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_GEN"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_GEN)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="0"
                $prm[TASKNO,3]="1"
                $prm[TASKNO,4]="1234"
                .num=3
                .status=TRUE
                RETURN
            END
        END
    END
    IF SIG(EXTIN_START_BUTTON)==ON THEN
        IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
            IF ROBOT_MODE==MODE_DIRECT THEN
                ;ダイレクトモード中は実行禁止
                RETURN
            END
            CALL chk_exe_staus(.exe_status)
            IF .exe_status<>err_no_error THEN
                IF FLG_EXTIN_RESTART<>FALSE THEN
                    ;AUTO時緑ボタン（再開）の無効
                    RETURN
                END
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_RESTART"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_RESTART)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1234"
                .num=2
            ELSE
                IF FLG_EXTIN_START<>FALSE THEN
                    ;AUTO時緑ボタン（実行）の無効
                    RETURN
                END
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_START"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_START)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1"
                $prm[TASKNO,3]="1234"
                .num=3
            END
        ELSE
            IF FLG_EXTIN_ROBOTMODE<>FALSE THEN
                ;MANUAL時緑ボタン（ﾀﾞｲﾚｸﾄﾃｨｰﾁ）の無効
                RETURN
            END
            IF (SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON) THEN
                RETURN
            END
            ;ロボットモード=ダイレクトティーチ、フラグ=ONに変更
            IF DEBUG.PRT.EXTIO==ON THEN
                PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->ON"
            END
            ;ダイレクトティーチゲインデフォルト設定
            mode_sa = 0
            sa_tool[1] = 1
            sa_tool[2] = 1
            FOR .i=1 TO 2
                FOR .j=1 TO 4
                    sa_param[.i,.j] = 1
                END
            END
            $sa_param = "0,1,1,1,1,1,1,1,1"
            flg_sa_change = 3
;
            $prm[TASKNO,0]=$ENCODE(CMD_EXE_ROBOTMODE)
            $prm[TASKNO,1]="0"
            $prm[TASKNO,2]="1"
            $prm[TASKNO,3]="1"
            $prm[TASKNO,4]="1234"
            .num=4
        END
        .status=TRUE
        RETURN
    END
    IF SW_EXTIN_START==ON AND SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
        ;外部I/Oから実行
        IF SIG(SIG_EXTIN_START) THEN
            IF robot_status_out==sta_nomove AND (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_START"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_START)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1"
                $prm[TASKNO,3]="1234"
                .num=3
                .status=TRUE
                RETURN
            END
        END
    END
    IF SW_EXTIN_RESTART==ON AND SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
        ;外部I/Oから再開
        IF SIG(SIG_EXTIN_RESTART) THEN
            IF robot_status_out==sta_hold AND (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_RESTART"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_RESTART)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1234"
                .num=2
                .status=TRUE
                RETURN
            END
        END
    END
    IF SW_EXTIN_ROBOTMODE==ON AND SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==OFF THEN
        ;外部I/Oからダイレクトティーチ
        IF SIG(SIG_EXTIN_ROBOTMODE) THEN
            IF (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
                ;ロボットモード=ダイレクトティーチ、フラグ=ONに変更
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->ON"
                END
                ;ダイレクトティーチゲインデフォルト設定
                mode_sa = 0
                sa_tool[1] = 1
                sa_tool[2] = 1
                FOR .i=1 TO 2
                    FOR .j=1 TO 4
                        sa_param[.i,.j] = 1
                    END
                END
                $sa_param = "0,1,1,1,1,1,1,1,1"
                flg_sa_change = 3
;
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_ROBOTMODE)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1"
                $prm[TASKNO,3]="1"
                $prm[TASKNO,4]="1234"
                .num=4
                .status=TRUE
                RETURN
            END
        END
    END
    IF SIG(EXTIN_STOP_BUTTON)==ON THEN
        IF G_LAST_ERROR<>err_no_error THEN
            IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
                IF FLG_EXTIN_ARESET<>FALSE THEN
                    ;AUTO時赤ボタン（エラーリセット）の無効
                    RETURN
                END
            ELSE
                IF FLG_EXTIN_MRESET<>FALSE THEN
                    ;MANUAL時赤ボタン（エラーリセット）の無効
                    RETURN
                END
            END
            IF DEBUG.PRT.EXTIO==ON THEN
                PRINT "chk_extin()-> START CMD_EXE_RESET"
            END
            $prm[TASKNO,0]=$ENCODE(CMD_EXE_RESET)
            $prm[TASKNO,1]="0"
            $prm[TASKNO,2]="1234"
            .num=2
            .status=TRUE
            RETURN
        ELSE
            IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
                IF FLG_EXTIN_AABORT<>FALSE THEN
                    ;AUTO時赤ボタン（停止）の無効
                    RETURN
                END
            ELSE
                IF FLG_EXTIN_MABORT<>FALSE THEN
                    ;MANUAL時赤ボタン（停止）の無効
                    RETURN
                END
            END
            IF DEBUG.PRT.EXTIO==ON THEN
                PRINT "chk_extin()-> START CMD_EXE_ABORT"
            END
            $prm[TASKNO,0]=$ENCODE(CMD_EXE_ABORT)
            $prm[TASKNO,1]="0"
            $prm[TASKNO,2]="1234"
            .num=2
            .status=TRUE
            RETURN
        END
    END
    IF SW_EXTIN_RESET==ON THEN
        IF SIG(SIG_EXTIN_RESET) THEN
            ;外部I/Oからエラーリセット
            IF G_LAST_ERROR<>err_no_error THEN
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_RESET"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_RESET)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1234"
                .num=2
                .status=TRUE
                RETURN
            END
        END
    END
    IF SW_EXTIN_ABORT==ON THEN
        IF SIG(SIG_EXTIN_ABORT) THEN
            ;外部I/Oから停止
            IF G_LAST_ERROR==err_no_error THEN
                IF DEBUG.PRT.EXTIO==ON THEN
                    PRINT "chk_extin()-> START CMD_EXE_ABORT"
                END
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_ABORT)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1234"
                .num=2
                .status=TRUE
                RETURN
            END
        END
    END
.END

.PROGRAM pccompc()
;-------------------------------- 
;機能：通信制御(非動作プログラム実行用)
;-------------------------------- 
    IF MODE_CTYPE==MODE_TCP THEN
        ;TCPポート接続、再接続
        CALL tcp_open(0,.ret)
    END
    CALL getcmd(.num,.ret)
    IF .ret==0 THEN
        IF (FLG_TAB_ABORT<>FALSE) AND (VAL($prm[TASKNO,0])==CMD_EXE_ABORT) THEN
            ;AUTO時タブレットから停止無効
            IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
                .ret = err_robotmode
                CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
                GOTO 10
            END
        END
        ;コマンド受信有り
        .$res=""
        ;コマンドを取得する
;        FOR .i=1 TO .num
;            $OPE_PARAMPC[.i]=$prm[TASKNO,.i]
;        END

        ;操作パネルのティーチ／リピート入力が不正な場合はエラー応答
        IF (SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==ON) OR (SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==OFF) THEN
            CASE VAL($prm[TASKNO,0]) OF
                VALUE CMD_EXE_GEN,CMD_EXE_START,CMD_EXE_L2EXE,CMD_EXE_GRAVITYADJ,CMD_EXE_VSCALIB,CMD_EXE_TEACH,CMD_EXE_MOVE,CMD_EXE_RESTART,CMD_EXE_ROBOTMODE:
                    .ret=err_extio_unknown
                    CALL update_error(.ret)
                    CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
                    GOTO 10
            END
        END
        
        CALL check_exec_cmd(VAL($prm[TASKNO,0]),.flg_exec_cmd)
        IF .flg_exec_cmd==FALSE THEN
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "->pccompc() Result of judgement by check_exec_cmd() is not authorizing."
            END
            .ret=err_robotmode
            CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
            GOTO 10
        END
        
        IF (SIG(EXTIN_TEACH_TGLSW)==OFF) AND (SIG(EXTIN_REPEAT_TGLSW)==ON) AND ((VAL($prm[TASKNO,0])==CMD_EXE_RESTART) OR (VAL($prm[TASKNO,0])==CMD_EXE_ROBOTMODE)) THEN
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "pccompc()-> (SIG(EXTIN_TEACH_TGLSW)==OFF) AND (SIG(EXTIN_REPEAT_TGLSW)==ON) AND ((VAL($prm[TASKNO,0])==CMD_EXE_RESTART) OR (VAL($prm[TASKNO,0])==CMD_EXE_ROBOTMODE))"
            END
            .ret=err_robotmode
            CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
            GOTO 10
        END
        
        OPE_COMMANDPC=VAL($prm[TASKNO,0])

        ;非動作命令系のみ実行する
        IF CMD_EXEC_TYPE[OPE_COMMANDPC]==CMD_TYPE_MONPG THEN
            IF DEBUG.PRT.COM==TRUE THEN
                PRINT "->pccompc() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
            END
            GOTO 10
        END

        ;プログラムを実行要否判定後に自動的にプログラムを実行する
        IF (OPE_COMMANDPC==CMD_EXE_RESTART) OR (OPE_COMMANDPC==CMD_EXE_ROBOTMODE) THEN
            IF G_LAST_ERROR<>err_no_error THEN
                .ret=G_LAST_ERROR
                CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
                IF DEBUG.PRT.COM==TRUE THEN
                    PRINT "TASKNO=",TASKNO,",pccompc()-> Cannot execute command=",OPE_COMMANDPC,",G_LAST_ERROR=",G_LAST_ERROR
                END
                GOTO 10
            ELSE
                IF OPE_COMMANDPC==CMD_EXE_RESTART THEN
                    IF .ret<>err_no_error THEN
                        CALL sendresp(OPE_COMMANDPC,"",.ret)
                        GOTO 10
                    END
                END
            END
        END
        
        ;コマンド実行
        CALL cmdmain(OPE_COMMANDPC,.$res,.ret)
        CALL sendresp(OPE_COMMANDPC,.$res,.ret)

    END
10
    ;エラー発生時はログに残す
    IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
      CALL error_log(.ret)
    END
.END

.PROGRAM getcmd(.num,.ret)
;-------------------------------- 
;機能：コマンドデータ取得(動作プログラム実行用)
;引数：なし
;戻値：実数データ配列(最大20個)、実数データ数、文字列データ配列、文字列データ数、成否
;-------------------------------- 
    .ret = err_no_error
    CALL recv(.$str,.ret)
    IF .ret==0 THEN
        .num=0
        FOR .i=0 TO 20
            $prm[TASKNO,.i] = ""
        END
        ;文字列取込み
        CALL csv_to_str( .$str, .num, .ret )
        IF .num >= 20 THEN
            ;バッファ掃除のために無視する
            .ret=err_cmd_prmnum
            RETURN
        END
    END
.END

.PROGRAM sendresp(.cmd,.$res,.ret)
;-------------------------------- 
;機能：コマンド応答
;引数：成否
;戻値：なし
;-------------------------------- 
    ;エラー発生時はログに残す
    IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
      CALL error_log(.ret)
    END
    IF .$res<>"" THEN
        IF .$res=="***" THEN
            .$res = ""
        END
        .$str=$ENCODE(.cmd)+","+$ENCODE(.ret)+","+.$res+",1234"
    ELSE
        .$str=$ENCODE(.cmd)+","+$ENCODE(.ret)+",1234"
    END
    CALL send(.$str,.ret)
.END
.PROGRAM check_home(.rno,.ret)
;-------------------------------- 
;機能：現在位置とホーム位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
    .ret = err_bad_position
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "check_home()-> .rno=",.rno
    END
    .homeno=1
    POINT .rno: .#home=#HOME(.homeno)
    IF .rno==ROBOT_MASTER THEN
        POINT .#pos=#S_HERE(1)
    ELSE
        POINT .#pos=#S_HERE(2)
    END
    DECOMPOSE .buf1[1]=.#home
    DECOMPOSE .buf2[1]=.#pos
    FOR .i=1 TO 6
        IF (.buf1[.i]-POSLIMIT_GEN<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+POSLIMIT_GEN) THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_pos()-> JTNUM=",.i,"....OK",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-POSLIMIT_GEN,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+POSLIMIT_GEN
            END
            IF .i==6 THEN
                .ret=err_no_error
                ;ホーム1、ホーム2のどちらかにいればOKとする
                RETURN
            END
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_pos()-> JTNUM=",.i,"....NG",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-POSLIMIT_GEN,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+POSLIMIT_GEN
            END
            GOTO 100
        END
    END
100
    .homeno=2
    POINT .rno: .#home=#HOME(.homeno)
    IF .rno==ROBOT_MASTER THEN
        POINT .#pos=#S_HERE(1)
    ELSE
        POINT .#pos=#S_HERE(2)
    END
    DECOMPOSE .buf1[1]=.#home
    DECOMPOSE .buf2[1]=.#pos
    FOR .i=1 TO 6
        IF (.buf1[.i]-POSLIMIT_GEN<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+POSLIMIT_GEN) THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_pos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-POSLIMIT_GEN,"<",.buf2[.i],"<",.buf1[.i]+POSLIMIT_GEN
            END
            IF .i==6 THEN
                .ret=err_no_error
                ;ホーム1、ホーム2のどちらかにいればOKとする
                RETURN
            END
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_pos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-POSLIMIT_GEN,"<",.buf2[.i],"<",.buf1[.i]+POSLIMIT_GEN
            END
            RETURN
        END
    END
.END

.PROGRAM check_holdpos(.rno,.ret)
;-------------------------------- 
;機能：現在位置と記録位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "check_home()-> .rno=",.rno
    END
    IF .rno==ROBOT_MASTER THEN
        POINT .#pos=#S_HERE(1)
        DECOMPOSE .buf1[1]=#REC_HOLDPOS[1]
    ELSE
        POINT .#pos=#S_HERE(2)
        DECOMPOSE .buf1[1]=#REC_HOLDPOS[2]
    END
    DECOMPOSE .buf2[1]=.#pos
    FOR .i=1 TO 6
        IF (.buf1[.i]-POSLIMIT_RESTART<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+POSLIMIT_RESTART) THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_holdpos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-POSLIMIT_RESTART,"<",.buf2[.i],"<",.buf1[.i]+POSLIMIT_RESTART
            END
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "check_holdpos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-POSLIMIT_RESTART,"<",.buf2[.i],"<",.buf1[.i]+POSLIMIT_RESTART
            END
            .ret = err_bad_position
            RETURN
        END
    END
.END
    
.PROGRAM check_pos(.rno,.cmd,.ret)
;-------------------------------- 
;機能：位置チェック
;引数：ロボット番号、コマンド
;戻値：成否
;-------------------------------- 
    .ret = err_bad_position
    CASE .cmd OF
        VALUE CMD_EXE_START,CMD_EXE_GRAVITYADJ:
            ;原点位置からの開始のみ許容する
            CASE .rno OF
                VALUE ROBOT_ALL:
                    CALL check_home(ROBOT_MASTER,.ret)
                    IF .ret<>err_no_error THEN
                        RETURN
                    END
                    CALL check_home(ROBOT_SLAVE,.ret)
                    IF .ret<>err_no_error THEN
                        RETURN
                    END
                VALUE ROBOT_MASTER:
                    CALL check_home(ROBOT_MASTER,.ret)
                VALUE ROBOT_SLAVE:
                    CALL check_home(ROBOT_SLAVE,.ret)
            END
        VALUE CMD_EXE_RESTART:
            ;停止位置記憶有効フラグ
            IF FLG_ENABLE_STOPPOS==TRUE THEN
                ;ホールド停止した時の位置からの開始のみ許容する
                CASE .rno OF
                    VALUE ROBOT_ALL:
                        CALL check_holdpos(ROBOT_MASTER,.ret)
                        IF .ret<>err_no_error THEN
                            RETURN
                        END
                        CALL check_holdpos(ROBOT_SLAVE,.ret)
                        IF .ret<>err_no_error THEN
                            RETURN
                        END
                    VALUE ROBOT_MASTER:
                        CALL check_holdpos(ROBOT_MASTER,.ret)
                    VALUE ROBOT_SLAVE:
                        CALL check_holdpos(ROBOT_SLAVE,.ret)
                END
            END
    END
    CALL update_error(.ret)
.END

.PROGRAM gen(.ret)
;-------------------------------- 
;機能：ホーム移動
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "->cmdgen() .rno=",$prm[TASKNO,1]
    END
    ;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    IF SYSDATA(ZSIMENV)<>2 THEN
        INTFCHK ON
    ELSE
        IF KROSET==TRUE THEN
            INTFCHK ON
        END
    END
    CASE VAL($prm[TASKNO,1]) OF
        VALUE ROBOT_ALL:
            FLG_SLAVE_MOVE = TRUE
            IF DEBUG.PRT.MAIN==ON THEN
                PRINT "TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
            END
            ;原点番号設定
            .home_no=VAL($prm[TASKNO,3])
            ;ロボット番号設定
            IF ZSW_MODE_HOME==ON THEN
                .rno=robot_all
            ELSE
                .rno=ROBOT_MASTER
            END
            ;仕様変更、速度指定無効化、常時固定値
            .sp=SAFTY_MOVE_SP
            CALL gen_core(.rno,.home_no,.sp,.ret)
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
            END
            WHILE(1)
                IF FLG_SLAVE_MOVE==FALSE THEN
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
                    END
                    RETURN
                ELSE
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
                    END
                END
            END
        VALUE ROBOT_MASTER:
            ;原点番号設定
            .home_no=VAL($prm[TASKNO,3])
            ;ロボット番号設定
            .rno=ROBOT_MASTER
            ;仕様変更、速度指定無効化、常時固定値
            .sp=SAFTY_MOVE_SP
            CALL gen_core(.rno,.home_no,.sp,.ret)
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
            END
        VALUE ROBOT_SLAVE:
            FLG_SLAVE_MOVE = TRUE
            WHILE(1)
                IF FLG_SLAVE_MOVE==FALSE THEN
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
                    END
                    RETURN
                ELSE
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
                    END
                END
            END
    END
    BREAK
.END

.PROGRAM monsp(.ret)
;-------------------------------- 
;機能：モニタ速度変更
;引数：速度
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .sp=VAL($prm[TASKNO,2])
    IF .sp<=0 OR .sp>100 THEN
        PRINT "TASKNO=",TASKNO,", err_bad_speed"
        .ret=err_bad_speed
        RETURN
    END
    DATA_MONSPEED[VAL($prm[TASKNO,1])]=.sp
    IF VAL($prm[TASKNO,1])==ROBOT_ALL THEN
        IF DEBUG.PRT.CMD==TRUE THEN
            PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,ROBOT_MASTER)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
            PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,ROBOT_SLAVE)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
        END
        MC SPEED ROBOT_MASTER: .sp
        MC SPEED ROBOT_SLAVE: .sp
        CALL wait_chg_sp(ROBOT_MASTER,.sp,.ret)
        CALL wait_chg_sp(ROBOT_SLAVE,.sp,.ret)
    ELSE
        IF DEBUG.PRT.CMD==TRUE THEN
            IF $prm[TASKNO,1]=="1" THEN
                PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,ROBOT_MASTER)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
            ELSE
                PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,ROBOT_SLAVE)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
            END
        END
        MC SPEED VAL($prm[TASKNO,1]): .sp
        IF $prm[TASKNO,1]=="1" THEN
            CALL wait_chg_sp(ROBOT_MASTER,.sp,.ret)
        ELSE
            CALL wait_chg_sp(ROBOT_SLAVE,.sp,.ret)
        END
    END
.END

.PROGRAM wait_chg_sp(.rno,.sp,.ret)
;-------------------------------- 
;機能：速度変更確認
;引数：ロボット番号、動作速度(.sp)
;戻値：成否(±1%以内で成功)
;-------------------------------- 
    .ret = err_no_error
    UTIMER .@NowTime = 0
    WHILE(1)
        IF .rno==ROBOT_SLAVE THEN
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED2),"---->TARGET_SP=",$ENCODE(.sp)
            END
            IF MSPEED2>.sp-1 AND MSPEED2 < .sp+1 THEN
                RETURN
            END
        ELSE
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED),"---->TARGET_SP=",$ENCODE(.sp)
            END
            IF MSPEED>.sp-1 AND MSPEED < .sp+1 THEN
                RETURN
            END
        END
        IF UTIMER(.@NowTime)>0.1 THEN
            .ret = err_chg_sp
            RETURN
        END
    END
.END

.PROGRAM get_iotype(.signo,.sigtype,.ret)
;-------------------------------- 
;機能：IO種類取得(信号設定範囲外の場合はエラー)
;引数：信号番号
;戻値：IO種類、成否
;-------------------------------- 
    .ret = err_no_error
    .sigtype = IO_UNKNOWN
    .fb_io = ZOPTION(13,2);汎用フィールドバスI/O設定
    IF (0<.signo) AND (.signo<1000) THEN
        IF .fb_io<>OFF THEN;汎用FB設定ON
          .out_sig_num = SYSDATA(ZSIGSPEC.DO)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
        ELSE;汎用FB設定OFF
          .out_sig_num = SYSDATA(ZSIGSPEC.DO)
        END
        IF .signo<=.out_sig_num THEN
            .sigtype=IO_DO
            RETURN
        END
    END
    IF (1000<.signo) AND (.signo<2000) THEN
        IF .fb_io<>OFF THEN;汎用FB設定ON
          .in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
        ELSE;汎用FB設定OFF
          .in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)
        END
        IF .signo<=.in_sig_num THEN
            .sigtype=IO_DI
            RETURN
        END
    END
    IF (2000<.signo) AND (.signo<3000) THEN
        IF .signo<=(2000+SYSDATA(ZSIGSPEC.INT)) THEN
            .sigtype=IO_INT
            RETURN
        END
    END
    .ret = err_bad_signo
    IF DEBUG.PRT.CMD==TRUE THEN
        IF .fb_io<>OFF THEN;汎用FB設定ON
            PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT),SYSDATA(ZSIGSPEC.MAS),SYSDATA(ZSIGSPEC.SLA)
        ELSE;汎用FB設定OFF
            PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT)
        END
    END
.END

.PROGRAM iochange(.signo,.status,.keeptime,.ret)
;-------------------------------- 
;機能：IO変更実行
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;説明；信号変更前の状態を保持して状態保持時間経過後にIO変更前の状態に戻す
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", Keed Signal Time=",.keeptime
    END
    IF .signo<=0 THEN
        ;信号状態は.statusに分離管理しているので.signo負値は存在しない
        ;操作を無視したいときに上位が意図的に0を設定する可能性があるため許容する
        RETURN
    END
    CALL get_iotype(.signo,.sigtype,.ret)
    IF .ret<>err_no_error then
        RETURN
    END
    IF FLG_PULSE_IO<>FALSE THEN
        IF .signo<=64 THEN
            IF .keeptime>0 AND .status<>FALSE THEN
                PULSE .signo,(.keeptime/1000)
                RETURN
            END
        END
    END
    IF .sigtype==IO_DI THEN
        ;入力信号は変更出来ないのでエラーにする
        .ret = err_bad_signo
        RETURN
    END
    .pre_io_status=SIG(.signo)
    IF .status <> FALSE THEN
        SIG .signo
    ELSE
        SIG -.signo
    END
    IF DEBUG.PRT.ITEM==TRUE THEN
        PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", SIG", .signo, "=", SIG(.signo), ", Keep Signal Time=",.keeptime, ", Time= ", $TIME
    END
    IF .keeptime>0 THEN
        TWAIT .keeptime/1000
        IF .pre_io_status <> FALSE THEN
            SIG .signo
        ELSE
            SIG -.signo
        END
    END
.END

.PROGRAM hand(.rno,.status,.ret)
;-------------------------------- 
;機能：ハンド操作
;引数：ロボット番号、ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.CMD==TRUE THEN
        PRINT "TASKNO=",TASKNO,",.rno=",.rno,",HAND STATUS=",.status
    END
    CASE .rno OF
        VALUE ROBOT_ALL:
            CALL handiochk(ROBOT_MASTER,.ret)
            IF .ret<>err_no_error THEN
                RETURN
            END
            CALL handiochk(ROBOT_SLAVE,.ret)
            IF .ret<>err_no_error THEN
                RETURN
            END
            DATA_HAND_CUR[ROBOT_MASTER]=.status
            DATA_HAND_CUR[ROBOT_SLAVE]=.status
            CALL handmove(ROBOT_MASTER,.status,.ret)
            CALL handmove(ROBOT_SLAVE,.status,.ret)
        VALUE ROBOT_MASTER,ROBOT_SLAVE:
            CALL handiochk(.rno,.ret)
            IF .ret<>err_no_error THEN
                RETURN
            END
            DATA_HAND_CUR[.rno]=.status
            CALL handmove(.rno,.status,.ret)
        ANY
            .ret=err_bad_rno
            PRINT "TASKNO=",TASKNO,",err_bad_rno"
            RETURN
    END
    
.END

.PROGRAM handiochk(.rno,.ret)
;-------------------------------- 
;機能：ハンド制御信号設定状態チェック
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DATA_HAND_TYPE[.rno]==HAND_SINGLE THEN
        IF (DATA_HAND_IO[.rno,1]==0) THEN
            .ret=err_bad_handio
            PRINT "chkhandio()->err_bad_handio"
            PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",DATA_HAND_TYPE[.rno],"(HAND_SINGLE),io1=",DATA_HAND_IO[.rno,1],",io2=",DATA_HAND_IO[.rno,2]
            RETURN
        END
    END
    IF DATA_HAND_TYPE[.rno]==HAND_DOUBLE THEN
        IF (DATA_HAND_IO[.rno,1]==0) OR (DATA_HAND_IO[.rno,2]==0) THEN
            .ret=err_bad_handio
            PRINT "chkhandio()->err_bad_handio"
            PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",DATA_HAND_TYPE[.rno],"(HAND_DOUBLE),io1=",DATA_HAND_IO[.rno,1],",io2=",DATA_HAND_IO[.rno,2],",io3=",DATA_HAND_IO[.rno,3],",io4=",DATA_HAND_IO[.rno,4]
            RETURN
        END
    END
.END

.PROGRAM handmove(.rno,.status,.ret)
;-------------------------------- 
;機能：ハンド制御信号変更
;引数：ロボット番号、ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL get_iotype(DATA_HAND_IO[.rno,1],.sigtype,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    IF .sigtype<>IO_DO THEN
        .ret = err_bad_signo
        RETURN
    END
    IF DATA_HAND_TYPE[.rno]==HAND_SINGLE THEN
        IF .status==HAND_CLOSE THEN
            SIG DATA_HAND_IO[.rno,1]
        END
        IF .status==HAND_OPEN THEN
            SIG -DATA_HAND_IO[.rno,1]
        END
    END
    IF DATA_HAND_TYPE[.rno]==HAND_DOUBLE THEN
        CALL get_iotype(DATA_HAND_IO[.rno,2],.sigtype,.ret)
        IF .ret<>err_no_error THEN
            RETURN
        END
        IF .sigtype<>IO_DO THEN
            .ret = err_bad_signo
            RETURN
        END
        IF .status==HAND_CLOSE THEN
            SIG DATA_HAND_IO[.rno,1],-DATA_HAND_IO[.rno,2]
        END
        IF .status==HAND_OPEN THEN
            SIG -DATA_HAND_IO[.rno,1],DATA_HAND_IO[.rno,2]
        END
    END
    IF DEBUG.PRT.ITEM==TRUE THEN
        IF .rno == 1 THEN
            PRINT "TASKNO=",TASKNO, ", hand()->HAND STATUS=",.status, ", 49=", SIG(49), ", 50=", SIG(50), ", Time= ", $TIME
        END
        IF .rno == 2 THEN
            PRINT "TASKNO=",TASKNO, " ,hand()->HAND STATUS=",.status, ", 65=", SIG(65), ", 66=", SIG(66), ", Time= ", $TIME
        END
    END
.END

.PROGRAM gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
;-------------------------------- 
;重力補償自動調整呼出
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    FLG_SLAVE_GRAVERR = FALSE
    CASE .rno OF
        VALUE ROBOT_ALL:
            GS_GRAVITY_MODE=.mode
            GS_GRAVITY_SETVAL=.slave_setval
            FLG_SLAVE_MOVE = TRUE
            IF DEBUG.PRT.MAIN==ON THEN
                PRINT "->gravityadj() TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
            END
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->gravityadj() MASTER robot started gravityadj_core()."
            END
            CALL gravityadj_core(ROBOT_MASTER,.mode,.master_setval,.ret)
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->gravityadj() MASTER robot done gravityadj_core()."
            END
            WHILE(1)
                IF FLG_SLAVE_MOVE==FALSE THEN
                    IF FLG_SLAVE_GRAVERR==TRUE THEN
                        .ret = err_gravityadj
                        FLG_SLAVE_GRAVERR = FALSE
                    END
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->gravityadj() Slave robot done gravityadj_core()."
                    END
                    RETURN
                ELSE
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
                    END
                END
            END
        VALUE ROBOT_MASTER:
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->gravityadj() MASTER robot started gravityadj_core()."
            END
            CALL gravityadj_core(ROBOT_MASTER,.mode,.master_setval,.ret)
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->gravityadj() MASTER robot done gravityadj_core()."
            END
        VALUE ROBOT_SLAVE:
            GS_GRAVITY_MODE=.mode
            GS_GRAVITY_SETVAL=.slave_setval
            FLG_SLAVE_MOVE = TRUE
            WHILE(1)
                IF FLG_SLAVE_MOVE==FALSE THEN
                    IF FLG_SLAVE_GRAVERR==TRUE THEN
                        .ret = err_gravityadj
                        FLG_SLAVE_GRAVERR = FALSE
                    END
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->gravityadj() Slave robot done gravityadj_core()."
                    END
                    RETURN
                ELSE
                    IF DEBUG.PRT.CMD==TRUE THEN
                        PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
                    END
                END
            END
    END
    BREAK
.END
.PROGRAM chg_colcalflg(.flg)
;-------------------------------- 
;衝突検知感度自動調整設定変更
;引数：ON/OFF(OFF=0.ON=0以外、通信の場合ON=1、ASのON/TRUE=-1）
;戻値：無し（ASシステムから状態取得できない）
;--------------------------------
    IF .flg==OFF THEN
        ;衝突検知感度自動調整設定OFF
        FLG_ENABLE_COLCHKMOVE=FALSE 
        COLCALOFF 1:
        COLCALOFF 2:
    ELSE
        ;衝突検知感度自動調整設定ON
        FLG_ENABLE_COLCHKMOVE=TRUE 
        COLCALON 1:
        COLCALON 2:
    END
.END
.PROGRAM rpy2oat(.#xyzrpy,.#xyzoat)
;-------------------------------- 
;機能：座標変換(RPY->OAT)
;引数：RPY
;戻値：OAT
;-------------------------------- 

    ;外部軸
    ;.xyzoat[7]=.xyzrpy[7]
    DECOMPOSE .xyzrpy[1]=.#xyzrpy

    ;XYZRPY
    .sx = sin(.xyzrpy[4])
    .sy = sin(.xyzrpy[5])
    .sz = sin(.xyzrpy[6])
    .cx = cos(.xyzrpy[4])
    .cy = cos(.xyzrpy[5])
    .cz = cos(.xyzrpy[6])

    .mat[0,0] = .cy * .cz
    .mat[0,1] = -.cy * .sz
    .mat[0,2] = .sy
    .mat[0,3] = .xyzrpy[1]

    .mat[1,0] = .sx * .sy * .cz + .cx * .sz
    .mat[1,1] = -.sx * .sy * .sz + .cx * .cz
    .mat[1,2] = -.sx * .cy
    .mat[1,3] = .xyzrpy[2]

    .mat[2,0] = -.cx * .sy * .cz + .sx * .sz
    .mat[2,1] = .cx * .sy * .sz + .sx * .cz
    .mat[2,2] = .cx * .cy
    .mat[2,3] = .xyzrpy[3]

    .mat[3,0] = 0.0
    .mat[3,1] = 0.0
    .mat[3,2] = 0.0
    .mat[3,3] = 0.0

    ;XYZOAT
    .p = sqrt(.mat[0,2] * .mat[0,2] + .mat[1,2] * .mat[1,2])

    .xyzoat[1] = .mat[0,3]
    .xyzoat[2] = .mat[1,3]
    .xyzoat[3] = .mat[2,3]
    .xyzoat[5] = atan2(-.mat[2,2], .p)

    IF ABS(.p) > 0.000001 THEN
        .xyzoat[4] = atan2(.mat[0,2], -.mat[1,2])
        .xyzoat[6] = atan2(.mat[2,1], -.mat[2,0])
    ELSE
        .xyzoat[4] = atan2(.mat[1,1], .mat[0,1])
        .xyzoat[6] = 0.0
    END
    .xyzoat[4] = .xyzoat[4] - 90.0
    .xyzoat[5] = .xyzoat[5] + 90.0

    FOR .i = 1 TO 3
        IF .xyzoat[.i + 3] > 180.0 THEN
            .xyzoat[.i + 3] = .xyzoat[.i + 3] - 360.0
        END
        IF .xyzoat[.i + 3] < -180.0 THEN
            .xyzoat[.i + 3] = .xyzoat[.i + 3] + 360.0
        END
    END
    POINT .#xyzoat = #PPOINT(.xyzoat[1],.xyzoat[2],xyzoat[3],.xyzoat[4],.xyzoat[5],.xyzoat[6])
.END

.PROGRAM oat2rpy(.#xyzoat,.#xyzrpy)
;-------------------------------- 
;機能：座標変換(OAT->RPY)
;引数：OAT
;戻値：RPY
;-------------------------------- 
    
    ;外部軸
    ;.xyzrpy[7]=.xyzoat[7]
    DECOMPOSE .xyzoat[1]=.#xyzoat
    
    ;XYZOAT
    .so = sin(.xyzoat[4] + 90.0)
    .co = cos(.xyzoat[4] + 90.0)
    .sa = sin(.xyzoat[5] - 90.0)
    .ca = cos(.xyzoat[5] - 90.0)
    .st = sin(.xyzoat[6])
    .ct = cos(.xyzoat[6])

    .mat[0,0] = .co * .st - .sa * .ct * .so
    .mat[1,0] = .so * .st + .sa * .ct * .co
    .mat[2,0] = -.ca * .ct
    .mat[3,0] = 0.0
    .mat[0,1] = .co * .ct + .sa * .st * .so
    .mat[1,1] = .so * .ct - .sa * .st * .co
    .mat[2,1] = .ca * .st
    .mat[3,1] = 0.0
    .mat[0,2] = .ca * .so
    .mat[1,2] = -.ca * .co
    .mat[2,2] = -.sa
    .mat[3,2] = 0.0
    .mat[0,3] = .xyzoat[1]
    .mat[1,3] = .xyzoat[2]
    .mat[2,3] = .xyzoat[3]
    .mat[3,3] = 1.0

    ;XYZRPY
    .xyzrpy[1] = .mat[0,3]
    .xyzrpy[2] = .mat[1,3]
    .xyzrpy[3] = .mat[2,3]

    IF ABS(.mat[0,2]) < 0.000001 THEN
        .xyzrpy[5] = 0.0
        .xyzrpy[4] = atan2(-.mat[1,2], .mat[2,2])
        .xyzrpy[6] = atan2(-.mat[0,1], .mat[0,0])
        IF ABS(.xyzrpy[6]) < 0.000001 THEN
        
            .xyzrpy[6] = 0.0
        END
    ELSE
        .p = sqrt(.mat[0,0] * .mat[0,0] + .mat[0,1] * .mat[0,1])
        IF ABS(.p) < 0.000001 THEN
            IF (.mat[0,2] > 0.0) THEN
                .xyzrpy[5] = 90.0
            ELSE
                .xyzrpy[5] = -90.0
            END
            .xyzrpy[4] = 0.0
            .xyzrpy[6] = atan2(.mat[1,0], .mat[1,1])
        ELSE
            .xyzrpy[4] = atan2(-.mat[1,2], .mat[2,2])
            .xyzrpy[5] = atan2(.mat[0,2], .p)
            .xyzrpy[6] = atan2(-.mat[0,1], .mat[0,0])
        END
    END
    POINT .#xyzrpy = #PPOINT(.xyzrpy[1],.xyzrpy[2],xyzrpy[3],.xyzrpy[4],.xyzrpy[5],.xyzrpy[6])
.END

.PROGRAM csv_to_real( .$str, .prm[], .num, .ret )
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
    .ret = err_no_error
    .num = 0
    DO
        .$temp=$DECODE( .$str, ",", 0 )
        .prm[.num] = VAL( .$temp )
        IF .$str == "" THEN
            GOTO 100
        END
        .$temp = $DECODE( .$str, "," , 1 )
        .num = .num + 1
    UNTIL .$str == ""
100
    IF .num == 0 THEN
        .ret = err_cant_convert
    END
.END

.PROGRAM csv_to_str( .$str, .num, .ret )
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)(動作プログラム実行用)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
    .ret = err_no_error
    .num = 0
    DO
        .$temp=$DECODE( .$str, ",", 0 )
        $prm[TASKNO,.num] = .$temp
        IF .$str == "" THEN
            GOTO 100
        END
        .$temp = $DECODE( .$str, "," , 1 )
        .num = .num + 1
        .length = LEN(.$temp)
        IF .length>1 THEN
            FOR .i=1 TO .length-1
                $prm[TASKNO,.num] = ""
                .num = .num + 1
            END
        END
    UNTIL .$str == ""
100
    IF .num == 0 THEN
        .ret = err_cant_convert
    END
.END

.PROGRAM killpg
;---------------------------------
;機能：プログラムロード準備
;    ；全TASK停止、PCプログラム7番で実行専用
;---------------------------------
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " "
    PRINT " This program have to execute in PC-PROGRAM No.7."
    PRINT " "
    IF TASKNO<>1007 THEN
        PRINT " "
        PRINT " *****************************************"
        PRINT "  Aborted execute killpg()."
        PRINT "  Please execute in PC-PROGRAM No.7."
        PRINT "  You doing execute in TASKNO=",TASKNO
        PRINT " *****************************************"
        PRINT " "
        RETURN
    END
    PRINT " Starting.... killpg()"
    FLG_START_KILLPG = TRUE
    PCABORT 6:
    UTIMER .@NowTime = 0
    WHILE(1)
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1006)<>1 THEN
            PRINT "  1006-PCABORT"
            GOTO 12
        END
    END 
12
    PCABORT 5:
    UTIMER .@NowTime = 0
    WHILE(1)
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1005)<>1 THEN
            PRINT "  1005-PCABORT"
            GOTO 13
        END
    END 
13
    PCABORT 1:
    UTIMER .@NowTime = 0
    WHILE(1)
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1001)<>1 THEN
            PRINT "  1001-PCABORT"
            GOTO 14
        END
    END
14
    PCABORT 3:
    UTIMER .@NowTime = 0
    WHILE(1)
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1003)<>1 THEN
            PRINT "  1003-PCABORT"
            GOTO 15
        END
    END
15
    PCABORT 4:
    UTIMER .@NowTime = 0
    WHILE(1)
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1004)<>1 THEN
            PRINT "  1004-PCABORT"
            GOTO 16
        END
    END
16
    PCABORT 8: 
    UTIMER .@NowTime = 0
    WHILE (1) DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1008)<>1 THEN
            PRINT "  1008-PCABORT"
            GOTO 17
        END
    END
17
    PCABORT 2: 
    UTIMER .@NowTime = 0
    WHILE (1) DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            PRINT "中断できません TASKNO=",TASKNO
            RETURN
        END
        IF TASK(1002)<>1 THEN
            PRINT "  1002-PCABORT"
            GOTO 18
        END
    END
18
    MC PCKILL 8:
    PRINT "  1008-PCKILL"
    MC PCKILL 2:
    PRINT "  1002-PCKILL"
    MC PCKILL 4: 
    PRINT "  1004-PCKILL"
    MC PCKILL 3: 
    PRINT "  1003-PCKILL"
    MC PCKILL 6: 
    PRINT "  1006-PCKILL"
    MC PCKILL 5: 
    PRINT "  1005-PCKILL"
    MC PCKILL 1:
    PRINT "  1001-PCKILL"
    PRINT " "
    ;ロボットマスター
    MC HOLD 1:
    PRINT "  1-HOLD"
    MC ABORT 1:
    PRINT "  1-ABORT"
    TWAIT 1
    MC KILL 1:
    PRINT "  1-KILL"
    ;ロボットスレーブ
    MC HOLD 2:
    PRINT "  2-HOLD"
    MC ABORT 2:
    PRINT "  2-ABORT"
    TWAIT 1
    MC KILL 2:
    PRINT "  2-KILL"
    PRINT " "
    PRINT " Done killpg(). Now... You can be load some files for controllers in safety."
    PRINT " "
    MC ZPOW 1: OFF
    MC ZPOW 2: OFF
.END

.PROGRAM exec_alone(.ret)
;-------------------------------- 
;機能：ALONEコマンド実行
;引数：なし
;戻値：成否
;-------------------------------- 
    .ret=err_no_error
    IF ( coopstatus(1) == 0 AND coopstatus(2) == 0 ) THEN
        IF DEBUG.PRT.FUNC==TRUE THEN
            PRINT "exec_alone()->協調中では無い TASKNO=",TASKNO
        END
        RETURN
    END
    IF TASKNO<>PG_MASTER AND TASKNO<>PG_SLAVE THEN
        IF DEBUG.PRT.FUNC==TRUE THEN
            PRINT "exec_alone()->協調中を検出:ZMONEXE ALONE TASKNO=",TASKNO
        END
        IF (SWITCH(CS,1)==ON OR SWITCH(CS,2)==ON) THEN
            DO
                IF SWITCH(CS,1)==ON THEN
                    MC HOLD 1:
                END
                IF SWITCH(CS,2)==ON THEN
                    MC HOLD 2:
                END
                IF DEBUG.PRT.FUNC==TRUE THEN
                    PRINT "Try to execute hold command before ZONEXE."
                END
            UNTIL((SWITCH(CS,1)==OFF AND SWITCH(CS,2)==OFF))
        END
        ZMONEXE "ALONE"
    ELSE
        IF DEBUG.PRT.FUNC==TRUE THEN
            PRINT "exec_alone()->協調中を検出:ALONE TASKNO=",TASKNO
        END
        ALONE
    END
    UTIMER .@NowTime = 0
    DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            .ret=err_robot_cmon
            PRINT "Can not change ALONE-mode for MASTER_ROBOT"
            RETURN
        END
    UNTIL(COOPSTATUS(1)==0)
    UTIMER .@NowTime = 0
    DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            .ret=err_robot_cmon
            PRINT "Can not change ALONE-mode for SLAVE_ROBOT"
            RETURN
        END
    UNTIL(COOPSTATUS(2)==0)
.END

.PROGRAM update_holdpos()
;-------------------------------- 
;機能：位置データの記録
;引数：無し
;戻値：無し
;--------------------------------
    ;停止位置記憶有効フラグ
    IF DISABLE_READJ_POS==FALSE THEN
        FLG_ENABLE_STOPPOS=TRUE
    END
    POINT #REC_HOLDPOS[1]=#S_HERE(1)
    POINT #REC_HOLDPOS[2]=#S_HERE(2)
    IF DEBUG.PRT.FUNC==TRUE THEN
        FOR .j=1 to 2
            DECOMPOSE .buf[1]=#REC_HOLDPOS[.j]
            FOR .i=1 TO 6
                PRINT "TASKNO=",TASKNO,"update_holdpos()-> Element of REC_HOLDPOS[",.j,"]:[",.i,"]=",.buf[.i]
            END
        END
    END
.END
.PROGRAM getparam(.cmd,.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
    .ret = err_no_error
    .rno=VAL($prm[TASKNO,1])
    CASE .cmd OF
        VALUE CMD_GET_SP:
            ;This protcol will delete soon.
            .$res = $ENCODE(0)
        VALUE CMD_GET_PITCH:
            .$res = $ENCODE(DATA_TEACHROT)+","+$ENCODE(DATA_TEACHPITCH)+","+$ENCODE(DATA_EXTTYPE[ROBOT_MASTER])+","+$ENCODE(DATA_EXTTYPE[ROBOT_SLAVE])
        VALUE CMD_GET_TNUM:
            .$res = $ENCODE(TOOL_DATA_NUM[.rno])
        VALUE CMD_GET_TOOL:
            .mode=VAL($prm[TASKNO,2]);モードは無効、後日削除
            POINT .toolprm=DEF_TOOL[.rno,VAL($prm[TASKNO,3])]
            DECOMPOSE .toolprm[1]=.toolprm
            ;重量、重心(XYZイナーシャXYZ)は未対応のため固定値応答
            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
            .$res=$ENCODE(.toolprm[1])+","+$ENCODE(.toolprm[2])+","+$ENCODE(.toolprm[3])+",0,0,0,0,0,0,0"
        VALUE CMD_GET_CORD:
            .$res = $ENCODE(DATA_TEACHCOORDINATE)
        VALUE CMD_GET_POS:
            .mode=VAL($prm[TASKNO,2])
            ;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
            CALL GetCurrentPos(.rno,.mode,.#cpos,.ret)
            IF .ret<>err_no_error THEN
                .$res = "err_bad_mode"
            ELSE
                DECOMPOSE .cpos[1] = .#cpos
                .$res=$ENCODE(.cpos[1])+","+$ENCODE(.cpos[2])+","+$ENCODE(.cpos[3])+","+$ENCODE(.cpos[4])+","+$ENCODE(.cpos[5])
            END
        VALUE CMD_GET_INFO:
            IF G_LAST_ERROR!=0 THEN
                .err = 1
            ELSE
                IF SWITCH(ERROR,1)==ON OR SWITCH(ERROR,2)==ON THEN
                    IF SWITCH(ERROR,1)==ON AND SWITCH(ERROR,2)==ON THEN
                        G_LAST_ERROR = 1020
                    ELSE
                        IF SWITCH(ERROR,1)==ON THEN
                            G_LAST_ERROR = 1021
                        ELSE
                            G_LAST_ERROR = 1022
                        END
                    END
                    .err = 1
                ELSE
                    .err = 0
                END
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    IF SWITCH(POWER,1)==ON AND SWITCH(POWER,2)==ON THEN
                        ;両方ONでON
                        .power_sw = 1
                    ELSE
                        .power_sw = 0
                    END
                VALUE ROBOT_MASTER:
                    IF SWITCH(POWER,1)==ON THEN
                        .power_sw = 1
                    ELSE
                        .power_sw = 0
                    END
                VALUE ROBOT_SLAVE:
                    IF SWITCH(POWER,2)==ON THEN
                        .power_sw = 1
                    ELSE
                        .power_sw = 0
                    END
                ANY
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN                
            END
            IF DATA_EXECUTE==TRUE OR FLG_MASTER_MOVE==TRUE OR FLG_SLAVE_MOVE==TRUE THEN
                .status=STATUS_MOVE
            ELSE
                CALL chk_exe_staus(.exe_status)
                IF .exe_status<>err_no_error THEN
                    .status=STATUS_HOLD
                ELSE
                    .status=STATUS_NOMOVE
                END
            END
            .direct_status = 0
            IF ROBOT_MODE==MODE_DIRECT THEN
                IF SWITCH(CS,1)==ON AND SWITCH(CS,2)==ON AND (ROBOT_MODE_FLG<>FALSE) THEN
                    .direct_status = 1
                END
            END
            .tablet_status = 0
            IF ROBOT_MODE==MODE_TABLET THEN
                IF SWITCH(CS,1)==ON AND SWITCH(CS,2)==ON AND (ROBOT_MODE_FLG<>FALSE) THEN
                    .tablet_status = 1
                END
            END
            .$res = $DATA_CUR_L1NAME+","+$ENCODE(DATA_CUR_L2DISP)+","+$ENCODE(DATA_CUR_L3DISP)+","+$ENCODE(.status)+","+$ENCODE(.power_sw)+","+$ENCODE(.err)
            .$res = .$res+","+$ENCODE(-SIG(SIG_EMG_OUTPUT))+","+$ENCODE(.tablet_status)+","+$ENCODE(.direct_status)+","+$ENCODE(G_LAST_ERROR)
            IF .rno==ROBOT_SLAVE THEN
                .$res = .$res+","+$ENCODE(MSPEED2)+","+$ENCODE(MSPEED2)
            ELSE
                ;両方の場合はマスターを返す
                .$res = .$res+","+$ENCODE(MSPEED)+","+$ENCODE(MSPEED)
            END
            ;原点情報
            IF SIG(sig_r1gen1_outp)==ON THEN
                .r1gen = 1
            ELSE
                IF SIG(sig_r1gen2_outp)==ON THEN
                    .r1gen = 2
                ELSE
                    .r1gen = 0
                END
            END
            IF SIG(sig_r2gen1_outp)==ON THEN
                .r2gen = 1
            ELSE
                IF SIG(sig_r2gen2_outp)==ON THEN
                    .r2gen = 2
                ELSE
                    .r2gen = 0
                END
            END
            .$res = .$res+","+$ENCODE(.r1gen)+","+$ENCODE(.r2gen)
            ;ロボット状態遷移情報
            IF g_last_error<>0 THEN
                .robot_status = sta_error
            ELSE
                .robot_status = robot_status_out
            END
            IF debug_status<>-1 THEN
                .robot_status = debug_status
            END
            ;AUTO/MANUAL情報
            IF SIG(extin_repeat_tg) AND SIG(-extin_teach_tgl) THEN
                .tglsw = 1
            ELSE
                IF SIG(-extin_repeat_tg) AND SIG(extin_teach_tgl) THEN
                    .tglsw = 0
                ELSE
                    .tglsw = 2
                END
            END
            .$res = .$res+","+$ENCODE(.robot_status)+","+$ENCODE(.tglsw)
            ;現在作業グループ番号
            .$res = .$res+","+$ENCODE(DATA_CUR_WORKNO)
        VALUE CMD_GET_L1INFO:
            .$res=$DATA_CUR_L1NAME+","+$ENCODE(DATA_L2NUM)
        VALUE CMD_GET_L2INFO:
            NOEXIST_SET_R DATA_L2WORKNO[VAL($prm[TASKNO,2])] = 0
            .$res=$DATA_L2NAME[VAL($prm[TASKNO,2])]+","+$ENCODE(DATA_L3NUM[VAL($prm[TASKNO,2])])+","+$ENCODE(DATA_L2EXETBLNUM[VAL($prm[TASKNO,2])])+","+$ENCODE(DATA_L2WORKNO[VAL($prm[TASKNO,2])])
        VALUE CMD_GET_L3INFO:
            .$res=$DATA_L3NAME[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])]
        VALUE CMD_GET_IO:
            IF SIG(VAL($prm[TASKNO,2])) THEN
                .$res="1"
            ELSE
                .$res="0"
            END
        VALUE CMD_GET_HOME:
            .homeno=VAL($prm[TASKNO,2])
            IF .rno!=1 && .rno!=2 THEN
                .ret=err_bad_rno
                .$res = "err_bad_rno"
                RETURN
            END
            IF .homeno!=1 && .homeno!=2 THEN
                .ret=err_bad_homeno
                .$res = "err_bad_homeno"
                RETURN
            END
            POINT .rno: .#home=#HOME(.homeno)
            DECOMPOSE .buf[1]=.#home
            ;精度取得のみ未対応
            .buf[7] = ROBOT_HACC[.rno,.homeno]
            ;.buf[1]-.buf[5]=JT1-JT5,.buf[7]=精度
            ;タブレット送信データ並び順=JT1,JT2,JT3,JT4,Ext1
            .$res = $ENCODE(.buf[1])+","+$ENCODE(.buf[2])+","+$ENCODE(.buf[3])+","+$ENCODE(.buf[4])+","+$ENCODE(.buf[5])+","+$ENCODE(.buf[7])
        VALUE CMD_GET_SIGNAME:
            IF VAL($prm[TASKNO,2])<0 THEN
                .ret=err_bad_tableno
                .$res = "err_bad_tableno"
                RETURN
            END
            .$res = $DATA_IO_NUM[VAL($prm[TASKNO,2])]+","+$DATA_IO_NAME[VAL($prm[TASKNO,2])]
        VALUE CMD_GET_SIGNUM:
            IF VAL($prm[TASKNO,2])<0 THEN
                .ret=err_bad_tableno
                .$res = "err_bad_tableno"
                RETURN
            END
            .$res = $ENCODE(DATA_IO_TABLENUM)
        VALUE CMD_GET_MONSP:
            CASE .rno OF
                VALUE ROBOT_ALL,ROBOT_MASTER:
                    ;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
                    .$res = $ENCODE(MSPEED)
                VALUE ROBOT_SLAVE:
                    .$res = $ENCODE(MSPEED2)
                ANY
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN
            END
        VALUE CMD_GET_L2EXETBL:
            IF VAL($prm[TASKNO,3])<0 THEN
                .ret=err_bad_tableno
                .$res = "err_bad_tableno"
                RETURN
            END
            .$res = $ENCODE(DATA_L2TBL_SIGNUM[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])])+","+$ENCODE(DATA_L2TBL_STATUS[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])])
        VALUE CMD_GET_INFOEX:
            IF .rno!=1 && .rno!=2 THEN
                .ret=err_bad_rno
                .$res = "err_bad_rno"
                RETURN
            END
            ;現在位置
            .mode=VAL($prm[TASKNO,2])
            ;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
            CALL GetCurrentPos(.rno,.mode,.#cpos,.ret)
            IF .ret<>err_no_error THEN
                .$res = "err_bad_mode"
                RETURN
            ELSE
                DECOMPOSE .cpos[1] = .#cpos
                .$res=$ENCODE(.cpos[1])+","+$ENCODE(.cpos[2])+","+$ENCODE(.cpos[3])+","+$ENCODE(.cpos[4])+","+$ENCODE(.cpos[5])+","
            END
            CASE .rno OF
                VALUE ROBOT_ALL,ROBOT_MASTER:
                    ;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
                    .$res = .$res+$ENCODE(MSPEED)
                VALUE ROBOT_SLAVE:
                    .$res = .$res+$ENCODE(MSPEED2)
                ANY
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN
            END
            ;アーム動作速度、アーム動作ピッチ(回転)、アーム動作ピッチ(直動)
            .$res = .$res+","+$ENCODE(DATA_TEACHROT)+","+$ENCODE(DATA_TEACHPITCH)+","
            ;IO取得
            .signo = VAL($prm[TASKNO,4])
            CALL get_iotype(.signo,.sigtype,.ret)
            IF .ret<>err_no_error THEN
                .$res = "err_bad_signo"
                RETURN
            END
            IF SIG(.signo) THEN
                .$res=.$res +"1,"
            ELSE
                .$res=.$res +"0,"
            END
            ;ハンド状態取得
            .$res=.$res +$ENCODE(DATA_HAND_CUR[.rno])
        VALUE CMD_GET_HAND:
            .$res=$ENCODE(DATA_HAND_CUR[ROBOT_MASTER])+","+$ENCODE(DATA_HAND_CUR[ROBOT_SLAVE])
        VALUE CMD_GET_HANDIO:
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN
                VALUE ROBOT_MASTER,ROBOT_SLAVE:
                    .$res = $ENCODE(DATA_HAND_TYPE[.rno])+","+$ENCODE(DATA_HAND_IO[.rno,1])+","+$ENCODE(DATA_HAND_IO[.rno,2])+","+$ENCODE(DATA_HAND_IO[.rno,3])+","+$ENCODE(DATA_HAND_IO[.rno,4])
                ANY
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN
            END
        VALUE CMD_GET_VTB:
            .vtblno=VAL($prm[TASKNO,2])
            IF .vtblno<=0 THEN
                ;タブレット側が番号0で呼出している暫定対策20150804
                ;.ret=err_bad_tableno
                .$res = "err_bad_tableno"
                RETURN
            END
            NOEXIST_SET_R DATA_VS_ROBOT[.vtblno]=0
            NOEXIST_SET_R DATA_VS_CAM_NUM[.vtblno]=0
            NOEXIST_SET_R DATA_VS_CALC_NUM[.vtblno]=0
            NOEXIST_SET_R DATA_VS_CAM_TYPE[.vtblno]=0
            NOEXIST_SET_R DATA_VS_HOLD_TYPE[.vtblno]=0
            NOEXIST_SET_R DATA_VS_CALC_POS[.vtblno]=0
            NOEXIST_SET_S $DATA_VS_NAME[.vtblno]="NO SETTING"
            CALL convert_vid(MODE_DEL,DATA_VS_CALC_POS[.vtblno],DATA_VS_VID[.vtblno],.vision_id)
            .$res = $ENCODE(.vision_id)+","+$ENCODE(DATA_VS_CAM_NUM[.vtblno])+","+$ENCODE(DATA_VS_CALC_NUM[.vtblno])
            .$res = .$res +","+$ENCODE(DATA_VS_CAM_TYPE[.vtblno])+","+$ENCODE(DATA_VS_HOLD_TYPE[.vtblno])+","+$ENCODE(DATA_VS_CALC_POS[.vtblno])
            .$res = .$res +","+$DATA_VS_NAME[.vtblno]+","+$ENCODE(DATA_VS_ROBOT[.vtblno])
        VALUE CMD_GET_VTBNUM:
            .$res = $ENCODE(DATA_VS_TBNUM)
        VALUE CMD_GET_VRESULT:
            ;ビジョンID変換
            CALL convert_vid(MODE_ADD,VAL($prm[TASKNO,4]),VAL($prm[TASKNO,2]),.vision_id)
            CALL get_vision_result(.vision_id,VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),.x,.y,.rot,.ret)
            .$res = $ENCODE(.x)+","+$ENCODE(.y)+","+$ENCODE(.rot)
        VALUE CMD_GET_ROBOTMODE:
            .$res = $ENCODE(ROBOT_MODE)+","+$ENCODE(ROBOT_MODE_FLG)
        VALUE CMD_GET_LOWSPAREA:
            IF VAL($prm[TASKNO,2])<=0 OR VAL($prm[TASKNO,2])>=5 THEN
                .ret=err_bad_areano
                RETURN
            END
            NOEXIST_SET_R AREASLOW_LOCATION[VAL($prm[TASKNO,2]),1]=0
            NOEXIST_SET_R AREASLOW_LOCATION[VAL($prm[TASKNO,2]),2]=0
            NOEXIST_SET_R AREASLOW_LOCATION[VAL($prm[TASKNO,2]),3]=0
            NOEXIST_SET_R AREASLOW_LOCATION[VAL($prm[TASKNO,2]),4]=0
            NOEXIST_SET_R AREASLOW_RATE[VAL($prm[TASKNO,2])]=10
            .$res = $ENCODE(AREASLOW_LOCATION[VAL($prm[TASKNO,2]),1])+","+$ENCODE(AREASLOW_LOCATION[VAL($prm[TASKNO,2]),2])+","+$ENCODE(AREASLOW_LOCATION[VAL($prm[TASKNO,2]),3])+","+$ENCODE(AREASLOW_LOCATION[VAL($prm[TASKNO,2]),4])+","+$ENCODE(AREASLOW_RATE[VAL($prm[TASKNO,2])])
        VALUE CMD_GET_LOWSPSETTING:
            NOEXIST_SET_R AREASLOW_MODE=0
            .$res = $ENCODE(AREASLOW_MODE)
        VALUE CMD_GET_GRAVITYADJMOVE:
            NOEXIST_SET_R GRAV_CUR_VAL[0]=-25
            NOEXIST_SET_R GRAV_CUR_VAL[1]=-25
            .$res = $ENCODE(-FLG_GRAVITYADJ_ACTIVE)+","+$ENCODE(GRAV_CUR_VAL[0])+","+$ENCODE(GRAV_CUR_VAL[1])
        VALUE CMD_GET_COLCHKMOVE:
            .$res = $ENCODE(ABS(FLG_ENABLE_COLCHKMOVE))
        VALUE CMD_GET_SLOWLIMIT:
            .$res = $ENCODE(SLOWLIMIT_ENA)+","+$ENCODE(SLOWLIMIT_SPEED)+","+$ENCODE(SLOWLIMIT_TIME)
        VALUE CMD_GET_VERSION:
            FOR .i=1 TO 2
                .$servo_ver[.i] =""
                FOR .j=1 TO 4
                  .$servo_ver[.i] =.$servo_ver[.i] + $SYSDATA(YM.ID,.i,.j)+"  "
                END
                .$servo_ver[.i] =$LEFT(.$servo_ver[.i],LEN(.$servo_ver[.i])-2)
            END
            .$res = $STR_ID(2)+","+.$servo_ver[1]+","+.$servo_ver[2]+","+$LEFT($appli_ver_tbl,8)
        VALUE CMD_GET_INTFPARAM:
            IF .rno<1 OR .rno>2 THEN
                .r_no =1
            ELSE
                .r_no=.rno
            END
;            .intf_param[1] = SYSDATA(INTF.MIN_X,.r_no )
;            .intf_param[2] = SYSDATA(INTF.MIN_Y,.r_no )
;            .intf_param[3] = SYSDATA(INTF.MAX_X,.r_no )
;            .intf_param[4] = SYSDATA(INTF.MAX_Y,.r_no )
;            .intf_param[5] = SYSDATA(INTF.XLINK_1,.r_no )
;            .intf_param[6] = SYSDATA(INTF.XLINK_2,.r_no )
;            .$res=$ENCODE(.intf_param[1])
;            FOR .i= 2 TO 6
;                .$res=.$res+","+$ENCODE(.intf_param[.i])
;            END
.*ASソフト完成までの暫定処理
            NOEXIST_SET_S $set_intf_param[.r_no] = "1,1,1,1,105,89"
            .$res = $set_intf_param[.r_no]
        VALUE CMD_GET_SA:
IF OFF THEN
;            FOR .arm=1 TO 2
;                .sa_base_dir[.arm] = SYSDATA(SA.BASE_DIRECTION, .arm )
;                .sa_tool_dir[.arm] = SYSDATA(SA.TOOL_DIRECTION, .arm)
;                .sa_over_jt[.arm] = SYSDATA(SA.OVR_RNG_JT, .arm)
;                .sa_over_dir[.arm] = SYSDATA(SA.OVR_RNG_DIR, .arm)
;            END
;            NOEXIST_SET_R .sa_base_dir[1] = -1
ELSE
            .sa_base_dir[1] = -1
            NOEXIST_SET_S $sa_param = "0,1,1,1,1,1,1,1,1"
END
            IF .sa_base_dir[1] ==-1 THEN
                .$res = $sa_param
                RETURN
            END
            IF 0<.sa_base_dir[ROBOT_MASTER] OR .sa_base_dir[ROBOT_SLAVE] THEN
                .sa_direct = 1
            ELSE
                IF 0<.sa_tool_dir[ROBOT_MASTER] OR .sa_tool_dir[ROBOT_SLAVE] THEN
                    .sa_direct = 2
                ELSE
                    .sa_direct = 0
                END
            END
            .$res = $ENCODE(/I1,.sa_direct)
            FOR .arm=1 TO 2
                FOR .p_no=1 TO 4
                    CASE .sa_direct
                        VALUE SA.JT
IF OFF THEN
;                            .sa_gain[.arm,.p_no] = SYSDATA(SA.GAIN, .arm,.p_no)
END
                            IF .sa_gain[.arm,.p_no] <100 THEN
                                .sa_param[.arm,.p_no] = 1
                            ELSE
                                .sa_param[.arm,.p_no] = 0
                            END
                        VALUE SA.BASE
                            .check = .sa_base_dir[.arm] BAND 2^(.p_no-1)
                            IF .check==OFF THEN
                                .sa_param[.arm,.p_no] = 0
                            ELSE
                                .sa_param[.arm,.p_no] = 1
                            END
                        VALUE SA.TOOL
                            .check = .sa_tool_dir[.arm] BAND 2^(.p_no-1)
                            IF .check==OFF THEN
                                .sa_param[.arm,.p_no] = 0
                            ELSE
                                .sa_param[.arm,.p_no] = 1
                            END
                    END
                    IF .sa_over_jt[.arm] == .p_no THEN
                        .sa_param[.arm,.p_no] = 2
                    END
                    IF .sa_over_dir[.arm] == .p_no OR ( .p_no==4 AND .sa_over_jt[.arm] == 6 )  THEN
                        .sa_param[.arm,.p_no] = 3
                    END
                    .$res = .$res+","+$ENCODE(/I1,.sa_param[.arm,.p_no])
                END
            END
        VALUE CMD_GET_IOSTAT:
            .ox_sig_no = VAL($prm[TASKNO,2]); 先頭信号番号（出力）
            .wx_sig_no = VAL($prm[TASKNO,3]); 先頭信号番号（入力）
            .ix_sig_no = VAL($prm[TASKNO,4]); 先頭信号番号（内部）
            CALL get_io_status(.ox_sig_no,16,.ox_sig_stat)
            CALL get_io_status(.wx_sig_no,16,.wx_sig_stat)
            CALL get_io_status(.ix_sig_no,16,.ix_sig_stat)
            .$res = $ENCODE(.ox_sig_no)+","+$ENCODE(.ox_sig_stat)+","+$ENCODE(.wx_sig_no)+","+$ENCODE(.wx_sig_stat)+","+$ENCODE(.ix_sig_no)+","+$ENCODE(.ix_sig_stat)
        VALUE CMD_GET_COUNT:
            .count_no[1] = VAL($prm[TASKNO,2]); 先頭カウンタ番号１
            .count_no[2] = VAL($prm[TASKNO,3]); 先頭カウンタ番号２
            FOR .i=1 TO 2
              CALL get_cnt_status(.count_no[.i],5)
              IF .i==1 THEN
                .$res = $ENCODE(.count_no[.i])
              ELSE
                .$res = .$res+","+$ENCODE(.count_no[.i])
              END
              FOR .j=1 TO 5
                .$res = .$res+","+$ENCODE(DISP_CNTNUM[.j])
              END
            END
        VALUE CMD_GET_GENPARAM:
            .pno = VAL($prm[TASKNO,2])
            .mno = VAL($prm[TASKNO,3])
            CASE .pno OF
              VALUE 1; 安全距離
                IF .rno<>1 AND .rno<>2 THEN; ロボット番号確認[1-2]
                    .ret=err_bad_rno
                    .$res = "err_bad_rno"
                    RETURN
                END
                IF .mno==1 THEN; 現在値取得
                  DECOMPOSE .rob[1] = S_HERE(.rno)
                  POINT .rob_pos = TRANS(.rob[1],.rob[2],.rob[3],.rob[4],.rob[5],.rob[6])
                  POINT .null_pos = TRANS(0,0,.rob[3],0,0,0)
                  .dist = DISTANCE(.rob_pos,.null_pos)
                  .$res = $ENCODE(/F8.3,.dist)
                ELSE; 設定値取得
                  .$res = $ENCODE(chk_gohome[.rno])
                END
              VALUE 2:; ツール間距離
                IF .mno==1 THEN; 現在値取得
                  DECOMPOSE .rob1[1] = S_HERE(1)
                  DECOMPOSE .rob2[1] = S_HERE(2)
                  POINT .rob1_pos = TRANS(.rob1[1],.rob1[2],.rob1[3],.rob1[4],.rob1[5],.rob1[6])
                  POINT .rob2_pos = TRANS(.rob2[1],.rob2[2],.rob1[3],.rob2[4],.rob2[5],.rob2[6])
                  .dist = DISTANCE(.rob1_pos,.rob2_pos)
                  .$res = $ENCODE(/F8.3,.dist)
                ELSE; 設定値取得
                  .$res = $ENCODE(chk_dist_here)
                END
              ANY
                .ret=err_bad_ptype
                .$res = "err_bad_ptype"
            END
        VALUE CMD_GET_COLR:
            ;衝突検知感度取得
        VALUE CMD_GET_WSET:
            ;作業グルーピング設定取得
            .$res = $ENCODE(DATA_WSET_ENA)+","+$ENCODE(DATA_CUR_MAXNUM)
        VALUE CMD_GET_WSPEC:
            ;作業グループ指定方法取得
            .$res = $ENCODE(DATA_WSET_SPEC)+","+$ENCODE(DATA_WSET_SET[1])+","+$ENCODE(DATA_WSET_SET[2])
        VALUE CMD_GET_WNO:
            ;作業グループ番号取得
            .$res = $ENCODE(DATA_WSET_NO)
        VALUE CMD_GET_WINFO:
            ;作業グループ名称取得
            .wno = VAL($prm[TASKNO,2])
            IF .wno<1 OR MAX_WORKNUM<.wno THEN
              .ret=err_bad_ptype
              .$res = "err_bad_ptype"
            ELSE
              NOEXIST_SET_S $DATA_WORKNAME[.wno] = ""
              .$res = $DATA_WORKNAME[.wno]
              IF .$res=="" THEN
                .$res = "***"
              END
            END
        ANY
            .ret=err_cmd_type
            .$res = "err_cmd_type"
    END
.END

.PROGRAM getstep(.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
    .ret = err_no_error
    .l2num=VAL($prm[TASKNO,2])
    .l3num=VAL($prm[TASKNO,3])
    .l3type=DATA_L3TYPE[.l2num,.l3num]
    CASE .l3type OF
        VALUE L3TYPE_MOVE:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]
            ;ビジョンID変換(引数順でID割当番号)
            .vision_id1 = DATA_VISION_ID1[.l2num,.l3num]
            CALL convert_vid(MODE_DEL,TYPE_POS,DATA_VISION_ID2[.l2num,.l3num],.vision_id2)
            CALL convert_vid(MODE_DEL,TYPE_POS,DATA_VISION_ID3[.l2num,.l3num],.vision_id3)
            .$res=.$res+","+$ENCODE(DATA_VISION_STATUS[.l2num,.l3num])+","+$ENCODE(.vision_id1)+","+$ENCODE(.vision_id2)+","+$ENCODE(.vision_id3)
            .$res=.$res+","+$ENCODE(DATA_REPSPEED[.l2num,.l3num])+","+$ENCODE(DATA_POSTYPE[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_BEFORE[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_AFTER[.l2num,.l3num])
            NOEXIST_SET_R DATA_ACCEL[.l2num,.l3num]=DATA_ACC
            NOEXIST_SET_R DATA_DECEL[.l2num,.l3num]=DATA_DEC
            NOEXIST_SET_R DATA_ACCURACY[.l2num,.l3num]=DATA_ACCU
            NOEXIST_SET_R DATA_ABSSP_MODE[.l2num,.l3num]=0
            .$res=.$res+","+$ENCODE(DATA_ACCEL[.l2num,.l3num])+","+$ENCODE(DATA_DECEL[.l2num,.l3num])+","+$ENCODE(DATA_ACCURACY[.l2num,.l3num])+","+$ENCODE(DATA_ABSSP_MODE[.l2num,.l3num])
        VALUE L3TYPE_IO_WAIT:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_SIGNUM[.l2num,.l3num])
            .$res=.$res+","+$ENCODE(DATA_SIGSTATUS[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_BEFORE[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_AFTER[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_TIMEOUT[.l2num,.l3num])
            NOEXIST_SET_R DATA_WAIT_TOCON[.l2num,.l3num]=0
            .$res=.$res+","+$ENCODE(DATA_WAIT_TOCON[.l2num,.l3num])
        VALUE L3TYPE_IO_CHANGE:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_SIGNUM[.l2num,.l3num])
            .$res=.$res+","+$ENCODE(DATA_SIGSTATUS[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_BEFORE[.l2num,.l3num])+","+$ENCODE(DATA_WAIT_AFTER[.l2num,.l3num])+","+$ENCODE(DATA_KEEP_WAIT[.l2num,.l3num])
        VALUE L3TYPE_CSTART,L3TYPE_CEND,L3TYPE_WSTART,L3TYPE_WEND,L3TYPE_RETURN:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]
        VALUE L3TYPE_VISION,L3TYPE_CALVISION:
            ;ビジョンID変換
            CALL convert_vid(MODE_DEL,DATA_VISION_CALPOS[.l2num,.l3num],DATA_VISION_ID[.l2num,.l3num],.vision_id)
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(.vision_id)+","+$ENCODE(DATA_VISION_CALPOS[.l2num,.l3num])
            NOEXIST_SET_R DATA_VISION_CNT[.l2num,.l3num]=0;         ビジョンNG続行フラグ初期値=0（停止）
            .$res=.$res+","+$ENCODE(DATA_VISION_CNT[.l2num,.l3num]); ビジョンNG続行フラグ追加
        VALUE L3TYPE_L2RESET:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_L2RESETNUM[.l2num,.l3num])
        VALUE L3TYPE_HAND_CHANGE:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_HAND_CTL[.l2num,.l3num])
        VALUE L3TYPE_COLCHK:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_COLCHK[.l2num,.l3num])
        VALUE L3TYPE_IFGOTO:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_L3IFGOTO_ID[.l2num,.l3num])+","+$ENCODE(DATA_L3IFGOTO_LABEL[.l2num,.l3num])
        VALUE L3TYPE_IFLABEL:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_L3LABEL[.l2num,.l3num])
        VALUE L3TYPE_CNT:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_CNTID[.l2num,.l3num])+","+$ENCODE(DATA_CNTTYPE[.l2num,.l3num])
        VALUE L3TYPE_CNTSET:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_CNTID[.l2num,.l3num])+","+$ENCODE(DATA_CNTVAL[.l2num,.l3num])
        VALUE L3TYPE_STOP:
            .$res=$ENCODE(DATA_ROBOTTYPE[.l2num,.l3num])+","+$ENCODE(DATA_L3TYPE[.l2num,.l3num])+","+$DATA_L3NAME[.l2num,.l3num]+","+$ENCODE(DATA_RESTART_FLG[.l2num,.l3num])
        ANY
            .ret=err_bad_l3type
    END
.END

.PROGRAM getsteppos(.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
    .ret = err_no_error
    .l2num=VAL($prm[TASKNO,2])
    .l3num=VAL($prm[TASKNO,3])
    .$buf1=$ENCODE(DATA_MODE[.l2num,.l3num])+","+$ENCODE(DATA_TOOL[.l2num,.l3num])
    IF DATA_MODE[.l2num,.l3num]<>MODE_JT THEN
        .$res=.$buf1+","+$ENCODE(DATA_POS1[.l2num,.l3num])+","+$ENCODE(DATA_POS2[.l2num,.l3num])+","+$ENCODE(DATA_POS3[.l2num,.l3num])+","+$ENCODE(DATA_POS4[.l2num,.l3num])+","+$ENCODE(DATA_POS5[.l2num,.l3num])
    ELSE
        .$res=.$buf1+","+$ENCODE(DATA_POS1[.l2num,.l3num])+","+$ENCODE(DATA_POS2[.l2num,.l3num])+","+$ENCODE(DATA_POS3[.l2num,.l3num])+","+$ENCODE(DATA_POS4[.l2num,.l3num])+","+$ENCODE(DATA_POS5[.l2num,.l3num])
    END
.END

.PROGRAM getstepifgoto(.$res,.ret)
;-------------------------------- 
;機能：条件分岐詳細取得コア
;引数：第2階層番号、第3階層番号、条件番号
;戻値：取得データ文字列、成否
;-------------------------------- 
    .ret = err_no_error
    .l2num = VAL($prm[TASKNO,2])
    .l3num = VAL($prm[TASKNO,3])
    .ifconid = VAL($prm[TASKNO,4])
    .$res = $ENCODE(DATA_IFMODE[.l2num,.l3num,.ifconid])+","+$ENCODE(DATA_IFTYPE[.l2num,.l3num,.ifconid])+","+$ENCODE(DATA_IFITEM[.l2num,.l3num,.ifconid])+","+$ENCODE(DATA_IFCNT[.l2num,.l3num,.ifconid])
.END

.PROGRAM get_io_status(.no,.num,.bit_io)
;-------------------------------- 
;機能：I/Oの状態を取得
;引数：開始信号番号、信号数
;戻値：信号状態
;-------------------------------- 
; 初期化
  .bit_io = 0
; 信号数取得
  .ox_num = SYSDATA(ZSIGSPEC.DO); 出力信号
  .wx_num = SYSDATA(ZSIGSPEC.DI); 入力信号
  .ix_num = SYSDATA(ZSIGSPEC.INT); 内部信号
; 汎用フィールドバスI/O設定取得
  .fb_io = ZOPTION(13,2)
  IF .fb_io<>OFF THEN
    .ox_num = .ox_num + SYSDATA(ZSIGSPEC.MAS) + SYSDATA(ZSIGSPEC.SLA)
    .wx_num = .wx_num + SYSDATA(ZSIGSPEC.MAS) + SYSDATA(ZSIGSPEC.SLA)
  END
; 入力値確認
  IF .num<=0 OR 16<.num THEN; 信号数が範囲外か確認
    IF .num<=0 THEN
      .num = 1; 最小
    ELSE
      .num = 16; 最大
    END
  END
  IF .no<=0 OR (.ox_num<(.no+.num-1) AND .no<=1000) OR ((1000+.wx_num)<(.no+.num-1) AND .no<=2000) OR ((2000+.ix_num)<(.no+.num-1)) THEN; 信号番号が範囲外か確認
    IF .no<=0 THEN
      .no = 1
    ELSE
      IF (.ox_num<(.no+.num-1) AND .no<=1000) THEN; 出力信号範囲外の時
        .no = .ox_num-(.num-1)
      ELSE
        IF ((1000+.wx_num)<(.no+.num-1) AND .no<=2000) THEN; 入力信号範囲外の時
          .no = 1000+.wx_num-(.num-1)
        ELSE
          IF ((2000+.ix_num)<(.no+.num-1)) THEN; 内部信号範囲外の時
            .no = 2000+.ix_num-(.num-1)
          ELSE
            .no = 1
          END
        END
      END
    END
  END
; 信号状態読み取り
  .bit_io = BITS(.no,.num)
.END

.PROGRAM get_cnt_status(.no,.num)
;-------------------------------- 
;機能：カウンタの状態を取得
;引数：開始カウンタ番号、カウンタ数
;戻値：カウンタ値(配列)
;-------------------------------- 
; 初期化
  FOR .i=1 TO 5
    DISP_CNTNUM[.i] = 0
  END
; 入力値確認
  IF .num<=0 OR 5<.num THEN; カウンタ数が範囲外か確認
    IF .num<=0 THEN
      .num = 1; 最小
    ELSE
      .num = 5; 最大
    END
  END
  IF .no<=0 OR MAX_CNTNUM<(.no+.num-1) THEN; カウンタ番号が範囲外か確認
    IF .no<=0 THEN
      .no = 1
    ELSE
      .no = MAX_CNTNUM-(.num-1)
    END
  END
; カウンタ読み取り
  FOR .i=1 TO .num
    DISP_CNTNUM[.i] = DATA_CNTNUM[.no+(.i-1)]
  END
.END
.*****************************************************
.*  変数定義ファイル
.*  定数として扱いたい情報はsys.pgに記載すること
.*  変数定義ファイルはロボット動作中のロード不可
.*****************************************************

.PROGRAM chgprtflg(.$mes,.val)
;-------------------------------- 
;機能：デバッグ文表示設定変更、問合せ文字列生成、問合わせ発生、設定変更結果表示
;引数：表示文字列の一部
;戻値：操作対象フラグ
;-------------------------------- 
    .ret=0
    IF .val==0 THEN
        .$sta="非表示"
    ELSE
        .$sta="表示"
    END
    PROMPT "変更? "+.$mes+":[現在設定="+.$sta+"] (YES:1,NO:ENTER)",.ret
    IF .ret==1 THEN
        IF .val==TRUE THEN
            .val=FALSE
        ELSE
            .val=TRUE
        END
        IF .val==FALSE THEN
            PRINT "---------------> [変更後設定=非表示]"
        ELSE
            PRINT "---------------> [変更後設定=表示]"
        END
            PRINT ""
    ELSE
        PRINT "---------------> 変更無し"
        PRINT ""
    END
.END

.PROGRAM chgprt
;-------------------------------- 
;機能：デバッグ文表示設定切替
;引数：なし
;戻値：なし
;-------------------------------- 
    CALL noexist_init
    PRINT ""
    PRINT "********************************************************"
    PRINT "****  デバッグ表示設定  特殊反映  ************************"
    PRINT "********************************************************"
    PRINT ""
    ;CALL chgprtflg("sock.pg(PROTOCOL詳細のみ)設定",DEBUG.PRT.PROC)
    CALL chgprtflg("act.pg(l2exeのみ)設定",DEBUG.PRT.L2EXEC)
    CALL chgprtflg("move.pg(位置情報詳細のみ)設定",DEBUG.PRT.POS)
    CALL chgprtflg("core.pg(再起動のみ)設定",DEBUG.PRT.REBOOT)
    CALL chgprtflg("com.pg(外部制御盤のみ)設定",DEBUG.PRT.EXTIO)
    PRINT ""
    PRINT "********************************************************"
    PRINT "****  デバッグ表示設定　ファイル単位 *********************"
    PRINT "********************************************************"
    PRINT ""
    CALL chgprtflg("act.pgファイル設定",DEBUG.PRT.ACT)
    CALL chgprtflg("cmd.pgファイル設定",DEBUG.PRT.CMD)
    CALL chgprtflg("main.pgファイル設定",DEBUG.PRT.MAIN)
    CALL chgprtflg("sub.pgファイル設定",DEBUG.PRT.SUB)
    CALL chgprtflg("gen.pgファイル設定",DEBUG.PRT.GEN)
    CALL chgprtflg("com.pgファイル設定",DEBUG.PRT.COM)
    CALL chgprtflg("sock.pgファイル設定",DEBUG.PRT.SOCK)
    CALL chgprtflg("func.pgファイル設定",DEBUG.PRT.FUNC)
    CALL chgprtflg("vision.pgファイル設定",DEBUG.PRT.VISION)
    CALL chgprtflg("move.pgファイル設定",DEBUG.PRT.MOVE)
.END

.PROGRAM noexist_init
NOEXIST_SET_R DEBUG.PRT.SOCK = -1
NOEXIST_SET_R DEBUG.PRT.PROC = -1
NOEXIST_SET_R DEBUG.PRT.ACT = -1
NOEXIST_SET_R DEBUG.PRT.CMD = -1
NOEXIST_SET_R DEBUG.PRT.CORE = -1
NOEXIST_SET_R DEBUG.PRT.MAIN = -1
NOEXIST_SET_R DEBUG.PRT.SUB = -1
NOEXIST_SET_R DEBUG.PRT.GEN = -1
NOEXIST_SET_R DEBUG.PRT.COM = -1
NOEXIST_SET_R DEBUG.PRT.FUNC = -1
NOEXIST_SET_R DEBUG.PRT.VISION = -1
NOEXIST_SET_R DEBUG.PRT.REBOOT = -1
NOEXIST_SET_R DEBUG.PRT.EXTIO = -1
NOEXIST_SET_R DEBUG.PRT.POS = 0
NOEXIST_SET_R DEBUG.PRT.MOVE = -1
NOEXIST_SET_R DEBUG.PRT.L2EXEC = -1
NOEXIST_SET_R DEBUG.PRT.LOG = 0
NOEXIST_SET_R DEBUG.PRT.ITEM = 0
NOEXIST_SET_R DEBUG.PRT.SP = 0

.*制御用グローバル変数
NOEXIST_SET_R FLG_START_REBOOT = 0
NOEXIST_SET_R FLG_MAIN_RUN = 0
NOEXIST_SET_R FLG_DIRECT_RUN = 0
NOEXIST_SET_R FLG_MASTER_MOVE = 0
NOEXIST_SET_R FLG_SLAVE_MOVE = 0
NOEXIST_SET_R FLG_REQ_MAMODE = 0
NOEXIST_SET_R FLG_SLAVE_RDY = 0
NOEXIST_SET_R FLG_SLAVE_PARALLEL_REQ = 0
NOEXIST_SET_R FLG_SINGLE_MOVE = 0
NOEXIST_SET_R FLG_RESTART = 0
NOEXIST_SET_R ROBOT_STATUS = 0
NOEXIST_SET_R ROBOT_STATUS_OUT = 0
NOEXIST_SET_R G_LAST_ERROR = 0

.*内部制御用(シミュレータと実機で分岐設定処理有)
NOEXIST_SET_R EXTIN_START_BUTTON = 0
NOEXIST_SET_R EXTIN_STOP_BUTTON = 0
NOEXIST_SET_R EXTIN_TEACH_TGLSW = 0
NOEXIST_SET_R EXTIN_REPEAT_TGLSW = 0

.*原点復帰用パラメータ
NOEXIST_SET_R gohome_ptn = 0
NOEXIST_SET_R chk_gohome[1] = 400
NOEXIST_SET_R chk_gohome[2] = 400
NOEXIST_SET_R chk_jt1_rad = 100
NOEXIST_SET_R chk_dist_here = 200
UTIMER @tim_aft_alone2[1] = 0
UTIMER @tim_aft_alone2[2] = 0

.*内部制御用カウンタ初期状態設定
FOR .i = 1 TO MAX_CNTNUM
    NOEXIST_SET_R DATA_CNTNUM[.i] = 0
END

.*重力補償自動調整プログラム実行状態
NOEXIST_SET_R FLG_GRAVITYADJ_ACTIVE = 0

.*衝突検知感度自動調整設定状態
NOEXIST_SET_R FLG_ENABLE_COLCHKMOVE = 0

.*コマンド実行時位置チェックリミット値
NOEXIST_SET_R POSLIMIT_GEN = 1
NOEXIST_SET_R POSLIMIT_RESTART = 5

.*作業停止再開不可フラグ
NOEXIST_SET_R NO_RESTART_FLG = FALSE

.*SLOWLIMIT動作
NOEXIST_SET_R SLOWLIMIT_ENA = 1
NOEXIST_SET_R SLOWLIMIT_TIME = 5
NOEXIST_SET_R SLOWLIMIT_SPEED = 100
NOEXIST_SET_R SLOWLIMIT_SPMIN = 1
NOEXIST_SET_R SLOWLIMIT_SPMAX = 100

.*デバッグ用ロボットモード状態変数
NOEXIST_SET_R debug_status = -1
.*デバッグ用IO待ちタイムアウト無効フラグ
NOEXIST_SET_R FLG_IOWAIT_DEBUG = 0

.*************
.*手動教示用グローバル変数パラメータ
.*CMD_SET_PARAMコマンドで設定する
.*************
NOEXIST_SET_R DATA_TEACHPITCH = 5
NOEXIST_SET_R DATA_TEACHROT = 5
NOEXIST_SET_R DATA_EXTTYPE[0] = 0
NOEXIST_SET_R DATA_EXTTYPE[1] = 0
NOEXIST_SET_R DATA_EXTTYPE[2] = 0
NOEXIST_SET_R DATA_TEACHCOORDINATE = 0
NOEXIST_SET_R DATA_TOOLCUR[1] = 1
NOEXIST_SET_R DATA_TOOLCUR[2] = 1
NOEXIST_SET_R DATA_ACC = 100
NOEXIST_SET_R DATA_DEC = 100
NOEXIST_SET_R DATA_ACCU = 1
NOEXIST_SET_R DATA_IO_TABLENUM = 0
NOEXIST_SET_R DATA_MONSPEED[0] = 100
NOEXIST_SET_R DATA_MONSPEED[1] = 100
NOEXIST_SET_R DATA_MONSPEED[2] = 100

.*************
.*作業管理データ
.*************
NOEXIST_SET_R DATA_EXECUTE = 0
NOEXIST_SET_R DATA_CUR_L2DISP = 0
NOEXIST_SET_R DATA_CUR_L3DISP = 0
NOEXIST_SET_R DATA_CUR_L2REC[1] = 0
NOEXIST_SET_R DATA_CUR_L2REC[2] = 0
NOEXIST_SET_R DATA_CUR_L3REC[1] = 0
NOEXIST_SET_R DATA_CUR_L3REC[2] = 0
NOEXIST_SET_R NOW_MOVE_L3NUM[1] = 0
NOEXIST_SET_R NOW_MOVE_L3NUM[2] = 0
NOEXIST_SET_R TMP_MOVE_L3NUM[1] = 0
NOEXIST_SET_R TMP_MOVE_L3NUM[2] = 0
NOEXIST_SET_R CHG_BEF_MSPEED[1] = 0
NOEXIST_SET_R CHG_BEF_MSPEED[2] = 0
NOEXIST_SET_R CHG_AFT_MSPEED[1] = 0
NOEXIST_SET_R CHG_AFT_MSPEED[2] = 0
.*全作業ステップ数(第2階層数)
NOEXIST_SET_R DATA_L2NUM = 0
.*作業ステップ内のデータ数(第3階層数)
.*DATA_L3NUM[第2階層番号]

.*************
.* 作業グルーピング対応関連
.*************
.* 作業グループ番号
NOEXIST_SET_R DATA_CUR_WORKNO = -999
.* 作業グループ最大数
NOEXIST_SET_R DATA_CUR_MAXNUM = 0
.* 作業グルーピング設定[0:無効, 1:有効]
NOEXIST_SET_R DATA_WSET_ENA = 0
.* 作業グループ番号指定方法[0:信号入力, 1:タブレット設定]
NOEXIST_SET_R DATA_WSET_SPEC = 0
.* 作業グループ番号設定1[作業グループ番号指定方法=0:先頭信号番号]
NOEXIST_SET_R DATA_WSET_SET[1] = 0
.* 作業グループ番号設定2[作業グループ番号指定方法=0:信号数]
NOEXIST_SET_R DATA_WSET_SET[2] = 0
.* 作業グループ番号設定[作業グループ番号指定方法=1:作業グループ番号]
NOEXIST_SET_R data_wset_no = 0

NOEXIST_SET_S $DATA_PGNAME = "MAINEXE"
NOEXIST_SET_S $DATA_CUR_L1NAME = "NO SETTING"

.*通信制御用
NOEXIST_SET_R OPE_COMMAND = 1999
NOEXIST_SET_R OPE_COMMANDPC = 1999
.*コマンド引数最大20個(数が多いためPRESET()関数で生成・初期化)
.*OPE_PARAM[1-20]
.*************
.*コマンド引数用変数初期化(最大20個)
.*************
NOEXIST_SET_R OPE_PARAM[1] = 0
NOEXIST_SET_R OPE_PARAM[2] = 0
NOEXIST_SET_R OPE_PARAM[3] = 0
NOEXIST_SET_R OPE_PARAM[4] = 0
NOEXIST_SET_R OPE_PARAM[5] = 0
NOEXIST_SET_R OPE_PARAM[6] = 0
NOEXIST_SET_R OPE_PARAM[7] = 0
NOEXIST_SET_R OPE_PARAM[8] = 0
NOEXIST_SET_R OPE_PARAM[9] = 0
NOEXIST_SET_R OPE_PARAM[10] = 0
NOEXIST_SET_R OPE_PARAM[11] = 0
NOEXIST_SET_R OPE_PARAM[12] = 0
NOEXIST_SET_R OPE_PARAM[13] = 0
NOEXIST_SET_R OPE_PARAM[14] = 0
NOEXIST_SET_R OPE_PARAM[15] = 0
NOEXIST_SET_R OPE_PARAM[16] = 0
NOEXIST_SET_R OPE_PARAM[17] = 0
NOEXIST_SET_R OPE_PARAM[18] = 0
NOEXIST_SET_R OPE_PARAM[19] = 0
NOEXIST_SET_R OPE_PARAM[20] = 0
NOEXIST_SET_R MFP_PARAM1 = 0
NOEXIST_SET_R MFP_PARAM2 = 0
NOEXIST_SET_R MFP_PARAM3 = 0
NOEXIST_SET_R MFP_PARAM4 = 0
NOEXIST_SET_R MFP_PARAM5 = 0
NOEXIST_SET_R MFP_PARAM6 = 0
NOEXIST_SET_R MFP_PARAM7 = 0
NOEXIST_SET_R MFP_PARAM8 = 0
NOEXIST_SET_R MFP_PARAM9 = 0
NOEXIST_SET_R MFP_PARAM10 = 0
NOEXIST_SET_R MFP_PARAM11 = 0
NOEXIST_SET_R MFP_PARAM12 = 0
NOEXIST_SET_R MFP_PARAM13 = 0
NOEXIST_SET_R MFP_PARAM14 = 0
NOEXIST_SET_R MFP_PARAM15 = 0
NOEXIST_SET_R MFP_PARAM16 = 0
NOEXIST_SET_R MFP_PARAM17 = 0
NOEXIST_SET_R MFP_PARAM18 = 0
NOEXIST_SET_R MFP_PARAM19 = 0
NOEXIST_SET_R MFP_PARAM20 = 0

NOEXIST_SET_R TOOL_DATA_NUM[1] = 999
NOEXIST_SET_R TOOL_DATA_NUM[2] = 999
NOEXIST_SET_R ROBOT_HACC[1,1] = 10
NOEXIST_SET_R ROBOT_HACC[1,2] = 10
NOEXIST_SET_R ROBOT_HACC[2,1] = 10
NOEXIST_SET_R ROBOT_HACC[2,2] = 10

NOEXIST_SET_R data_hand_io[1,1] = 49
NOEXIST_SET_R data_hand_io[1,2] = 50
NOEXIST_SET_R data_hand_io[1,3] = 0
NOEXIST_SET_R data_hand_io[1,4] = 0
NOEXIST_SET_R data_hand_io[2,1] = 65
NOEXIST_SET_R data_hand_io[2,2] = 66
NOEXIST_SET_R data_hand_io[2,3] = 0
NOEXIST_SET_R data_hand_io[2,4] = 0
NOEXIST_SET_R data_hand_type[1] = 1
NOEXIST_SET_R data_hand_type[2] = 1
NOEXIST_SET_R DATA_HAND_CUR[1] = 0
NOEXIST_SET_R DATA_HAND_CUR[2] = 0
NOEXIST_SET_R data_vs_tbnum = 3

.*配列引数=ロボット番号,ツール番号
NOEXIST_SET_L DEF_TOOL[1,1] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L DEF_TOOL[1,2] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L DEF_TOOL[2,1] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L DEF_TOOL[2,2] = TRANS(360,400,0,0,0,0)
.*盤面ランプ点滅用監視タイマ
UTIMER @lamp_flash =0

.*************
.* ログ関連
.*************
.* エラーログ保存有効[0:OFF, -1:ON]
NOEXIST_SET_R LOG_ERROR_ENA = -1
.* エラーログの区切り文字
NOEXIST_SET_S $DELIMITER = "  "
.* 通信ログ保存モード[0:OFF, 1:送信のみ, 2:受信のみ, 3:送受信]
NOEXIST_SET_R LOG_MODE[1] = 1
NOEXIST_SET_R LOG_MODE[2] = 1
.* ログカウンタ初期化
NOEXIST_SET_R LOG_COUNT[1] = 1
NOEXIST_SET_R LOG_COUNT[2] = 1
NOEXIST_SET_R LOG_COUNT[9] = 1
.* ログ最大保存件数
NOEXIST_SET_R LOG_MAX_NUM = 100

.*************
.* 機能切替スイッチ
.*************
.* 原点移動[OFF:直接移動 ON:アーム間干渉回避]
NOEXIST_SET_R ZSW_MODE_HOME = ON
.* AUTO時の緑/赤ボタン（原点復帰）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_GEN = OFF
.* AUTO時の緑ボタン（再開）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_RESTART = OFF
.* AUTO時の緑ボタン（実行）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_START = OFF
.* MANUAL時の緑ボタン（ﾀﾞｲﾚｸﾄﾃｨｰﾁ）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_ROBOTMODE = OFF
.* AUTO時の赤ボタン（エラーリセット）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_ARESET = OFF
.* MANUAL時の赤ボタン（エラーリセット）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_MRESET = OFF
.* MANUAL時の赤ボタン（停止）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_AABORT = OFF
.* MANUAL時の赤ボタン（停止）[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_MABORT = OFF
.* AUTO/MANUALスイッチ[ON:無効、OFF:有効]
NOEXIST_SET_R FLG_EXTIN_TGLSW = OFF
.* 64点目以下のパルス出力[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_PULSE_IO = OFF
.* AUTO/MANUAL切替HOLD時のエラー出力[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_TGLSW_CHGERROR = OFF
.* 原点復帰動作開始前の処理[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_GOHOME_INIT = OFF
.* BASE引き動作後の処理[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_GOHOME_CHK = OFF
.* 原点復帰完了後の処理[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_GOHOME_COMP = OFF
.* 実行開始前の処理[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_BEFORE_EXEC = OFF
.* AUTO時タブレットから停止[OFF:有効、ON:無効]
NOEXIST_SET_R FLG_TAB_ABORT = OFF

.*************
.* 外部I/Oからの操作
.*************
.* 外部原点復帰切替フラグ(AUTO)[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_GENA = OFF
.* 外部原点復帰切替フラグ(MANUAL)[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_GENM = OFF
.* 外部原点復帰信号
NOEXIST_SET_R SIG_EXTIN_GEN = 0
.* 外部実行切替フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_START = OFF
.* 外部実行信号
NOEXIST_SET_R SIG_EXTIN_START = 0
.* 外部再開切替フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_RESTART = OFF
.* 外部再開信号
NOEXIST_SET_R SIG_EXTIN_RESTART = 0
.* 外部ﾀﾞｲﾚｸﾄﾃｨｰﾁ切替フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_ROBOTMODE = OFF
.* 外部ﾀﾞｲﾚｸﾄﾃｨｰﾁ信号
NOEXIST_SET_R SIG_EXTIN_ROBOTMODE = 0
.* 外部エラーリセット切替フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_RESET = OFF
.* 外部エラーリセット信号
NOEXIST_SET_R SIG_EXTIN_RESET = 0
.* 外部停止切替フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R SW_EXTIN_ABORT = OFF
.* 外部停止信号
NOEXIST_SET_R SIG_EXTIN_ABORT = 0

.*************
.* 外部I/O出力
.*************
.* 状態出力切替フラグ[ON:有効、OFF:無効]
.* 状態出力信号
FOR .i = 0 TO robot_status_max
    NOEXIST_SET_R FLG_EXTOUT_STATUS[.i] = OFF
    NOEXIST_SET_R SIG_EXTOUT_STATUS[.i] = 0
END
.* AUTO/MANUAL状態出力フラグ[ON:有効、OFF:無効]
NOEXIST_SET_R FLG_EXTOUT_TGLSW = OFF
.* AUTO状態出力信号
NOEXIST_SET_R EXTOUT_REPEAT = 0
.* MANUAL状態出力信号
NOEXIST_SET_R EXTOUT_TEACH = 0

.END
.PROGRAM update_error(.ret)
;---------------------------------
;機能：エラー状態、表示更新
;引数：エラーコード
;戻値：無し
;---------------------------------
    IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error<>.ret THEN
      CALL error_log(.ret)
    END
    g_last_error = .ret
.END

.PROGRAM ResetCtrllInfo()
;-------------------------------- 
;制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
    FLG_MAIN_RUN = FALSE
    FLG_TABLET_RUN[1]=FALSE
    FLG_TABLET_RUN[2]=FALSE
    FLG_DIRECT_RUN = FALSE
    FLG_MASTER_MOVE = FALSE
    FLG_SLAVE_MOVE = FALSE
    FLG_REQ_MAMODE = FALSE
    FLG_SLAVE_RDY = FALSE
    FLG_SLAVE_PARALLEL_REQ = FALSE
    TCP_RECONNECT_BUSY[0]=FALSE
    TCP_RECONNECT_BUSY[1]=FALSE
    FLG_WAIT_END=FALSE
    FLG_GRAVITYADJ_ACTIVE = FALSE
    ;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
    SIG -EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
    ;暫定スロースタート機能制御
    FLG_SLOWLIMIT=FALSE
    FLG_EXEC_FIRST_MOVE=TRUE
    ;実行条件成立待機中ﾌﾗｸﾞ
    FLG_L2CHK_WAIT = FALSE
.END

.PROGRAM ResetStartInfo()
;-------------------------------- 
;初回起動時だけ実行する制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
    ;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
    IF SYSDATA(ZSIMENV)<>2 THEN
        ;K-ROSET用
        KROSET = FALSE
        ;通信ポート
        TCP_LISTEN_PORT[0] = REAL_TCP_PORT[0]
        TCP_LISTEN_PORT[1] = REAL_TCP_PORT[1]
        ;メッセージOFF=パフォーマンス対策
        ;MESSAGE OFF
        ;外部制御盤入力設定=実機
        EXTIN_START_BUTTON = REAL_START_BUTTON
        EXTIN_STOP_BUTTON = REAL_STOP_BUTTON
        IF FLG_EXTIN_TGLSW<>TRUE THEN
            EXTIN_TEACH_TGLSW = REAL_TEACH_TGLSW
            EXTIN_REPEAT_TGLSW = REAL_REPEAT_TGLSW
        ELSE
            EXTIN_TEACH_TGLSW = OFF_TEACH_TGLSW
            EXTIN_REPEAT_TGLSW = OFF_REPEAT_TGLSW
        END
    ELSE
        IF KROSET==TRUE THEN
            ;アーム間干渉チェック機能有効化
            ZINTFCHK ON
            ;通信ポート(K-ROSET用)
            TCP_LISTEN_PORT[0] = SIM_TCP_PORT[0]
            TCP_LISTEN_PORT[1] = SIM_TCP_PORT[1]
        ELSE
            ;アーム間干渉チェック機能無効化
            ZINTFCHK OFF
            ;通信ポート
            TCP_LISTEN_PORT[0] = REAL_TCP_PORT[0]
            TCP_LISTEN_PORT[1] = REAL_TCP_PORT[1]
        END
        ;衝突・衝撃検知機能無効化
        ZCOLDISABLE 1:ON 
        ZCOLDISABLE 2:ON
        ;外部制御盤入力設定=シミュレータ
        EXTIN_START_BUTTON = SIM_START_BUTTON
        EXTIN_STOP_BUTTON = SIM_STOP_BUTTON
        IF FLG_EXTIN_TGLSW<>TRUE THEN
            EXTIN_TEACH_TGLSW = SIM_TEACH_TGLSW
            EXTIN_REPEAT_TGLSW = SIM_REPEAT_TGLSW
        ELSE
            EXTIN_TEACH_TGLSW = OFF_TEACH_TGLSW
            EXTIN_REPEAT_TGLSW = OFF_REPEAT_TGLSW
        END
    END
    FLG_START_KILLPG = FALSE
    TCP_LISTEN_LOCK = FALSE
    FLG_START_REBOOT=TRUE
    ;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
    SIG -EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
    ;ティーチロック無効化
    ZTPDISCON ON
    ;暫定スロースタート機能制御
    FLG_SLOWLIMIT=FALSE
    FLG_EXEC_FIRST_MOVE=TRUE
    ;衝突検知感度自動調整設定OFF
    CALL chg_colcalflg(OFF)
    ;モニタ速度変更フラグ初期化
    CHG_BEF_MSPEED[1] = 0
    CHG_BEF_MSPEED[2] = 0
    CHG_AFT_MSPEED[1] = 0
    CHG_AFT_MSPEED[2] = 0
    ;モニタ速度保存
    DATA_MONSPEED[0] = MSPEED
.END

.PROGRAM autostart.pc 
;-------------------------------- 
;機能：自動起動プログラム
;引数：無し
;戻値：無し
;--------------------------------
    PRINT "TASKNO=",TASKNO,", autostart.pc() -> CALL noexist_init()"
    CALL noexist_init
    UTIMER @SLOWLIMIT_TIMER = 0
    FLG_EXEC_FIRST_MOVE=TRUE
    SETAPPLIVER $appli_ver_tbl
    DATA_EXECUTE=FALSE
    IF SYSDATA(ZSIMENV)<>2 THEN
        debug_status = -1
    END
    CALL ResetStartInfo
    CALL rebootsystem
.END

.PROGRAM rebootsystem
;-------------------------------- 
;機能：再起動管理、エラーチェック用常時起動プログラム
;引数：無し
;戻値：無し
;-------------------------------- 
    IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
        FLG_TGLSW_REPEAT=TRUE
    ELSE
        FLG_TGLSW_REPEAT=FALSE
    END
    FLG_CYCLE_TIME = FALSE
    IF KROSET==TRUE THEN
        SIGNAL -ix_cycle_time
    END
    WHILE(TRUE)
        IF FLG_START_REBOOT==TRUE THEN
            CALL ResetSystem
        END
        IF FLG_START_KILLPG==FALSE THEN
            IF TASK(1005)<>1 OR TASK(1006)<>1 THEN
                IF DEBUG.PRT.REBOOT==TRUE THEN
                    PRINT "rebootsystem()->.......TASK(1005)<>1 OR TASK(1006)<>1"
                END
                FLG_START_REBOOT=TRUE
            END
        END

        IF FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE THEN
            ;ロボット状態監視
            CALL status_check(.ret)
        END
        
        IF SIG(SIG_EXT_REBOOT)==TRUE THEN
            CALL exec_pg(.ret)
        END
        
        ;AUTO/MANUAL状態出力
        IF FLG_EXTOUT_TGLSW<>FALSE THEN
            IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
                SIGNAL EXTOUT_REPEAT,-EXTOUT_TEACH
            ELSE
                IF SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==OFF THEN
                    SIGNAL -EXTOUT_REPEAT,EXTOUT_TEACH
                ELSE
                    SIGNAL -EXTOUT_REPEAT,-EXTOUT_TEACH
                END
            END
        END
        
        ;ランプ制御
        CALL extout_ctl
        
        ;K-ROSET用(サイクルタイム計測)
        IF KROSET==TRUE THEN
            CALL chk_cycle_time
        END
    END
.END

.PROGRAM extout_ctl()
;-------------------------------- 
;機能：ランプ制御
;引数：無し
;戻値：無し
;--------------------------------
;    CHECK_LAMP_TIME = 0.5; 点滅間隔(sec)
;    CHECK_LAMP_CNT = 3; 接続確認点滅回数
;    CHECK_LAMP_MODE = 0; 点滅モード
    NOEXIST_SET_R .flash_cnt = 0
;
    IF EXOUT_BOTH_FLASH_MODE==TRUE THEN
        ;ﾀﾌﾞﾚｯﾄ通信確認
        .flash_time = CHECK_LAMP_TIME
        IF .flash_cnt==0 THEN
            CASE CHECK_LAMP_MODE OF
                VALUE 1:;交互点滅
                    IF (SIG(EXTOUT_START_BUTTON) XOR SIG(EXTOUT_STOP_BUTTON))==FALSE THEN
                        SIGNAL EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
                        .flash_cnt = 1
                        UTIMER @lamp_flash = 0
                    END
                ANY :;同時点滅
                    IF (SIG(EXTOUT_START_BUTTON) XOR SIG(EXTOUT_STOP_BUTTON)) THEN
                        SIGNAL EXTOUT_START_BUTTON,EXTOUT_STOP_BUTTON
                        .flash_cnt = 1
                        UTIMER @lamp_flash = 0
                    END
            END
        END
        IF CHECK_LAMP_CNT*2<.flash_cnt THEN
            EXOUT_BOTH_FLASH_MODE = FALSE
            SIGNAL -EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
            .flash_cnt = 0
        END
        IF .flash_time<UTIMER(@lamp_flash) THEN
            CASE CHECK_LAMP_MODE OF
                VALUE 1:;交互点滅
                    IF SIG(EXTOUT_START_BUTTON)==ON AND SIG(EXTOUT_STOP_BUTTON)==OFF THEN
                        SIGNAL -EXTOUT_START_BUTTON,EXTOUT_STOP_BUTTON
                    ELSE
                        SIGNAL EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
                    END
                ANY :;同時点滅
                    IF SIG(EXTOUT_START_BUTTON)==ON AND SIG(EXTOUT_STOP_BUTTON)==ON THEN
                        SIGNAL -EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
                    ELSE
                        SIGNAL EXTOUT_START_BUTTON,EXTOUT_STOP_BUTTON
                    END
            END
            .flash_cnt = .flash_cnt+1
            UTIMER @lamp_flash = 0
        END
    ELSE
        ;ロボット状態遷移情報
        IF G_LAST_ERROR<>err_no_error OR (SWITCH(ERROR,1) == ON) OR (SWITCH(ERROR,2) == ON) THEN
            IF G_LAST_ERROR==err_no_error THEN
                IF (SYSDATA(ERROR.CODE,1)<>OFF) AND (SYSDATA(ERROR.CODE,2)<>OFF) THEN;2台同時にエラーコード有り
                    G_LAST_ERROR = err_roboterror[0];ロボット本体異常発生中（2台同時発生中）
                ELSE
                    IF SYSDATA(ERROR.CODE,1)<>OFF THEN;マスタロボットで発生中
                        G_LAST_ERROR = err_roboterror[1];下アーム異常発生中
                    ELSE
                        G_LAST_ERROR = err_roboterror[2];上アーム異常発生中
                    END
                END
            END
            robot_status_out = sta_error
        ELSE
            CASE robot_status OF
                VALUE sta_exe,sta_l2exe,sta_gen,sta_direct,sta_tablet,sta_gravityadj,sta_vscalib:
                    IF (SWITCH(CS ,1)==ON OR TASK(1)==1) OR (SWITCH(CS ,2)==ON OR TASK(2)==1) THEN
                        robot_status_out = robot_status
                    ELSE
                        CALL chk_exe_staus(.exe_status)
                        IF .exe_status<>err_no_error THEN
                            robot_status_out = sta_hold
                        ELSE
                            robot_status_out = sta_nomove
                        END
                    END
                ANY :
                    robot_status_out = robot_status
            END
        END
        FOR .i = 0 TO robot_status_max
            IF .i<>robot_status_out THEN
                IF FLG_EXTOUT_STATUS[.i]<>FALSE THEN
                    SIGNAL -SIG_EXTOUT_STATUS[.i]
                END
            END
        END
        IF FLG_EXTOUT_STATUS[robot_status_out]<>FALSE THEN
            SIGNAL SIG_EXTOUT_STATUS[robot_status_out]
        END
        ;ロボットモード状態によって点灯パターン別け
        IF G_LAST_ERROR<>err_no_error OR robot_status_out==sta_error THEN
            ;エラー発生中
            .flash_time = EXTOUT_FLASHTIME
            SIGNAL -EXTOUT_START_BUTTON
            IF .flash_time<UTIMER(@lamp_flash) THEN
                IF SIG(EXTOUT_STOP_BUTTON)==ON THEN
                    SIGNAL -EXTOUT_STOP_BUTTON
                ELSE
                    SIGNAL EXTOUT_STOP_BUTTON
                END
                UTIMER @lamp_flash = 0
            END
        ELSE
            CASE robot_status_out OF
                VALUE sta_nomove:
                    SIGNAL -EXTOUT_START_BUTTON,EXTOUT_STOP_BUTTON
                VALUE sta_exe,sta_l2exe,sta_direct,sta_tablet,sta_vscalib,sta_gravityadj:
                    .flash_time = EXTOUT_FLASHTIME
                    SIGNAL -EXTOUT_STOP_BUTTON
                    IF ((FLG_L2CHK_WAIT<>FALSE) AND (robot_status_out==sta_exe OR robot_status_out==sta_l2exe)) THEN
                        ;実行条件待ちの場合
                        IF .flash_time<UTIMER(@lamp_flash) THEN
                            IF SIG(EXTOUT_START_BUTTON)==ON THEN
                                SIGNAL -EXTOUT_START_BUTTON
                            ELSE
                                SIGNAL EXTOUT_START_BUTTON
                            END
                            UTIMER @lamp_flash = 0
                        END
                    ELSE
                        SIGNAL EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
                    END
                VALUE sta_hold:
                    .flash_time = EXTOUT_FLASHTIME
                    SIGNAL EXTOUT_STOP_BUTTON
                    IF .flash_time<UTIMER(@lamp_flash) THEN
                        IF SIG(EXTOUT_START_BUTTON)==ON THEN
                            SIGNAL -EXTOUT_START_BUTTON
                        ELSE
                            SIGNAL EXTOUT_START_BUTTON
                        END
                        UTIMER @lamp_flash = 0
                    END
                VALUE sta_gen:
                    .flash_time = EXTOUT_FLASHTIME
                    SIGNAL EXTOUT_START_BUTTON
                    IF .flash_time<UTIMER(@lamp_flash) THEN
                        IF SIG(EXTOUT_STOP_BUTTON)==ON THEN
                            SIGNAL -EXTOUT_STOP_BUTTON
                        ELSE
                            SIGNAL EXTOUT_STOP_BUTTON
                        END
                        UTIMER @lamp_flash = 0
                    END
            END
        END
    END
;動作中のスイッチ切替
    IF FLG_TGLSW_REPEAT==FALSE THEN
        IF SIG(EXTIN_TEACH_TGLSW)==OFF AND SIG(EXTIN_REPEAT_TGLSW)==ON THEN
            IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (DATA_EXECUTE==TRUE) OR (FLG_MASTER_MOVE==TRUE) OR (FLG_SLAVE_MOVE==TRUE) THEN
                IF FLG_TGLSW_CHGERROR<>FALSE THEN
                    CALL update_error(err_extio_change)
                END
                $prm[TASKNO,1] = "-1"
                CALL cmdabort(.ret)
            END
            ;作業再開不可
            CALL updatel2l3info(TRUE,0,0,TRUE)
            ;ロボット状態遷移
            robot_status = sta_nomove
            ;強制的にロボットモード変更
            ROBOT_MODE = MODE_TABLET
            ROBOT_MODE_FLG = OFF
            FLG_TGLSW_REPEAT = TRUE
        END
    ELSE
        IF SIG(EXTIN_TEACH_TGLSW)==ON AND SIG(EXTIN_REPEAT_TGLSW)==OFF THEN
            IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (DATA_EXECUTE==TRUE) OR (FLG_MASTER_MOVE==TRUE) OR (FLG_SLAVE_MOVE==TRUE) THEN
                IF FLG_TGLSW_CHGERROR<>FALSE THEN
                    CALL update_error(err_extio_change)
                END
                $prm[TASKNO,1] = "-1"
                CALL cmdabort(.ret)
            END
            ;作業再開不可
            CALL updatel2l3info(TRUE,0,0,TRUE)
            ;ロボット状態遷移
            robot_status = sta_nomove
            ;強制的にロボットモード変更
            ROBOT_MODE = MODE_TABLET
            ROBOT_MODE_FLG = OFF
            FLG_TGLSW_REPEAT = FALSE
        END
    END
.END

.PROGRAM chk_robot_stop_status
;-------------------------------- 
;機能：ロボット状態を停止に変更
;引数：無し
;戻値：無し
;--------------------------------
    ;動作プログラム実行状態フラグ
    FLG_MAIN_RUN=FALSE
    FLG_TABLET_RUN[1]=FALSE
    FLG_TABLET_RUN[2]=FALSE
    FLG_DIRECT_RUN=FALSE
    ;作業実行フラグ
    DATA_EXECUTE=FALSE
    ;ロボット動作中フラグ
    FLG_MASTER_MOVE=FALSE
    FLG_SLAVE_MOVE=FALSE
    ;ロボットモードONフラグ
    ROBOT_MODE_FLG=FALSE
    ;ロボットモード
    ROBOT_MODE = MODE_TABLET
    IF NO_RESTART_FLG<>FALSE THEN
        ;作業停止ステップ再開不可
        CALL updatel2l3info(TRUE,0,0,TRUE)
        NO_RESTART_FLG = FALSE
    END
    ;ロボット状態遷移
    CALL chk_exe_staus(.exe_status)
    IF .exe_status<>err_no_error THEN
        robot_status = sta_hold
    ELSE
        robot_status = sta_nomove
    END
    ;重力補償自動調整プログラム実行状態
    FLG_GRAVITYADJ_ACTIVE = FALSE
    ;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
    SIG -EXTOUT_START_BUTTON,-EXTOUT_STOP_BUTTON
.END

.PROGRAM status_check(.ret)
;-------------------------------- 
;機能：ロボット状態監視
;引数：なし
;戻値：成否(err_no_error:正常、0以外:異常)
;-------------------------------- 
    .ret = err_no_error
    IF (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(POWER,1)==OFF OR SWITCH(POWER,2)==OFF) THEN
        IF G_LAST_ERROR<>err_motor_off THEN
            IF DEBUG.PRT.REBOOT==TRUE THEN
                    PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(POWER,1)==OFF OR SWITCH(POWER,2)==OFF)"
            END
        END
        .ret = err_emg_stop
    END
    IF (FLG_START_REBOOT==FALSE) AND (((FLG_MAIN_RUN==TRUE) AND (FLG_TABLET_RUN[1]==TRUE) AND (FLG_TABLET_RUN[2]==TRUE)) OR FLG_DIRECT_RUN==TRUE) AND ((SWITCH(CS,1)==OFF) OR (SWITCH(CS,2)==OFF)) AND (FLG_RESTART==FALSE) THEN
        IF (SWITCH(POWER,1)==ON AND SWITCH(POWER,2)==ON) THEN
            IF (FLG_MASTER_MOVE==TRUE) OR ((ROBOT_MODE==MODE_TABLET) AND (ROBOT_MODE_FLG<>FALSE)) OR ((ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE))THEN
                IF G_LAST_ERROR<>err_cs_off THEN
                    IF DEBUG.PRT.REBOOT==TRUE THEN
                        PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(CS,1)==OFF) OR (SWITCH(CS,2)==OFF)"
                    END
                END
                .ret = err_cs_off
            END
        END
    END
    IF (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (G_LAST_ERROR<>err_no_error) THEN
        IF (SWITCH(POWER,1)!=OFF AND SWITCH(POWER,2)!=OFF) THEN
            IF DEBUG.PRT.REBOOT==TRUE THEN
                PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (G_LAST_ERROR<>err_no_error)"
            END
            .ret = G_LAST_ERROR
        END
    END
    ;動作範囲外エラーや干渉回避エラーなどが発生
    IF (SWITCH(ERROR,1) == ON) OR (SWITCH(ERROR,2) == ON) THEN
        IF (SYSDATA(ERROR.CODE,1)<>OFF) AND (SYSDATA(ERROR.CODE,2)<>OFF) THEN;2台同時にエラーコード有り
            IF DEBUG.PRT.REBOOT==TRUE THEN
                PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF AND SYSDATA(ERROR.CODE,2)<>OFF"
            END
            .ret = err_roboterror[0];ロボット本体異常発生中（2台同時発生中）
        ELSE
            IF SYSDATA(ERROR.CODE,1)<>OFF THEN;マスタロボットで発生中
                IF DEBUG.PRT.REBOOT==TRUE THEN
                    PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF == ON"
                END
                .ret = err_roboterror[1];下アーム異常発生中
            ELSE
                IF DEBUG.PRT.REBOOT==TRUE THEN
                    PRINT "status_check()-> SYSDATA(ERROR.CODE,2.)<>OFF == ON"
                END
                .ret = err_roboterror[2];上アーム異常発生中
            END
        END
    END
    
    ;即応答コマンド実行中等にエラーが発生した場合はここから即応答する
    ;pccom関数内だと自動リセット後で判定できない可能性有
    IF .ret <> err_no_error THEN
        ;衝突検知感度自動調整設定OFF
        CALL chg_colcalflg(OFF)
        ;1台ロボットが停止した場合を考慮してHOLDする
        MC HOLD 1:
        MC HOLD 2:
        IF DATA_EXECUTE==TRUE THEN
            CALL update_holdpos
        END
        CALL update_error(.ret)
        IF (FLG_MASTER_MOVE==TRUE) THEN
            IF CMD_WAIT_TYPE[OPE_COMMAND]==CMD_TYPE_WAIT THEN
                CALL sendresp(OPE_COMMAND,"",.ret)
                IF DEBUG.PRT.REBOOT==TRUE THEN
                    PRINT "status_check()-> Detected robot-error while moving robot.so execute sendresp()."
                END
            END
        END
        CALL reset_mon_sp(ROBOT_ALL); モニタ速度を変更している場合は元に戻す
        CALL chk_robot_stop_status
    END
.END

.PROGRAM ResetSystem
;-------------------------------- 
;システムリセット 
;引数：無し
;戻値：無し
;-------------------------------- 
    ;ロボット状態初期化
    CALL ResetCtrllInfo
    ;エラー状態を一旦解除する
    G_LAST_ERROR = err_no_error
    ;PCプログラムは必ず起動する(停止しない)
    CALL BootPCProgram(.ret)
    IF DEBUG.PRT.CORE==TRUE THEN
        PRINT "->ResetSystem() System change to READY status."
    END
    FLG_START_REBOOT = FALSE
    ;制御電源投入直後のロボット状態を通知する
    CALL status_check(.ret)
.END

.PROGRAM RdyBoot(.flg_motor,.ret)
;-------------------------------- 
;動作プログラム実行(再起動)準備、モータ停止状態遷移
;引数：準備にモータ電源ON処理含む(TRUE/FALSE)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .time_out = BOOT_TIMEOUT
    ;エラー状態を一旦解除する
    G_LAST_ERROR = err_no_error
    IF SIG(SIG_EMG_OUTPUT)==ON THEN
        PRINT "->RdyBoot() Need to clear EMG-STOP button." 
        .ret=err_emg_on
        CALL update_error(.ret)
        RETURN
    END
    
    ;状態監視プログラム(status_check関数)でエラーが発生しないようにフラグ変更
    CALL chk_robot_stop_status
    
    IF SWITCH(REPEAT,1)==OFF OR SWITCH(REPEAT,2)==OFF THEN
        PRINT "->RdyBoot() Need to change repeat mode."
        .ret=err_repeat
        CALL update_error(.ret)
        RETURN
    END
    IF SWITCH(TEACH_LOCK,1)==ON OR SWITCH(TEACH_LOCK,2)==ON THEN
        PRINT "->RdyBoot() Need to unlock teach-lock button."
        .ret=err_teach_lock
        CALL update_error(.ret)
        RETURN
    END
    
    CALL exec_alone(.ret)
    IF .ret<>err_no_error THEN
        PRINT "RdyBoot()-> Error ocured,When called exec_alone(.ret)-function"
        RETURN
    END

    UTIMER .@NowTime = 0 
    DO
        MC HOLD 
        IF UTIMER(.@NowTime)>.time_out THEN 
            PRINT "->RdyBoot() Can NOT stop main program."
            .ret=err_main_stop
            CALL update_error(.ret)
            RETURN
        END
    UNTIL ((SWITCH(CS,1)==OFF) AND ((TASK(1)==0) OR (TASK(1)==2)) )
    
    IF DEBUG.PRT.CORE==TRUE THEN
        PRINT "->RdyBoot() Kill pg for Robot 1:."
    END
    MC KILL 
    
    UTIMER .@NowTime = 0 
    DO
        MC HOLD 2:
        IF UTIMER(.@NowTime)>.time_out THEN 
            PRINT "->RdyBoot() Can NOT stop main program."
            .ret=err_main_stop
            CALL update_error(.ret)
            RETURN
        END
    UNTIL ((SWITCH(CS,2)==OFF) AND ((TASK(2)==0) OR (TASK(2)==2)) )
    
    IF DEBUG.PRT.CORE==TRUE THEN
        PRINT "->RdyBoot() Kill pg for Robot 2:."
    END
    MC KILL 2: 

    ;エラーOFF 
    UTIMER .@NowTime = 0 
    DO 
        MC ERESET 1:
        IF UTIMER(.@NowTime)>.time_out THEN 
            PRINT "->RdyBoot() Can NOT error reset."
            .ret=err_errreset
            CALL update_error(.ret)
            RETURN
        END 
    UNTIL (SWITCH(ERROR,1)==OFF) 

    UTIMER .@NowTime = 0 
    DO 
        MC ERESET 2:
        IF UTIMER(.@NowTime)>.time_out THEN 
            PRINT "->RdyBoot() Can NOT error reset."
            .ret=err_errreset
            CALL update_error(.ret)
            RETURN
        END 
    UNTIL (SWITCH(ERROR,2)==OFF) 

    IF .flg_motor==TRUE THEN
        UTIMER .@NowTime = 0
        DO
            MC ZPOWER ON
            IF UTIMER(.@NowTime)>POWER_TIMEOUT THEN
                PRINT "->RdyBoot() Can NOT motor-on."
                .ret=err_poweron
                CALL update_error(.ret)
                RETURN
            END
            TWAIT ascycle
        UNTIL (SWITCH(POWER,1)==ON AND SWITCH(POWER,2)==ON)
    END
    COLRON 1:
    COLRJON 1:
    COLRON 2:
    COLRJON 2:
.END

.PROGRAM ExecMain(.robot_mode,.robot_mode_flg,.ret)
;-------------------------------- 
;動作プログラム実行(初期化)
;引数：ロボットモード(0:タブレット、1:ダイレクト)、プログラム実行要否フラグ(ON/OFF)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .time_out = BOOT_TIMEOUT
    ;エラー状態を一旦解除する
    G_LAST_ERROR = err_no_error
    ;作業継続要求を一旦解除する
    FLG_MASTER_CON=FALSE
    ;ロボット状態初期化
    CALL ResetCtrllInfo
    
    ;動作プログラム実行準備
    CALL RdyBoot(TRUE,.ret)
    IF .ret<>err_no_error THEN
        PRINT "RdyBoot()-> Error ocured,When called RdyBoot(TRUE,.ret)-function"
        RETURN
    END

    UTIMER .@NowTime = 0
    .exec_pg=FALSE
    IF (.robot_mode==MODE_DIRECT) AND (.robot_mode_flg<>FALSE) THEN
        MC EXECUTE 1: SAVMOD
        ;ロボット状態遷移
        robot_status = sta_direct
        .exec_pg=TRUE
    END
    IF (.robot_mode<>MODE_DIRECT) THEN
        MC EXECUTE 1: main
        ;ロボット状態遷移
        IF .robot_mode_flg<>FALSE THEN
            robot_status = sta_tablet
        END
        .exec_pg=TRUE
    END
    IF .exec_pg==FALSE THEN
        PRINT "ExecMain()-> MASTER-ROBOT dont execute program."
        GOTO 10
    END
    DO
    UNTIL((SWITCH(CS,1)==ON) OR UTIMER(.@NowTime)>.time_out)
    ;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
    ;MC/ERR .err_code = MC EXECUTE 1: main
    ;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
    IF SWITCH(CS,1)==OFF THEN 
        PRINT "Can NOT execute program on MASTER-ROBOT."
        .ret=err_main_start
        CALL update_error(.ret)
        RETURN
    END
10
    UTIMER .@NowTime = 0 
    IF (.robot_mode==MODE_DIRECT) AND (.robot_mode_flg<>FALSE) THEN
        MC EXECUTE 2: SAVMOD
        .exec_pg=TRUE
    END
    IF (.robot_mode<>MODE_DIRECT) THEN
        MC EXECUTE 2: sub
        .exec_pg=TRUE
    END
    IF .exec_pg==FALSE THEN
        PRINT "ExecMain()-> SLAVE-ROBOT dont execute program."
        RETURN
    END
    DO
    UNTIL((SWITCH(CS,2)==ON) OR UTIMER(.@NowTime)>.time_out)
    ;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
    ;MC/ERR .err_code = MC EXECUTE 2: sub 
    ;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
    IF SWITCH(CS,2)==OFF THEN 
        PRINT "Can NOT execute program on SLAVE-ROBOT."
        .ret=err_main_start
        CALL update_error(.ret)
        RETURN
    END
.END

.PROGRAM BootPCProgram(.ret)
;-------------------------------- 
;PCプログラム再起動(PCプログラムは停止しない方針に変更)
;引数：無し
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .time_out = BOOT_TIMEOUT

    ;**********動作命令用*************

    IF TASK(1005)<>1 THEN
        UTIMER .@NowTime = 0
        DO
            PCEX 5: pccom,-1
            IF UTIMER(.@NowTime)>.time_out THEN
                .ret = err_pccom_start
                CALL update_error(.ret)
                RETURN
            END
            TWAIT 0.5
        UNTIL TASK(1005)==1
    END
    
    ;**********非動作命令用*************
    
    IF TASK(1006)<>1 THEN
        UTIMER .@NowTime = 0
        DO
            PCEX 6: pccompc,-1
            IF UTIMER(.@NowTime)>.time_out THEN
                .ret = err_pccom_start
                CALL update_error(.ret)
                RETURN
            END
            TWAIT 0.5
        UNTIL TASK(1006)==1
    END
    
.END

.PROGRAM reset_error(.ret)
;-------------------------------- 
;動作プログラム実行(再起動)準備、モータ停止状態遷移
;引数：準備にモータ電源ON処理含む(TRUE/FALSE)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .time_out = BOOT_TIMEOUT
    ;エラー状態を一旦解除する
    G_LAST_ERROR = err_no_error
    IF SIG(SIG_EMG_OUTPUT)==ON THEN
        PRINT "->reset_error() Need to clear EMG-STOP button."
        .ret=err_emg_on
        CALL update_error(.ret)
        RETURN
    END
    ;操作パネルの状態を確認
    IF SWITCH(REPEAT,1)==OFF OR SWITCH(REPEAT,2)==OFF THEN
        PRINT "->reset_error() Need to change repeat mode."
        .ret=err_repeat
        CALL update_error(.ret)
        RETURN
    END
    IF SWITCH(TEACH_LOCK,1)==ON OR SWITCH(TEACH_LOCK,2)==ON THEN
        PRINT "->reset_error() Need to unlock teach-lock button."
        .ret=err_teach_lock
        CALL update_error(.ret)
        RETURN
    END
    ;エラーOFF(下アーム)
    UTIMER .@NowTime = 0
    DO
        MC ERESET 1:
        IF UTIMER(.@NowTime)>.time_out THEN
            PRINT "->reset_error() Can NOT error reset."
            .ret=err_errreset
            CALL update_error(.ret)
            RETURN
        END
    UNTIL (SWITCH(ERROR,1)==OFF)
    ;エラーOFF(上アーム)
    UTIMER .@NowTime = 0
    DO
        MC ERESET 2:
        IF UTIMER(.@NowTime)>.time_out THEN
            PRINT "->reset_error() Can NOT error reset."
            .ret=err_errreset
            CALL update_error(.ret)
            RETURN
        END
    UNTIL (SWITCH(ERROR,2)==OFF)
    ;モータON
    UTIMER .@NowTime = 0
    DO
        MC ZPOWER ON
        IF UTIMER(.@NowTime)>POWER_TIMEOUT THEN
            PRINT "->reset_error() Can NOT motor-on."
            .ret=err_poweron
            CALL update_error(.ret)
            RETURN
        END
        TWAIT ascycle
    UNTIL (SWITCH(POWER,1)==ON AND SWITCH(POWER,2)==ON)
.END

.PROGRAM chk_cycle_time()
;-------------------------------- 
;サイクルタイム計測(K-ROSET用)
;引数：無し
;戻値：無し
;-------------------------------- 
    IF FLG_CYCLE_TIME==FALSE THEN
        IF SIG(ix_cycle_time) THEN
            FLG_CYCLE_TIME = TRUE
            UTIMER .@cycle_time = 0
        END
    ELSE
        IF SIG(-ix_cycle_time) THEN
            FLG_CYCLE_TIME = FALSE
            TYPE 6: "cycle_time =",UTIMER(.@cycle_time)," sec"
        END
    END
.END

.REALS
.*************
.* K-ROSET関連
.*************
.* K-ROSETフラグ[OFF:KMTerm等, ON:K-ROSET]
  KROSET = 0
.* 通信ポート
  REAL_TCP_PORT[0] = 60001
  REAL_TCP_PORT[1] = 60003
  SIM_TCP_PORT[0] = 60001
  SIM_TCP_PORT[1] = 60003
.END
.PROGRAM main
;---------------------------------
;機能：動作プログラム(マスター)
;引数：無し
;戻値：無し
;-------------------------------- 
    .ret = g_last_error
    .$res=""
    IF TASKNO==PG_MASTER THEN
        IF DEBUG.PRT.MAIN==ON THEN
            PRINT "main()-> Booted main program. This program working in ROBOT-MASTER."
        END
    ELSE
        PRINT "main()-> Booted main program in BAD-TASK. TASKNO=",TASKNO
        RETURN
    END
    
    IF (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE) THEN
        IF DEBUG.PRT.MAIN==ON THEN
            PRINT "main()-> Done main program. ROBOT_MODE=",ROBOT_MODE,",ROBOT_MODE_FLG=",ROBOT_MODE_FLG
        END
        GOTO 10
    END

    CALL exec_alone(.ret)
    ;ダイレクトティーチモード強制解除
    SAEND
    SAENVCHKON
999
    ;初期化：共通処理
     CALL chg_move_param(0,100,100,100,1,.ret)
    ;初期化：ロボット別
    FLG_TABLET_RUN[1]=TRUE

    ;スレーブロボット動作準備完了待ち
    IF FLG_TABLET_RUN[2]==FALSE THEN
        UTIMER .@NowTime = 0 
        DO
            IF UTIMER(.@NowTime)>WAIT_SLAVE_TIMEOUT THEN
                GOTO 10
            END
            IF DEBUG.PRT.MAIN==ON THEN
                PRINT "main()-> TASKNO=",TASKNO,",WAITING... SLAVE-ROBOT still not booted.OPE_COMMAND=",OPE_COMMAND
            END
        UNTIL(FLG_TABLET_RUN[2]==TRUE)
        IF DEBUG.PRT.MAIN==ON THEN
            PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 1"
        END
    ELSE
        IF DEBUG.PRT.MAIN==ON THEN
            PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 2"
        END
    END
    SYS_FORCE_CMODE=FALSE
    SMODE_START = FALSE
    FLG_MASTER_MOVE = FALSE
    FLG_REQ_MAMODE = FALSE
    FLG_MAIN_RUN = TRUE
    FLG_DIRECT_RUN = FALSE
    
    ;コマンド実行指示待ち
    DO
        IF (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE) THEN
            ;プログラム終了後status_check関数が反応してエラー状態に遷移する
            PRINT "main()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
            GOTO 10
        END
    UNTIL(FLG_MASTER_MOVE==TRUE)
    
    ;コマンド実行
    IF FLG_MASTER_CON==TRUE THEN
        ;マスター作業再開
        ;ロボット状態遷移
        IF flg_single_move==FALSE THEN
            robot_status = sta_exe
        ELSE
            robot_status = sta_l2exe
        END
        IF DEBUG.PRT.MAIN==ON THEN
            PRINT "main()->OPE_COMMAND=",OPE_COMMAND
            PRINT "main()->マスター動作を再実行します。DATA_CUR_L2REC[ROBOT_MASTER]=",DATA_CUR_L2REC[ROBOT_MASTER]
            PRINT "main()->マスター動作を再実行します。DATA_CUR_L3REC[ROBOT_MASTER]=",DATA_CUR_L3REC[ROBOT_MASTER]
        END
        .l2num=DATA_CUR_L2REC[ROBOT_MASTER]
        .l3num=DATA_CUR_L3REC[ROBOT_MASTER]
        IF .l2num==0 AND .l3num==0 THEN
            IF DEBUG.PRT.MAIN==ON THEN
                PRINT "main()->.l2num and .l3num are Zero for MASTER ROBOT!."
            END
            FLG_MASTER_CON=FALSE
            GOTO 10
        END
        CALL l2exec(.l2num,.l3num,.ret)
        IF .ret==err_no_error THEN
            IF FLG_SINGLE_MOVE==FALSE THEN
                DATA_EXECUTE=TRUE
                IF DEBUG.PRT.MAIN==ON THEN
                    PRINT "main()->START cmdexe() after RESTART-command."
                END
                ;作業継続用情報初期化(マスター、スレーブ両方)
                CALL updatel2l3info(FALSE,0,0,FALSE)
                ;引き続き作業を続行する
                $prm[TASKNO,0]=$ENCODE(CMD_EXE_START)
                $prm[TASKNO,1]="0"
                $prm[TASKNO,2]="1"
                $prm[TASKNO,3]="1234"
                CALL cmdexecore(.ret)
            ELSE
                ;個別実行再開完了後は再開不可
                CALL updatel2l3info(TRUE,0,0,TRUE)
                robot_status = sta_nomove
            END
        END
    ELSE
        ;通常コマンド実行
        CALL cmdmain(OPE_COMMAND,.$res,.ret)
    END
    CALL update_error(.ret)
10
    ;終了処理
    ;完全初期化後のエラー回避
    IF OPE_COMMAND<>1999 THEN
        ;動作完了応答
        IF CMD_WAIT_TYPE[OPE_COMMAND]==CMD_TYPE_WAIT THEN
            BREAK
            CALL sendresp(OPE_COMMAND,.$res,.ret)
        END
    END
    ;タブレットティーチモード中はプログラムを終了しない
    IF (ROBOT_MODE==MODE_TABLET) AND (ROBOT_MODE_FLG<>FALSE) THEN
        GOTO 999
    END
    FLG_MAIN_RUN = FALSE
    DATA_EXECUTE = FALSE
    FLG_MASTER_MOVE = FALSE
    FLG_TABLET_RUN[1]=FALSE
.END
.PROGRAM sub
;---------------------------------
;機能：動作プログラム(スレーブ)
;引数：無し
;戻値：無し
;-------------------------------- 
    .ret = g_last_error
    .$res=""
    IF TASKNO==PG_SLAVE THEN
        IF DEBUG.PRT.SUB==ON THEN
            PRINT "sub()-> Booted sub program. This program working in ROBOT-MASTER."
        END
    ELSE
        PRINT "sub()-> Booted sub program in BAD-TASK. TASKNO=",TASKNO
        RETURN
    END

    IF (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE) THEN
        IF DEBUG.PRT.SUB==ON THEN
            PRINT "sub()-> Done sub program. ROBOT_MODE=",ROBOT_MODE,",ROBOT_MODE_FLG=",ROBOT_MODE_FLG
        END
        GOTO 10
    END

    CALL exec_alone(.ret)
    ;ダイレクトティーチモード強制解除
    SAEND
    SAENVCHKON
;
    FLG_SLAVE_MOVED = FALSE; 動作済みフラグ
    SYN_MODE_END = FALSE; 同期終了フラグ
999
    ;初期化：共通処理
    IF FLG_SLAVE_MOVED==FALSE THEN
        CALL chg_move_param(0,100,100,100,1,.ret)
    END
    ;初期化：ロボット別
    FLG_TABLET_RUN[2]=TRUE
    FLG_SLAVE_RDY = FALSE
    FLG_SLAVE_MOVE = FALSE
    
    ;マスターロボット動作準備完了待ち
    IF FLG_TABLET_RUN[1]==FALSE THEN
        UTIMER .@NowTime = 0 
        DO
            IF UTIMER(.@NowTime)>WAIT_MASTE_TIMEOUT THEN
                GOTO 10
            END
            IF DEBUG.PRT.SUB==ON THEN
                PRINT "sub()-> TASKNO=",TASKNO,",WAITING... MASTER-ROBOT still not booted."
            END
        UNTIL(FLG_TABLET_RUN[1]==TRUE)
        IF DEBUG.PRT.SUB==ON THEN
            PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 1"
        END
    ELSE
        IF DEBUG.PRT.SUB==ON THEN
            PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 2"
        END
    END

    ;コマンド実行指示待ち
    DO
        IF (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE) THEN
            ;プログラム終了後status_check関数が反応してエラー状態に遷移する
            IF DEBUG.PRT.SUB==ON THEN
                PRINT "sub()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
            END
            GOTO 10
        END
        ;マスター動作プログラム終了に併せてスレーブロボットの動作を終了する
        IF FLG_TABLET_RUN[1]==FALSE THEN
            IF DEBUG.PRT.SUB==ON THEN
                PRINT "sub()-> MSTER ROBOT IS NOT BOOTING...OPE_COMMAND=",OPE_COMMAND
            END
            GOTO 10
        END
        ;同期終了処理
        IF SYN_MODE_END==TRUE THEN
            SYN_MODE_END = FALSE
            ALONE
        END
    UNTIL(FLG_SLAVE_MOVE==TRUE)
    
    ;コマンド実行
    ;実行タイミングはMASTERが指示、エラー処理はMASTERで実行
    CASE OPE_COMMAND OF
        VALUE CMD_EXE_GEN:
            ;原点番号設定
            .home_no=VAL($OPE_PARAM[3])
            ;ロボット番号設定
            IF ZSW_MODE_HOME==OFF THEN
                .rno=ROBOT_SLAVE
            ELSE
                .rno=VAL($OPE_PARAM[1])
            END
            ;仕様変更、速度指定無効化、常時固定値
            .sp=SAFTY_MOVE_SP
            CALL gen_core(.rno,.home_no,.sp,.ret)
            BREAK
        VALUE CMD_EXE_START,CMD_EXE_MOVE,CMD_EXE_TEACH,CMD_EXE_L2EXE,CMD_EXE_RESTART:
            IF FLG_SLAVE_PARALLEL_REQ==FALSE THEN
                ;動作コマンドのみサポート、その他(IO待ち、変更など）はMASTERで実行
                CALL submove(.ret)
                CALL update_error(.ret)
            ELSE
                 BREAK; 並列動作開始の為BREAK
                ;並列スレーブロボット連続作業実行
                .l2num=GS_l2num
                .l3num=GS_l3num
                IF .l2num==0 AND .l3num==0 THEN
                    IF DEBUG.PRT.SUB==ON THEN
                        PRINT "sub()->.l2num and .l3num are Zero for SLAVE ROBOT!."
                    END
                    FLG_SLAVE_CON=FALSE
                    GOTO 10
                END
                ;マスターが実行済み部分をスキップして処理開始
                IF FLG_SLAVE_CON==TRUE THEN
                    CALL l2exec(.l2num,.l3num,.ret)
                    CALL update_error(.ret)
                ELSE
                    FOR .l2num=GS_l2num TO DATA_L2NUM
                        CALL l2exec(.l2num,.l3num,.ret)
                        IF .ret<>err_no_error THEN
                            IF .ret==err_slave_actend THEN
                                ;正常終了処理
                                .ret=err_no_error
                                GOTO 10
                            ELSE
                                ;異常終了処理
                                CALL update_error(.ret)
                                GOTO 10
                            END
                        END
                        ;途中作業以降は先頭から実行
                        .l3num=1
                    END
                END
            END
            VALUE CMD_EXE_GRAVITYADJ:
                IF DEBUG.PRT.SUB==ON THEN
                    PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_GRAVITYADJ"
                END
                .mode=GS_GRAVITY_MODE
                .setval=GS_GRAVITY_SETVAL
                CALL gravityadj_core(ROBOT_SLAVE,.mode,.setval,.ret)
                CALL update_error(.ret)
            VALUE CMD_EXE_VSCALIB:
                IF DEBUG.PRT.SUB==ON THEN
                    PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VSCALIB"
                END
                .rno=GS_RNO
                .camno=GS_CAMNO
                .calno=GS_CALNO
                .camtype=GS_CAMTYPE
                POINT .target=GS_POSXYZR1
                .len=GS_LEN
                .height=GS_HEIGHT
                POINT .tool_p=GS_TOOLP
                CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
                CALL update_error(.ret)
            VALUE CMD_EXE_VCALCHK:
                IF DEBUG.PRT.SUB==ON THEN
                    PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VCALCHK"
                END
                .rno=GS_RNO
                .camno=GS_CAMNO
                .height=GS_HEIGHT
                CALL vision_excalchk(.rno,.camno,.height,.ret)
                CALL update_error(.ret)        
            ANY
            IF DEBUG.PRT.SUB==ON THEN
                PRINT "sub()-> Error occuerd. You try to execute unsupport command.OPE_COMMAND=",OPE_COMMAND 
            END
            .ret=err_cmd_type
    END
10
    ;終了処理
    ;マスタープログラム終了検知までsubプログラムを終了しない(sub関数先頭ループ処理に検知実装有)
    IF FLG_MAIN_RUN<>FALSE THEN
        GOTO 999
    ELSE
        FLG_SLAVE_MOVE = FALSE
    END
    FLG_TABLET_RUN[2]=FALSE
    FLG_MAIN_RUN = FALSE
.END

.PROGRAM submove(.ret)
;---------------------------------
;機能：スレーブロボット専用指定位置移動
;引数：無し
;戻値：成否
;メモ：動作に必要な情報はマスター側で生成する
;---------------------------------
    .ret = err_no_error
    ;同期モード動作
    IF FLG_REQ_MAMODE==TRUE THEN
        IF DEBUG.PRT.SUB==TRUE THEN
            PRINT "->submove() SLAVE ROBOT ....................."
        END
        IF SYN_MODE_START==TRUE THEN; 協調動作開始時のみ実行
          SYN_MODE_START = FALSE
          BREAK; 同期開始の為BREAK
          IF FLG_SLAVE_MOVED==FALSE THEN
            JMOVE #HERE
            FLG_SLAVE_MOVED = TRUE
          END
          ;マスタ側にスレーブが協調モードに入ることを通知する
          ;協調動作に入った後のハンドシェイクはASシステムが行うので考慮不要とのこと
          FLG_SLAVE_RDY = TRUE
          SLAVE
        END
        RETURN
    END
    ; 動作関連パラメータ設定
    CALL chg_move_param(GS_SP_MODE,GS_SP,GS_ACCEL,GS_DECEL,GS_ACCURACY,.ret)
    IF .ret<>err_no_error THEN
        RETURN
    END
    ;ツール変換値設定
    IF GS_MODE<>MODE_JT THEN
        IF DATA_TOOLCUR[ROBOT_SLAVE]<>GS_TOOL THEN
            DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_SLAVE,GS_TOOL]
            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
            IF DEBUG.PRT.SUB==TRUE THEN
                PRINT "->sub() CHANGE TOOL(DEF_TOOL) TO .rno=",ROBOT_SLAVE," .tno[]=",GS_TOOL
                PRINT "->sub() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,2)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,2)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,2))
            END
            ZL3LINKX 2: .toolprm[1]
            ZL3LINKX2 2: .toolprm[2]
            ZL3LINKH1 2: .toolprm[3]
            DATA_TOOLCUR[ROBOT_SLAVE]=GS_TOOL
            IF DEBUG.PRT.SUB==TRUE THEN
                PRINT "->sub() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,2)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,2)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,2))
            END
        END
    END
    ;移動動作
    IF GS_TYPE==MODE_JMOVE THEN
        IF GS_MODE==MODE_JT THEN
            JMOVE #G_MPOS
        ELSE
            DECOMPOSE .p[1]=G_MPOS
            .p[6]=G_EXT1
            ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
            JMOVE .#tpos;変換値指定はできない
        END
    ELSE
        IF GS_MODE==MODE_JT THEN
            ZL3LMOVE #G_MPOS,1,1;引数は各軸値
        ELSE
            DECOMPOSE .p[1]=G_MPOS
            .p[6]=G_EXT1
            ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
            ZL3LMOVE .#tpos,1,1;引数は各軸値
        END
    END
    IF FLG_SLAVE_MOVED==FALSE THEN
      FLG_SLAVE_MOVED = TRUE
    END
    ; スレーブロボットの動作中の作業番号を記憶(マスターから起動する為マスター側で記憶しスレーブ側の記憶は消去)
    NOW_MOVE_L3NUM[ROBOT_MASTER] = TMP_MOVE_L3NUM[ROBOT_SLAVE]
    NOW_MOVE_L3NUM[ROBOT_SLAVE] = 0
    IF GS_BFLAG==TRUE THEN
      BREAK
    END
.END
.PROGRAM gen_core(.rno,.home_no,.sp,.ret)
;-------------------------------- 
;機能：ホーム移動コア処理
;引数：ホーム番号、動作速度
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  IF debug.prt.gen==ON THEN
    PRINT "gen_core()-> TASKNO=",TASKNO,".rno=",.rno,".home_no=",.home_no,",.sp=",.sp
  END
  CALL chg_sp(.sp,.ret)
  IF .ret<>err_no_error THEN
    CALL update_error(.ret)
    RETURN
  END
  IF ZSW_MODE_HOME==ON AND .rno<>robot_master AND .rno<>robot_slave THEN
    IF TASKNO==pg_master THEN ;マスターの処理
      CALL gohome_main(.home_no,.ret);原点復帰ﾊﾟﾀｰﾝ選択
      CALL cont_timing;マスタとスレーブのタイミングを合わせ
      IF .ret<>err_no_error THEN
        CALL update_error(.ret)
        RETURN
      END
      CALL gohome_move(pg_master,gohome_ptn,.home_no,.ret);BASE引き動作
    ELSE ;スレーブの処理
      CALL cont_timing;マスタとスレーブのタイミングを合わせ
      IF gohome_ptn==0 THEN
        RETURN
      END
      CALL gohome_move(pg_slave,gohome_ptn,.home_no,.ret);BASE引き動作
    END
    IF .ret<>err_no_error THEN
      CALL update_error(.ret)
      RETURN
    END
  ELSE
    HOME (.home_no)
  END
.END
.PROGRAM gohome_main(.home_no,.ret)
;-------------------------------- 
;機能：原点復帰ﾊﾟﾀｰﾝ選択
;引数：なし
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  gohome_ptn = 0 ;原点復帰ﾊﾟﾀｰﾝﾘｾｯﾄ
  DECOMPOSE 1: .jho1[1] = #HOME(.home_no)
  DECOMPOSE 1: .jhe1[1] = #S_HERE(1)
  DECOMPOSE 1: .lhe1[1] = S_HERE(1)
  DECOMPOSE 2: .jho2[1] = #HOME(.home_no)
  DECOMPOSE 2: .jhe2[1] = #S_HERE(2)
  DECOMPOSE 2: .lhe2[1] = S_HERE(2)
  POINT .null1 = TRANS(0,0,.jho1[3],0,0,0)
  POINT .null2 = TRANS(0,0,.jho2[3],0,0,0)
  POINT .here1 = TRANS(.lhe1[1],.lhe1[2],.jho1[3],.lhe1[4],.lhe1[5],.lhe1[6])
  POINT .here2 = TRANS(.lhe2[1],.lhe2[2],.jho2[3],.lhe2[4],.lhe2[5],.lhe2[6])
  .dist1 = DISTANCE(.here1,.null1)
  .dist2 = DISTANCE(.here2,.null2)
  POINT .base1 = TRANS(((chk_gohome[1]-5)*.lhe1[1])/.dist1,((chk_gohome[1]-5)*.lhe1[2])/.dist1,.jho1[3],.lhe1[4],.lhe1[5],.lhe1[6]);BASEに引いた点
  POINT .base2 = TRANS(((chk_gohome[2]-5)*.lhe2[1])/.dist2,((chk_gohome[2]-5)*.lhe2[2])/.dist2,.jho2[3],.lhe2[4],.lhe2[5],.lhe2[6]);BASEに引いた点
;●原点復帰不可状態の処理
  IF ABS(.jho1[1]-.jhe1[1])>360 OR ABS(.jho2[1]-.jhe2[1])>360 THEN ;1軸現在値が回転しすぎ
    .ret = err_gen_jt1 ;1軸回転量異常
    RETURN
  END
  IF (.jho1[2]<0 AND .jhe1[2]>=0) OR (.jho1[2]>=0 AND .jhe1[2]<0) OR (.jho2[2]<0 AND .jhe2[2]>=0) OR (.jho2[2]>=0 AND .jhe2[2]<0) THEN ;2軸現在値の符号が原点と逆
    .ret = err_gen_jt2 ;2軸回転量異常
    RETURN
  END
  IF (.jho1[2]>0 AND .jho2[2]>0) OR (.jho1[2]<0 AND .jho2[2]<0) OR .jho1[2]==0 OR .jho2[2]==0 THEN ;原点姿勢の異常(両ｱｰﾑの2軸が同一方向を向いている。2軸値の原点角度が0°)
    .ret = err_gen_pos ;原点姿勢異常
    RETURN
  END
;●肘間の角度を計算
  CALL chg_jt1rad(.jhe1[1],.jhe1[101]);下ｱｰﾑ側 1軸の角度を0〜360°内に変換
  CALL chg_jt1rad(.jhe2[1],.jhe2[101]);上ｱｰﾑ側 1軸の角度を0〜360°内に変換
  IF (.jhe1[101]<.jhe2[101] AND .jhe1[2]<0 AND .jhe2[2]>=0) OR (.jhe1[101]>.jhe2[101] AND .jhe2[2]<0 AND .jhe1[2]>=0) THEN
    .jt2rad = ABS(.jhe1[101]-.jhe2[101])
  ELSE
    .jt2rad = 360-ABS(.jhe1[101]-.jhe2[101])
  END
;●原点復帰パターンの選択
  IF .dist1<chk_gohome[1] AND .dist2<chk_gohome[2] THEN ;両ｱｰﾑが既にBASEに引いている
    gohome_ptn = 1 ;★その場から原点復帰
    GOTO fin
  END
  IF (INRANGE(.base1,#S_HERE(1))<>0) THEN ;下ームが動作範囲外に近い
    IF .jt2rad>chk_jt1_rad THEN ;肘間隔が広い
      gohome_ptn = 2;★上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑを2軸曲げる
      GOTO fin
    ELSE ;肘間隔が狭い
      gohome_ptn = 3;★両ｱｰﾑ2軸を曲げる
      GOTO fin
    END
  END
  IF DISTANCE(S_HERE(1),S_HERE(2))<chk_dist_here THEN ;アーム同士の距離が近い
    IF .dist1<=.dist2 THEN ;下ｱｰﾑが上ｱｰﾑよりBASEに近い
      gohome_ptn = 4;★協調でBASEに引く(下ｱｰﾑMASTER)
      GOTO fin
    ELSE ;上ｱｰﾑが下ｱｰﾑよりBASEに近い
      gohome_ptn = 5;★協調でBASEに引く(上ｱｰﾑMASTER)
      GOTO fin
    END
  ELSE ;アーム同士の距離が遠い場合
    IF .jt2rad<chk_jt1_rad THEN ;肘間隔が狭い
      gohome_ptn = 3;★両ｱｰﾑ2軸を曲げる
      GOTO fin
    ELSE
      IF .dist1<=.dist2 THEN ;下ｱｰﾑが上ｱｰﾑよりBASEに近い
        gohome_ptn = 6;★下ｱｰﾑをBASEに引いて逃げる→上ｱｰﾑをBASEに引く
        GOTO fin
      ELSE ;上ｱｰﾑが下ｱｰﾑよりBASEに近い
        gohome_ptn = 7;★上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑをBASEに引く
        GOTO fin
      END
    END
  END
  .ret = err_gen_noptn ;原点復帰条件未成立
fin:
  RETURN
.END
.PROGRAM gohome_move(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰動作
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
;ﾊﾝﾄﾞI/Oの初期化等の処理はここに追加する。
  IF FLG_GOHOME_INIT<>FALSE THEN
    CALL gohome_init(.rno,.gohome_ptn,.home_no,.ret)
    IF .ret<>err_no_error THEN
      RETURN
    END
  END
;ここまで
  DECOMPOSE .rno: .jho[1] = #HOME(.home_no)
  DECOMPOSE .rno: .jhe[1] = #S_HERE(.rno)
  DECOMPOSE .rno: .lhe[1] = S_HERE(.rno)
  POINT .null = TRANS(0,0,.jho[3],0,0,0)
  POINT .here = TRANS(.lhe[1],.lhe[2],.jho[3],.lhe[4],.lhe[5],.lhe[6])
  .dist = DISTANCE(.here,.null)
  POINT .base = TRANS(((chk_gohome[.rno]-5)*.lhe[1])/.dist,((chk_gohome[.rno]-5)*.lhe[2])/.dist,.jho[3],.lhe[4],.lhe[5],.lhe[6]);BASEに引いた点
  JMOVE #PPOINT(.jhe[1],.jhe[2],.jho[3],.jhe[4],.jhe[5],.jhe[6]);3軸を原点高さにする
;BASE引き動作
  CASE .gohome_ptn OF
   VALUE 1:;その場から原点復帰
   VALUE 2:;上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑ2軸を曲げる
    IF .rno==pg_master THEN
      CALL cont_timing
      JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6])
      BREAK
    ELSE
      ZL3LMOVE .base,1,1
      BREAK
      CALL gohome_nige(.home_no,.rno);1軸退避動作
      CALL cont_timing
    END
   VALUE 3:;両ｱｰﾑ2軸を曲げる
    JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6])
    BREAK
   VALUE 4:;協調でBASEに引く(下ｱｰﾑMASTER)
    IF .rno==pg_master THEN
      MASTER
      MLZL3LMOVE .base,1,1
      BREAK
      ALONE
      CALL gohome_nige(.home_no,.rno);1軸退避動作
      CALL cont_timing
    ELSE
      SLAVE
      ALONE
      CALL cont_timing
      ZL3LMOVE .base,1,1
      BREAK
    END
   VALUE 5:;協調でBASEに引く(上ｱｰﾑMASTER)
    IF .rno==pg_master THEN
      SLAVE
      ALONE
      CALL cont_timing
      ZL3LMOVE .base,1,1
      BREAK
    ELSE
      MASTER
      MLZL3LMOVE .base,1,1
      BREAK
      ALONE
      CALL gohome_nige(.home_no,.rno);1軸退避動作
      CALL cont_timing
    END
   VALUE 6:;下ｱｰﾑをBASEに引いて逃げる→上ｱｰﾑをBASEに引く
    IF .rno==pg_master THEN
      ZL3LMOVE .base,1,1
      BREAK
      CALL gohome_nige(.home_no,.rno);1軸退避動作
      CALL cont_timing
    ELSE
      CALL cont_timing
      ZL3LMOVE .base,1,1
      BREAK
    END
   VALUE 7:;上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑをBASEに引く
    IF .rno==pg_master THEN
      CALL cont_timing
      ZL3LMOVE .base,1,1
      BREAK
    ELSE
      ZL3LMOVE .base,1,1
      BREAK
      CALL gohome_nige(.home_no,.rno);1軸退避動作
      CALL cont_timing
    END
  END
  BREAK
  CALL cont_timing
;BASE引き動作完了
  DECOMPOSE .jt[1] = #S_HERE(.rno)
  JMOVE #PPOINT(.jt[1],.jt[2],.jt[3],.jho[4],.jt[5],.jt[6]);4軸を原点位置に戻す
  BREAK
  CALL cont_timing
  IF DISTANCE(S_HERE(.rno),.null)<=chk_gohome[.rno] THEN
    ;BASE引き後、周辺装置等の原点復帰処理等をしたい場合はここに処理を追加する
    IF FLG_GOHOME_CHK<>FALSE THEN
      CALL gohome_chk(.rno,.gohome_ptn,.home_no,.ret)
      IF .ret<>err_no_error THEN
        RETURN
      END
    END
  ELSE
    .ret = err_gen_base[.rno]
    RETURN
  END
;ここまで
;安全距離からの原点復帰動作
  DECOMPOSE .jt[1] = #S_HERE(.rno)
  IF .rno==pg_master THEN
    MASTER
    MLJMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6]);@下ｱｰﾑの1軸を原点位置に戻す
    BREAK
    ALONE
    CALL cont_timing;A待ち
    HOME (.home_no)
  ELSE
    SLAVE;@待ち
    ALONE
    JMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6]);A上ｱｰﾑの1軸を原点位置に戻す
    BREAK
    CALL cont_timing
    HOME (.home_no)
  END
  CALL cont_timing
;原点復帰完了後の処理がある場合はここに追加する
  IF FLG_GOHOME_COMP<>FALSE THEN
    CALL gohome_comp(.rno,.gohome_ptn,.home_no,.ret)
    IF .ret<>err_no_error THEN
      RETURN
    END
  END
  RETURN
.END
.PROGRAM gohome_nige(.home_no,.rno)
;-------------------------------- 
;機能：原点復帰 1軸退避動作
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号
;戻値：なし
;-------------------------------- 
  IF .rno==pg_master THEN
    .arno = pg_slave
  ELSE
    .arno = pg_master
  END
  GETULIMIT .rno: .#ulim
  GETLLIMIT .rno: .#llim
  .ulim[1] = DEXT(.#ulim,1)
  .llim[1] = DEXT(.#llim,1)
  .jt1here = DEXT(#S_HERE(.rno),1);1軸値を取得
  DECOMPOSE .rno: .jho[1] = #HOME(.home_no);原点の各軸成分を取得
  DECOMPOSE 1: .jhe1[1] = #S_HERE(1);現在値の各軸成分を取得
  DECOMPOSE 2: .jhe2[1] = #S_HERE(2);現在値の各軸成分を取得
;●肘間の角度を計算→退避角度の算出
  CALL chg_jt1rad(.jhe1[1],.jhe1[101]);下ｱｰﾑ側 1軸の角度を0〜360°内に変換
  CALL chg_jt1rad(.jhe2[1],.jhe2[101]);上ｱｰﾑ側 1軸の角度を0〜360°内に変換
  IF (.jhe1[101]<.jhe2[101] AND .jhe1[2]<0 AND .jhe2[2]>=0) OR (.jhe1[101]>.jhe2[101] AND .jhe2[2]<0 AND .jhe1[2]>=0) THEN
    .jt2rad = ABS(.jhe1[101]-.jhe2[101])
  ELSE
    .jt2rad = 360-ABS(.jhe1[101]-.jhe2[101])
  END
  .rad = (.jt2rad-chk_jt1_rad);退避角度
;●退避動作
;退避アームがマイナス側にある場合は、.radがプラスの時に1軸をマイナス側に退避する。.radがマイナスな場合は1軸をプラス側に退避する。
;退避アームがプラス側にある場合は、.radがプラスの時に1軸をプラス側に退避する。.radがマイナスな場合は1軸をマイナス側に退避する。
  IF .jho[2]>0 THEN ;退避するｱｰﾑが右側(マイナス側)にある
    IF .rad>=0 THEN;マイナス側に退避するので、LLIMITを確認する。
      WHILE NOT ((.jt1here-ABS(.rad))>=.llim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をデクリメントする
        .rad = .rad-1
        IF .rad<=0 THEN
          RETURN
        END
        TWAIT ascycle
      END
    ELSE;プラス側に退避するので、ULIMITを確認する。
      WHILE NOT ((.jt1here+ABS(.rad))<=.ulim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をインクリメントする
        .rad = .rad+1
        IF .rad>=0 THEN
          RETURN
        END
        TWAIT ascycle
      END
    END
    DRIVE 1,-.rad
  ELSE ;退避するｱｰﾑが左側(プラス側)にある
    IF .rad>=0 THEN;プラス側に退避するので、ULIMITを確認する。
      WHILE NOT ((.jt1here+ABS(.rad))<=.ulim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をインクリメントする
        .rad = .rad-1
        IF .rad<=0 THEN
          RETURN
        END
        TWAIT ascycle
      END
    ELSE;マイナス側に退避するので、LLIMITを確認する。
      WHILE NOT ((.jt1here-ABS(.rad))>=.llim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をデクリメントする
        .rad = .rad+1
        IF .rad>=0 THEN
          RETURN
        END
        TWAIT ascycle
      END
    END
    DRIVE 1,.rad
  END
  RETURN
.END
.PROGRAM cont_timing()
;-------------------------------- 
;機能：マスタとスレーブのタイミングを合わせる
;引数：なし
;戻値：なし
;-------------------------------- 
  .rob_no = TASKNO;実行ロボット番号
  IF .rob_no==1 THEN;マスタロボット
    .chk_rob = 2;相手側のロボット番号
  ELSE;スレーブロボット
    .chk_rob = 1;相手側のロボット番号
  END
  WHILE (COOPSTATUS(.chk_rob)==3 OR COOPSTATUS(.chk_rob)==4) DO;相手ロボットがMASTERまたはSLAVE状態
    TWAIT ascycle;相手ロボットのALONE待ち
    UTIMER @tim_aft_alone2[.rob_no] = 0;ALONE後のタイマをリセット
  END
  WAIT NOT (0<UTIMER(@tim_aft_alone2[.rob_no]) AND UTIMER(@tim_aft_alone2[.rob_no])<3);前回のALONE後、3秒間は新たにMASTER/SLAVE宣言させない
  IF .rob_no==1 THEN;マスタロボット
    MASTER;協調開始（マスタ）
  ELSE;スレーブロボット
    SLAVE;協調開始（スレーブ）
  END
  ALONE;協調停止命令
  TWAIT ascycle;ALONE待ち
  UTIMER @tim_aft_alone2[.rob_no] = 0;ALONE後のタイマをリセット
  RETURN
.END
.PROGRAM chg_jt1rad(.jt,.jtans)
;-------------------------------- 
;機能：1軸の角度を0°〜360°内に変換
;引数：1軸値
;戻値：変換後の1軸値
;-------------------------------- 
  IF .jt<0 THEN
    .jtans = .jt+360
  ELSE
    IF .jt>360 THEN
      .jtans = .jt-360
    ELSE
      .jtans = .jt
    END
  END
.END
.PROGRAM gohome_init(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰動作開始前の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
  .ret = err_no_error
  RETURN
.END
.PROGRAM gohome_chk(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：BASE引き動作後の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
  .ret = err_no_error
  RETURN
.END
.PROGRAM gohome_comp(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰完了後の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
  .ret = err_no_error
  RETURN
.END
.PROGRAM chg_sp(.sp,.ret)
;-------------------------------- 
;機能：速度変更
;引数：変更希望速度
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF .sp>0 THEN
        IF FLG_SLOWLIMIT==TRUE THEN
            IF UTIMER(@SLOWLIMIT_TIMER) < SLOWLIMIT_TIME THEN
                SPEED SLOWLIMIT_SPEED MM/S ALWAYS
                IF DEBUG.PRT.MOVE==TRUE THEN
                    PRINT "chg_sp()-> START---SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",SLOWLIMIT_SPEED,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@SLOWLIMIT_TIMER),",SLOWLIMIT_TIME=",SLOWLIMIT_TIME
                END
                RETURN
            ELSE
                IF DEBUG.PRT.MOVE==TRUE THEN
                    PRINT "chg_sp()-> DONE----SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",SLOWLIMIT_SPEED,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@SLOWLIMIT_TIMER),",SLOWLIMIT_TIME=",SLOWLIMIT_TIME
                END
                FLG_SLOWLIMIT=FALSE
            END
        END
        IF (.sp>SAFTY_MOVE_SP-1 AND .sp<SAFTY_MOVE_SP+1) OR (.sp>SAFTY_LMOVE_SP-1 AND .sp<SAFTY_LMOVE_SP+1) THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "TASKNO=",TASKNO,", change speed to ",.sp, "[mm/sec]"
            END
            IF TASKNO==1 THEN
                ABS.SPEED 1:ON
            ELSE
                ABS.SPEED 2:ON
            END
            IF (.sp>SAFTY_MOVE_SP-1 AND .sp<SAFTY_MOVE_SP+1) THEN
              SPEED SAFTY_MOVE_SP MM/S ALWAYS
            ELSE
              SPEED SAFTY_LMOVE_SP MM/S ALWAYS
            END
        ELSE
            IF .sp<=0 OR .sp>100 THEN
                IF DEBUG.PRT.MOVE==TRUE THEN
                    PRINT "TASKNO=",TASKNO,", err_bad_speed"
                END
                .ret=err_bad_speed
                RETURN
            ELSE
                IF DEBUG.PRT.MOVE==TRUE THEN
                    PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%]"
                END
                IF TASKNO==1 THEN
                    ABS.SPEED 1:OFF
                ELSE
                    ABS.SPEED 2:OFF
                END
                SPEED .sp ALWAYS
            END
        END
    ELSE
        IF DEBUG.PRT.MOVE==TRUE THEN
            PRINT "TASKNO=",TASKNO,", sp is invalid value. .sp=",.sp
        END
    END
.END

.PROGRAM chg_move_param(.sp_mode,.sp,.acc,.dec,.accu,.ret)
;-------------------------------- 
;機能：動作パラメータ変更
;引数：絶対速度モード[0;OFF(%),1:ON(%),2:OFF(mm/sec),3:ON(mm/sec)]、速度、加速度、減速度、精度
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  CALL reset_mon_sp(TASKNO); モニタ速度を変更している場合は元に戻す
  IF FLG_SLOWLIMIT==TRUE THEN
    IF UTIMER(@SLOWLIMIT_TIMER) < SLOWLIMIT_TIME THEN
      IF TASKNO==1 THEN
        ABS.SPEED 1:ON
      ELSE
        ABS.SPEED 2:ON
      END
      IF SLOWLIMIT_SPEED<SLOWLIMIT_SPMIN OR SLOWLIMIT_SPMAX<SLOWLIMIT_SPEED THEN
        IF SLOWLIMIT_SPEED<SLOWLIMIT_SPMIN THEN
          SLOWLIMIT_SPEED = SLOWLIMIT_SPMIN
        ELSE
          SLOWLIMIT_SPEED = SLOWLIMIT_SPMAX
        END
      END
      SPEED SLOWLIMIT_SPEED MM/S ALWAYS
      IF DEBUG.PRT.MOVE==TRUE THEN
          PRINT "chg_move_param()-> START---SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",SLOWLIMIT_SPEED,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@SLOWLIMIT_TIMER),",SLOWLIMIT_TIME=",SLOWLIMIT_TIME
      END
      IF DEBUG.PRT.SP==TRUE THEN
          PRINT "chg_move_param()-> -- SLOWSTART -- M.SPEED",SYSDATA(M.SPEED,TASKNO), "[%], P.SPEED",SLOWLIMIT_SPEED,"[mm/sec], TASKNO =",TASKNO,", L3NUM =",TMP_MOVE_L3NUM[TASKNO]
      END
      GOTO jump
    ELSE
      IF DEBUG.PRT.MOVE==TRUE THEN
          PRINT "chg_move_param()-> DONE----SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",SLOWLIMIT_SPEED,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@SLOWLIMIT_TIMER),",SLOWLIMIT_TIME=",SLOWLIMIT_TIME
      END
      FLG_SLOWLIMIT = FALSE
      IF FLG_EXEC_FIRST_MOVE==TRUE THEN
          FLG_EXEC_FIRST_MOVE = FALSE
      END
    END
  END
  IF DEBUG.PRT.MOVE==TRUE THEN
    PRINT "chg_move_param()-> TASKNO=",TASKNO
  END
  CASE .sp_mode OF
   VALUE 0,1:; 絶対速度指定OFF[%]
    IF .sp<=0 OR .sp>100 THEN
      IF DEBUG.PRT.MOVE==TRUE THEN
        PRINT "TASKNO=",TASKNO,", err_bad_speed"
      END
      .ret = err_bad_speed
      RETURN
    ELSE
      IF DEBUG.PRT.MOVE==TRUE THEN
        IF .sp_mode==0 THEN
          PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%] ABS.SPEED OFF"
        ELSE
          PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%] ABS.SPEED ON"
        END
      END
      IF .sp_mode==0 THEN; 絶対速度指定OFF
        IF TASKNO==1 THEN
          ABS.SPEED 1:OFF
        ELSE
          ABS.SPEED 2:OFF
        END
      ELSE; 絶対速度指定ON
        IF TASKNO==1 THEN
          ABS.SPEED 1:ON
        ELSE
          ABS.SPEED 2:ON
        END
      END
      SPEED .sp ALWAYS; 速度を設定
      IF DEBUG.PRT.SP==TRUE THEN
          PRINT "chg_move_param()-> M.SPEED",SYSDATA(M.SPEED,TASKNO), "[%], P.SPEED",.sp,"[%], TASKNO =",TASKNO,", L3NUM =",TMP_MOVE_L3NUM[TASKNO]
      END
    END
  VALUE 2,3:; 速度指定[mm/sec]
    IF .sp<=0 THEN
      IF DEBUG.PRT.MOVE==TRUE THEN
        PRINT "TASKNO=",TASKNO,", err_bad_speed"
      END
      .ret = err_bad_speed
      RETURN
    ELSE
      IF DEBUG.PRT.MOVE==TRUE THEN
        IF .sp_mode==0 THEN
          PRINT "TASKNO=",TASKNO,", change speed to ",.sp, "[mm/sec] ABS.SPEED OFF"
        ELSE
          PRINT "TASKNO=",TASKNO,", change speed to ",.sp, "[mm/sec] ABS.SPEED ON"
        END
      END
      IF .sp_mode==2 THEN; 絶対速度指定OFF
        IF TASKNO==1 THEN
          ABS.SPEED 1:OFF
        ELSE
          ABS.SPEED 2:OFF
        END
      ELSE; 絶対速度指定ON
        IF TASKNO==1 THEN
          ABS.SPEED 1:ON
        ELSE
          ABS.SPEED 2:ON
        END
      END
      SPEED .sp MM/S ALWAYS; 速度を設定
      IF DEBUG.PRT.SP==TRUE THEN
          PRINT "chg_move_param()-> M.SPEED",SYSDATA(M.SPEED,TASKNO), "[%], P.SPEED",.sp,"[mm/sec], TASKNO =",TASKNO,", L3NUM =",TMP_MOVE_L3NUM[TASKNO]
      END
    END
  END
;
jump:
  IF .acc<=0 OR 100<.acc THEN
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", err_bad_accel"
    END
    .ret = err_bad_speed
    RETURN
  ELSE
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", change accel to ",.acc,"[%]"
    END
    ACCEL .acc ALWAYS; 加速度を設定
  END
;
  IF .dec<=0 OR 100<.dec THEN
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", err_bad_decel"
    END
    .ret = err_bad_speed
    RETURN
  ELSE
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", change decel to ",.dec,"[%]"
    END
    DECEL .dec ALWAYS; 減速度を設定
  END
;
  IF .accu<=0 THEN
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", err_bad_accuracy"
    END
    .ret = err_bad_speed
    RETURN
  ELSE
    IF DEBUG.PRT.MOVE==TRUE THEN
      PRINT "TASKNO=",TASKNO,", change accuracy to ",.accu,"[mm]"
    END
    ZL3TRN .accur[1] = .accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
    ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
  END
.END

.PROGRAM reset_mon_sp(.rno)
;-------------------------------- 
;機能：モニタ速度を戻す
;引数：
;戻値：成否
;-------------------------------- 
  CASE .rno OF
   VALUE ROBOT_ALL:
    FOR .i=ROBOT_MASTER TO ROBOT_SLAVE
      IF CHG_BEF_MSPEED[.i]<>0 THEN
        IF ABS(CHG_BEF_MSPEED[.i]-DATA_MONSPEED[0])<0.1 THEN
          .$str = "SPEED "+$ENCODE(.i)+":"+$ENCODE(CHG_BEF_MSPEED[.i])
          ZMONEXE .$str
          IF DEBUG.PRT.SP==TRUE THEN
              PRINT "reset_mon_sp()-> M.SPEED",CHG_BEF_MSPEED[.i], "[%], P.SPEED",SYSDATA(P.SPEED,.i),"[%], TASKNO =",TASKNO,", rno =",.i
          END
        ELSE
          IF DEBUG.PRT.SP==TRUE THEN
              PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",CHG_BEF_MSPEED[.i], "[%], DATA_MONSPEED",DATA_MONSPEED[0],"[%], TASKNO =",TASKNO,", rno =",.i
          END
        END
        CHG_AFT_MSPEED[.i] = CHG_BEF_MSPEED[.i]
        CHG_BEF_MSPEED[.i] = 0
      ELSE
        IF DEBUG.PRT.SP==TRUE THEN
          PRINT "reset_mon_sp()-> -- NoChange -- M.SPEED",SYSDATA(M.SPEED,.i), "[%], P.SPEED",SYSDATA(P.SPEED,.i),"[%], TASKNO =",TASKNO,", rno =",.i
        END
      END
    END
   VALUE ROBOT_MASTER,ROBOT_SLAVE:
    IF CHG_BEF_MSPEED[.rno]<>0 THEN
      IF ABS(CHG_BEF_MSPEED[.rno]-DATA_MONSPEED[0])<0.1 THEN
        .$str = "SPEED "+$ENCODE(.rno)+":"+$ENCODE(CHG_BEF_MSPEED[.rno])
        ZMONEXE .$str
        IF DEBUG.PRT.SP==TRUE THEN
            PRINT "reset_mon_sp()-> M.SPEED",CHG_BEF_MSPEED[.rno], "[%], P.SPEED",SYSDATA(P.SPEED,.rno),"[%], TASKNO =",TASKNO,", rno =",.rno
        END
      ELSE
        IF DEBUG.PRT.SP==TRUE THEN
            PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",CHG_BEF_MSPEED[.rno], "[%], DATA_MONSPEED",DATA_MONSPEED[0],"[%], TASKNO =",TASKNO,", rno =",.rno
        END
      END
      CHG_AFT_MSPEED[.rno] = CHG_BEF_MSPEED[.rno]
      CHG_BEF_MSPEED[.rno] = 0
    END
    IF .rno==ROBOT_MASTER THEN
      IF CHG_BEF_MSPEED[ROBOT_SLAVE]<>0 AND FLG_REQ_MAMODE==TRUE THEN
        IF ABS(CHG_BEF_MSPEED[ROBOT_SLAVE]-DATA_MONSPEED[0])<0.1 THEN
          .$str = "SPEED "+$ENCODE(ROBOT_SLAVE)+":"+$ENCODE(CHG_BEF_MSPEED[ROBOT_SLAVE])
          ZMONEXE .$str
          IF DEBUG.PRT.SP==TRUE THEN
              PRINT "reset_mon_sp()-> M.SPEED",CHG_BEF_MSPEED[ROBOT_SLAVE], "[%], P.SPEED",SYSDATA(P.SPEED,ROBOT_SLAVE),"[%], TASKNO =",TASKNO,", rno =",ROBOT_SLAVE
          END
        ELSE
          IF DEBUG.PRT.SP==TRUE THEN
              PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",CHG_BEF_MSPEED[ROBOT_SLAVE], "[%], DATA_MONSPEED",DATA_MONSPEED[0],"[%], TASKNO =",TASKNO,", rno =",ROBOT_SLAVE
          END
        END
        CHG_AFT_MSPEED[ROBOT_SLAVE] = CHG_BEF_MSPEED[ROBOT_SLAVE]
        CHG_BEF_MSPEED[ROBOT_SLAVE] = 0
      END
    END
  END
.END

.PROGRAM change_ms_mode(.timeout,.ret)
;-------------------------------- 
;機能：協調動作モードに移行
;引数：
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.MOVE==TRUE THEN
        PRINT "->change_ms_mode() MASTER-SLAVE MODE"
    END
    FLG_REQ_MAMODE = TRUE
    FLG_SLAVE_MOVE = TRUE
    UTIMER .@NowTime=0
    WHILE(1)
        IF FLG_SLAVE_RDY==TRUE THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->change_ms_mode() SLAVE STATUS IS RDY! MASTER ROBOT CHANGE TO RDY TOO."
            END
            MASTER
            GOTO check
        END
        IF (UTIMER(.@NowTime)>.timeout) THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->change_ms_mode() Cannot Slave robot change to RDY status."
            END
            .ret=err_srobot_timeout
            RETURN
        END
        IF g_last_error<>err_no_error THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->change_ms_mode() Detected error. g_last_error=",g_last_error
            END
            .ret=err_srobot_error
            RETURN
        END
    END
check:
    UTIMER .@NowTime = 0
    DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            .ret=err_robot_cmon
            PRINT "->change_ms_mode() Cannot change MASTER-mode for MASTER_ROBOT"
            RETURN
        END
    UNTIL(COOPSTATUS(1)==3)
    UTIMER .@NowTime = 0
    DO
        IF UTIMER(.@NowTime)>BOOT_TIMEOUT THEN
            .ret=err_robot_cmon
            PRINT "->change_ms_mode() Cannot change SLAVE-mode for SLAVE_ROBOT"
            RETURN
        END
    UNTIL(COOPSTATUS(2)==4)
.END

.PROGRAM slave_run(.timeout,.ret)
;-------------------------------- 
;機能：スレーブ動作実行
;引数：
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    UTIMER @SlaveTime = 0
    FLG_SLAVE_MOVE = TRUE
    WHILE(1)
        IF FLG_SLAVE_MOVE==FALSE THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->movepos() Slave robot moved to TARGET-POSITION."
            END
            RETURN
        ELSE
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->movepos() WAITING Slave robot move to TARGET-POSITION. TIME=",UTIMER(.@NowTime),"/LIMIT=",.timeout
            END
        END
        IF UTIMER(@SlaveTime)>.timeout THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->movepos() TIMEOUT ERROR.Slave robot NOT move to TARGET-POSITION."
            END
            .ret=err_cmd_timeout
            RETURN
        END
        IF g_last_error<>err_no_error THEN
            IF DEBUG.PRT.MOVE==TRUE THEN
                PRINT "->movepos() Detected error. g_last_error=",g_last_error
            END
            .ret=err_srobot_error
            RETURN
        END
    END
.END

.PROGRAM movepos(.rno,.#tno,.mode,.type,.#inpos,.bflag,.sp,.acc,.dec,.accu,.sp_mode,.ret)
;-------------------------------- 
;機能：指定位置移動
;引数：ロボット番号、ツール変換値、動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、教示点構成要素(.data実数配列)、動作後BREAK有無、第3階層指定速度(ティーチ時などは0)、第3階層指定加速度、第3階層指定減速度、第3階層指定精度、第3階層指定速度モード(%／mm/sec)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    ;位置情報生成
    DECOMPOSE .inpos[1] = .#inpos
    DECOMPOSE .tno[1] = .#tno
    IF .mode==MODE_JT THEN
        POINT .#pos= #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
    ELSE
        POINT .pos=TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],)
        .ext1 = .inpos[6]
        G_EXT1 = .ext1
    END

    IF DEBUG.PRT.MOVE==TRUE THEN
        PRINT "->movepos() .rno=",.rno," ,TASKNO=",TASKNO
    END
    ; 動作関連パラメータ設定
    IF (TASKNO==ROBOT_MASTER AND (.rno==ROBOT_ALL OR .rno==ROBOT_MASTER)) OR (TASKNO==ROBOT_SLAVE AND .rno==ROBOT_SLAVE) THEN
      CALL chg_move_param(.sp_mode,.sp,.acc,.dec,.accu,.ret)
      IF .ret<>err_no_error THEN
          RETURN
      END
    END

    ;スレーブ制御用グローバル変数
    IF .rno==ROBOT_SLAVE THEN
      GS_MODE=.mode
      GS_TYPE=.type
      GS_BFLAG=.bflag
      GS_SP=.sp
      GS_ACCEL=.acc
      GS_DECEL=.dec
      GS_ACCURACY=.accu
      GS_SP_MODE=.sp_mode
    END

    IF .rno==ROBOT_ALL THEN
        IF SYN_MODE_START==TRUE THEN
          ;協調モードに移行
          CALL change_ms_mode(SLAVE_TIMEOUT,.ret)
          IF .ret<>err_no_error THEN
            IF TASKNO==PG_MASTER THEN
              ;終了処理
              FLG_REQ_MAMODE = FALSE
              CALL exec_alone(.ret)
              RETURN
            END
          END
        END
    END

    IF .type==MODE_JMOVE THEN
        IF .mode==MODE_JT THEN
            ;JMOVE/JT
            DECOMPOSE .d[1]=.#pos
            IF DEBUG.PRT.MOVE==TRUE THEN
                FOR .i=1 TO 6
                    PRINT "->movepos() MODE_JMOVE JT[",.i,"]=",.d[.i]
                END
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .rno=1;マスターで制御する
                    MLJMOVE .#pos
                VALUE ROBOT_MASTER:
                    JMOVE .#pos
                VALUE ROBOT_SLAVE:
                    IF TASKNO==PG_MASTER THEN
                        GS_TOOL=.tno[ROBOT_SLAVE]
                        POINT #G_MPOS=.#pos
                        ;スレーブ動作実行
                        CALL slave_run(SLAVE_TIMEOUT,.ret)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "(JMOVE/MODE_JT)"
                        END
                        DO
                        UNTIL(FLG_SLAVE_MOVE==FALSE)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "SLAVE action done."
                        END
                    ELSE
                        JMOVE .#pos
                    END
            END
        ELSE
            ;JMOVE/XYZR1EXT1
            DECOMPOSE .d[1]=.pos
            .d[6]=.ext1
            IF DEBUG.PRT.MOVE==TRUE THEN
                FOR .i=1 TO 6
                    PRINT "->movepos() MODE_JMOVE XYZR1EXT1[",.i,"]=",.d[.i]
                END
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .rno=1;マスターで制御する
                    IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_MASTER] THEN
                        DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_MASTER,.tno[ROBOT_MASTER]]
                        ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                            PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,1)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,1)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,1))
                        END
                        ZL3LINKX 1: .toolprm[1]
                        ZL3LINKX2 1: .toolprm[2]
                        ZL3LINKH1 1: .toolprm[3]
                        DATA_TOOLCUR[.rno]=.tno[ROBOT_MASTER]
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                    END
                    DECOMPOSE .p[1]=.pos
                    .p[6]=.ext1
                    ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
                    MLJMOVE .#tpos
                VALUE ROBOT_MASTER:
                    IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_MASTER] THEN
                        DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_MASTER,.tno[ROBOT_MASTER]]
                        ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                            PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                        ZL3LINKX 1: .toolprm[1]
                        ZL3LINKX2 1: .toolprm[2]
                        ZL3LINKH1 1: .toolprm[3]
                        DATA_TOOLCUR[.rno]=.tno[ROBOT_MASTER]
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                    END
                    DECOMPOSE .p[1]=.pos
                    .p[6]=.ext1
                    ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
                    JMOVE .#tpos;変換値指定はできない
                VALUE ROBOT_SLAVE:
                    IF TASKNO==PG_MASTER THEN
                        GS_TOOL=.tno[ROBOT_SLAVE]
                        POINT G_MPOS=.pos
                        ;スレーブ動作実行
                        CALL slave_run(SLAVE_TIMEOUT,.ret)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "(JMOVE/NOT MODE_JT)"
                        END
                        DO
                        UNTIL(FLG_SLAVE_MOVE==FALSE)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "SLAVE action done."
                        END
                    ELSE
                        IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_SLAVE] THEN
                            DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_SLAVE,.tno[ROBOT_SLAVE]]
                            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                            IF DEBUG.PRT.MOVE==TRUE THEN
                                PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                                PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_SLAVE)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_SLAVE)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_SLAVE))
                            END
                            ZL3LINKX 2: .toolprm[1]
                            ZL3LINKX2 2: .toolprm[2]
                            ZL3LINKH1 2: .toolprm[3]
                            DATA_TOOLCUR[.rno]=.tno[ROBOT_SLAVE]
                            IF DEBUG.PRT.MOVE==TRUE THEN
                                PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_SLAVE)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_SLAVE)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_SLAVE))
                            END
                        END
                        DECOMPOSE .p[1]=.pos
                        .p[6]=.ext1
                        ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
                        JMOVE .#tpos;変換値指定はできない
                    END
            END
        END
    ELSE
        IF .mode==MODE_JT THEN
            ;LMOVE/JT
            DECOMPOSE .d[1]=.#pos
            IF DEBUG.PRT.MOVE==TRUE THEN
                FOR .i=1 TO 6
                    PRINT "->movepos() MODE_LMOVE JT[",.i,"]=",.d[.i]
                END
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .rno=1;マスターで制御する
                    MLZL3LMOVE .#pos,1,1
                VALUE ROBOT_MASTER:
                    ZL3LMOVE .#pos,1,1;引数は各軸値
                VALUE ROBOT_SLAVE:
                    IF TASKNO==PG_MASTER THEN
                        GS_TOOL=.tno[ROBOT_SLAVE]
                        POINT #G_MPOS=.#pos
                        ;スレーブ動作実行
                        CALL slave_run(SLAVE_TIMEOUT,.ret)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "(LMOVE/MODE_JT)"
                        END
                        DO
                        UNTIL(FLG_SLAVE_MOVE==FALSE)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "SLAVE action done."
                        END
                    ELSE
                        ZL3LMOVE .#pos,1,1;引数は各軸値
                    END
            END
        ELSE
            ;LMOVE/XYZR1EXT1
            DECOMPOSE .d[1]=.pos
            .d[6]=.ext1
            IF DEBUG.PRT.MOVE==TRUE THEN
                FOR .i=1 TO 6
                    PRINT "->movepos() MODE_LMOVE XYZR1EXT1[",.i,"]=",.d[.i]
                END
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .rno=1;マスターで制御する
                    IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_MASTER] THEN
                        DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_MASTER,.tno[ROBOT_MASTER]]
                        ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                            PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,1)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,1)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,1))
                        END
                        ZL3LINKX 1: .toolprm[1]
                        ZL3LINKX2 1: .toolprm[2]
                        ZL3LINKH1 1: .toolprm[3]
                        DATA_TOOLCUR[.rno]=.tno[ROBOT_MASTER]
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                    END
                    DECOMPOSE .p[1]=.pos
                    .p[6]=.ext1
                    ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
                    MLZL3LMOVE .#tpos,1,1
                VALUE ROBOT_MASTER:
                    IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_MASTER] THEN
                        DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_MASTER,.tno[ROBOT_MASTER]]
                        ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                            PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                        ZL3LINKX 1: .toolprm[1]
                        ZL3LINKX2 1: .toolprm[2]
                        ZL3LINKH1 1: .toolprm[3]
                        DATA_TOOLCUR[.rno]=.tno[ROBOT_MASTER]
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_MASTER)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_MASTER)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_MASTER))
                        END
                    END
                    DECOMPOSE .p[1]=.pos
                    ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
                    ZL3LMOVE .#tpos,1,1;引数は各軸値
                VALUE ROBOT_SLAVE:
                    IF TASKNO==PG_MASTER THEN
                        GS_TOOL=.tno[ROBOT_SLAVE]
                        POINT G_MPOS=.pos
                        ;スレーブ動作実行
                        CALL slave_run(SLAVE_TIMEOUT,.ret)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "(LMOVE/NOT MODE_JT)"
                        END
                        DO
                        UNTIL(FLG_SLAVE_MOVE==FALSE)
                        IF DEBUG.PRT.MOVE==TRUE THEN
                            PRINT "SLAVE action done."
                        END
                    ELSE
                        IF DATA_TOOLCUR[.rno]<>.tno[ROBOT_SLAVE] THEN
                            DECOMPOSE .toolprm[1]=DEF_TOOL[ROBOT_SLAVE,.tno[ROBOT_SLAVE]]
                            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
                            IF DEBUG.PRT.MOVE==TRUE THEN
                                PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
                                PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_SLAVE)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_SLAVE)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_SLAVE))
                            END
                            ZL3LINKX 2: .toolprm[1]
                            ZL3LINKX2 2: .toolprm[2]
                            ZL3LINKH1 2: .toolprm[3]
                            DATA_TOOLCUR[.rno]=.tno[ROBOT_SLAVE]
                            IF DEBUG.PRT.MOVE==TRUE THEN
                                PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,ROBOT_SLAVE)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,ROBOT_SLAVE)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,ROBOT_SLAVE))
                            END
                        END
                        DECOMPOSE .p[1]=.pos
                        .p[6]=.ext1
                        ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
                        ZL3LMOVE .#tpos,1,1;引数は各軸値
                    END
            END
        END
    END
    ; マスターロボットの動作中の作業番号を記憶
    IF .rno==ROBOT_MASTER THEN
      NOW_MOVE_L3NUM[ROBOT_MASTER] = TMP_MOVE_L3NUM[.rno]
      IF SYS_FORCE_CMODE==TRUE OR FLG_SLAVE_PARALLEL_REQ==FALSE THEN
        NOW_MOVE_L3NUM[ROBOT_SLAVE] = 0; 協調動作または単体動作の時はスレーブ側の記憶は消去
      END
    ELSE
      IF TASKNO==ROBOT_SLAVE THEN
        NOW_MOVE_L3NUM[ROBOT_SLAVE] = TMP_MOVE_L3NUM[.rno]; 並列動作の時のみスレーブロボットの動作中の作業番号も記憶
        IF FLG_SLAVE_MOVED==FALSE THEN
          FLG_SLAVE_MOVED = TRUE
        END
      END
    END
    IF .bflag == TRUE AND .rno==TASKNO THEN
        BREAK
    END
    IF DEBUG.PRT.ITEM==TRUE THEN
        IF .mode==MODE_JT THEN
            PRINT "TASKNO=",TASKNO,", move()->Mode=", .mode, ", Type=", .type,", JT1=", .d[1], ", JT2=", .d[2], ", JT3=", .d[3], ", JT4=", .d[4], ", JT5=", .d[5], ", JT6=", .d[6], ", Time=", $TIME
        ELSE
            PRINT "TASKNO=",TASKNO,", move()->Mode=", .mode, ", Type=", .type,", X=", .d[1], ", Y=", .d[2], ", Z=", .d[3], ", R1=", .d[4], ", EXT1=", .d[5], ", EXT2=", .d[6], ", Time=", $TIME
        END
    END
.END

.PROGRAM shift_poscore(.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
;-------------------------------- 
;機能：教示点加算コア処理
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
    .ret = err_no_error
    DECOMPOSE .inpos[1] = .#inpos
    DECOMPOSE .offsetpos[1] = .#offsetpos
    CASE .mode OF
        VALUE MODE_JT:
            ;OFFSET値は各軸とする(ビジョン補正の加算演算はロボットBC判断で対応不要とのこと)
            POINT .#pos = #PPOINT(.inpos[1]+.offsetpos[1],.inpos[2]+.offsetpos[2],.inpos[3]+.offsetpos[3],.inpos[4]+.offsetpos[4])
            DECOMPOSE .outpos[1]=.#pos
        VALUE MODE_XYZR1EXT1:
            CASE .shift_type OF
                VALUE MODE_TOOL:
                    POINT .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])
                    DECOMPOSE .outpos[1]=.pos
                VALUE MODE_BASE:
                    POINT .pos = TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])+TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
                    DECOMPOSE .outpos[1]=.pos
            END
        ANY
            .ret=err_bad_mode
            RETURN
    END
    POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
    IF DEBUG.PRT.POS==TRUE THEN
        FOR .i=1 TO 6
            PRINT "shift_poscore()-> .inpos[]=",.inpos[.i]
        END
        FOR .i=1 TO 6
            PRINT "shift_poscore()-> .outpos[]=",.outpos[.i]
        END
    END
.END

.PROGRAM shift_pos(.rno,.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)    
;-------------------------------- 
;機能：教示点加算
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.POS==TRUE THEN
        FOR .i=1 TO 6
            PRINT "shift_pos()-> .offsetpos[]=",.offsetpos[.i]
        END
    END
    DECOMPOSE .inpos[1] = .#inpos
    DECOMPOSE .offsetpos[1] = .#offsetpos
    IF DISABLE_AVETOOL==FALSE THEN
        IF (.rno==ROBOT_ALL) AND (.mode==MODE_XYZR1EXT1) AND (.shift_type==MODE_TOOL) THEN
            ;inposは無視して、現在値ベースで加算する
            POINT .inpos=TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
            ;中心位置にオフセット加算
            CALL GetCurrentPos(ROBOT_MASTER,.mode,.#pos_m,.ret)
            DECOMPOSE .pos_m[1] = .#pos_m
            POINT .pos_m=TRANS(.pos_m[1],.pos_m[2],.pos_m[3],.pos_m[4])
            CALL GetCurrentPos(ROBOT_SLAVE,.mode,.#pos_s,.ret)
            DECOMPOSE .pos_s[1] = .#pos_s
            POINT .pos_s=TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4])
            POINT .pos_ave=AVE_TRANS(.pos_m,.pos_s)
            POINT .pos_diff=-.pos_m+.pos_ave
            ;マスター位置に換算
            POINT .pos = .pos_ave+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])-.pos_diff
            DECOMPOSE .outpos[1]=.pos
				    POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
            RETURN
        END
    END
    CALL shift_poscore(.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)    
.END
.PROGRAM setparam(.cmd,.ret)
;-------------------------------- 
;機能：変数設定コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .rno=VAL($prm[TASKNO,1])
    CASE .cmd OF
        VALUE CMD_SET_SP:
            ;This protcol will delete soon.
        VALUE CMD_SET_PITCH:
            DATA_TEACHROT = VAL($prm[TASKNO,2])
            DATA_TEACHPITCH = VAL($prm[TASKNO,3])
            DATA_EXTTYPE[ROBOT_MASTER] = VAL($prm[TASKNO,4])
            DATA_EXTTYPE[ROBOT_SLAVE] = VAL($prm[TASKNO,5])
        VALUE CMD_SET_TNUM:
            TOOL_DATA_NUM[.rno]=VAL($prm[TASKNO,2])
        VALUE CMD_SET_TOOL:
            FOR .i=4 TO 6
                CALL setparam_range($prm[TASKNO,.i],"REAL",0,1000,FALSE,.tool_pos[.i-3],.ret); リンク長／ハンド長 最小値[0]・最大値[1000]確認
                IF .ret<>err_no_error GOTO end
            END
            ;カレントツールは変更しないでデータ格納のみ実行する
            .mode=VAL($prm[TASKNO,2]);モードは無効、後日削除
            ;重量、重心(XYZイナーシャXYZ)は未対応のため無視
            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
            POINT DEF_TOOL[.rno,VAL($prm[TASKNO,3])] = TRANS(.tool_pos[1],.tool_pos[2],.tool_pos[3],0,0,0)
            POINT TEMP_TOOL=DEF_TOOL[.rno,VAL($prm[TASKNO,3])]
            ;動作コマンド実行時は異なるツール番号の時だけ更新する
            ;同じツール番号で設定変更した場合はここで即時更新する
            DECOMPOSE .toolprm[1]=DEF_TOOL[.rno,VAL($prm[TASKNO,3])]
            ;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdsetparam() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",VAL($prm[TASKNO,3])
                PRINT "->cmdsetparam() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
            END
            IF .rno==1 THEN
                ZL3LINKX 1: .toolprm[1]
                ZL3LINKX2 1: .toolprm[2]
                ZL3LINKH1 1: .toolprm[3]
            ELSE
                ZL3LINKX 2: .toolprm[1]
                ZL3LINKX2 2: .toolprm[2]
                ZL3LINKH1 2: .toolprm[3]
            END
            IF DEBUG.PRT.CMD==TRUE THEN
                PRINT "->cmdsetparam() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
            END
        VALUE CMD_SET_CORD:
            DATA_TEACHCOORDINATE = VAL($prm[TASKNO,2])
        VALUE CMD_SET_HOME:
            .homeno=VAL($prm[TASKNO,2])
            IF .homeno!=1 && .homeno!=2 THEN
                .ret=err_bad_homeno
                RETURN
            END
            ;$prm[TASKNO,3]-$prm[TASKNO,7]=JT1-JT6,$prm[TASKNO,8]=精度
            ;タブレット送信データ並び順=JT1,JT2,JT3,JT4,Ext1
            POINT .#buf=#PPOINT(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),0,0)
            IF .rno==0 THEN
                .ret = err_bad_homeno
                RETURN
            END
            GETULIMIT .rno: .#ulim
            GETLLIMIT .rno: .#llim
            DECOMPOSE .ulim[1] = .#ulim
            DECOMPOSE .llim[1] = .#llim
            FOR .i = 1 TO 4
                IF .ulim[.i]<VAL($prm[TASKNO,2+.i]) OR .llim[.i]>VAL($prm[TASKNO,2+.i]) THEN
                    ;動作範囲外を越えている場合はエラー
                    .ret = err_bad_homeno
                    RETURN
                END
            END
            .hacc=VAL($prm[TASKNO,8])
            IF .hacc<1 OR .hacc>100 THEN
                .ret = err_bat_value
                RETURN
            END
            POINT #ROBOT_HOME[.rno,.homeno]=.#buf
            ROBOT_HACC[.rno,.homeno]=.hacc
            IF .homeno==1 THEN
                IF .rno==ROBOT_ALL THEN
                    SETHOME ROBOT_MASTER: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                    SETHOME ROBOT_SLAVE: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                ELSE
                    SETHOME .rno: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                END
            ELSE
                IF .rno==ROBOT_ALL THEN
                    SET2HOME ROBOT_MASTER: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                    SET2HOME ROBOT_SLAVE: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                ELSE
                    SET2HOME .rno: ROBOT_HACC[.rno,.homeno],#ROBOT_HOME[.rno,.homeno]
                END
            END
        VALUE CMD_SET_SIGNAME:
            IF VAL($prm[TASKNO,2]) < 0 THEN
                .ret=err_bad_tableno
                RETURN
            END
            IF VAL($prm[TASKNO,3]) < 0 THEN
                .ret=err_bad_tableno
                RETURN
            END
            $DATA_IO_NUM[VAL($prm[TASKNO,2])]=$prm[TASKNO,3]
            $DATA_IO_NAME[VAL($prm[TASKNO,2])]=$prm[TASKNO,4]
        VALUE CMD_SET_SIGNUM:
            IF VAL($prm[TASKNO,2]) < 0 THEN
                .ret=err_bad_tableno
                RETURN
            END
            DATA_IO_TABLENUM = VAL($prm[TASKNO,2])
        VALUE CMD_SET_L2EXETBL:
            IF VAL($prm[TASKNO,3]) < 0 THEN
                .ret=err_bad_tableno
                RETURN
            END
            DATA_L2TBL_SIGNUM[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])]=VAL($prm[TASKNO,4])
            DATA_L2TBL_STATUS[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])]=VAL($prm[TASKNO,5])
        VALUE CMD_SET_HANDIO:
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .ret=err_bad_rno
                    RETURN
                VALUE ROBOT_MASTER,ROBOT_SLAVE:
                    FOR .i=3 TO 4
                        CALL get_iotype(VAL($prm[TASKNO,.i]),.sigtype,.ret)
                        IF .ret<>err_no_error then
                            .ret = err_bad_signo
                            RETURN
                        END
                        IF .sigtype==IO_DI OR .sigtype==IO_INT THEN
                            ;入力信号と内部信号はエラーにする
                            .ret = err_bad_signo
                            RETURN
                        END
                    END
                    DATA_HAND_TYPE[.rno]=VAL($prm[TASKNO,2])
                    DATA_HAND_IO[.rno,1]=VAL($prm[TASKNO,3])
                    DATA_HAND_IO[.rno,2]=VAL($prm[TASKNO,4])
                    DATA_HAND_IO[.rno,3]=VAL($prm[TASKNO,5])
                    DATA_HAND_IO[.rno,4]=VAL($prm[TASKNO,6])
                ANY
                    .ret=err_bad_rno
                    RETURN
            END
        VALUE CMD_SET_VTB:
            .vtblno=VAL($prm[TASKNO,2])
            IF .vtblno<=0 THEN
                .ret=err_bad_tableno
                RETURN
            END
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .ret=err_bad_rno
                    RETURN
                VALUE ROBOT_MASTER,ROBOT_SLAVE:
                    DATA_VS_CAM_NUM[.vtblno]=VAL($prm[TASKNO,4])
                    DATA_VS_CALC_NUM[.vtblno]=VAL($prm[TASKNO,5])
                    DATA_VS_CAM_TYPE[.vtblno]=VAL($prm[TASKNO,6])
                    DATA_VS_HOLD_TYPE[.vtblno]=VAL($prm[TASKNO,7])
                    DATA_VS_CALC_POS[.vtblno]=VAL($prm[TASKNO,8])
                    $DATA_VS_NAME[.vtblno]=$prm[TASKNO,9]
                    DATA_VS_ROBOT[.vtblno]=VAL($prm[TASKNO,10])
                    ;ビジョンID変換
                    CALL convert_vid(MODE_ADD,DATA_VS_CALC_POS[.vtblno],VAL($prm[TASKNO,3]),DATA_VS_VID[.vtblno])
                ANY
                    .ret=err_bad_rno
                    RETURN
            END
        VALUE CMD_SET_VTBNUM:
            CASE .rno OF
                VALUE ROBOT_ALL:
                    .ret=err_bad_rno
                    RETURN
                VALUE ROBOT_MASTER,ROBOT_SLAVE:
                    DATA_VS_TBNUM=VAL($prm[TASKNO,2])
                ANY
                    .ret=err_bad_rno
                    RETURN
            END
        VALUE CMD_SET_LOWSPAREA:
            IF VAL($prm[TASKNO,2])<=0 OR 4<VAL($prm[TASKNO,2]) THEN; エリア番号[1-4]確認
                .ret=err_bad_areano
                RETURN
            END
            FOR .i=3 TO 6
                CALL setparam_range($prm[TASKNO,.i],"REAL",-10000,10000,FALSE,.lowsp_area[.i-2],.ret); 領域最小値[-10000]・最大値[10000]確認
                IF .ret<>err_no_error GOTO end
            END
            IF .lowsp_area[1]>=.lowsp_area[3] OR .lowsp_area[2]>=.lowsp_area[4] THEN; 最小値と最大値を逆に設定していないか確認
                .ret=err_bat_value
                RETURN
            END
            IF VAL($prm[TASKNO,7])<=0 OR 100<VAL($prm[TASKNO,7]) THEN; 速度[1-100]確認
                .ret=err_bad_speed
                RETURN
            END
            ;取得ASコマンドが存在しないためGETコマンド用に暫定保持
            AREASLOW_LOCATION[VAL($prm[TASKNO,2]),1]=.lowsp_area[1]
            AREASLOW_LOCATION[VAL($prm[TASKNO,2]),2]=.lowsp_area[2]
            AREASLOW_LOCATION[VAL($prm[TASKNO,2]),3]=.lowsp_area[3]
            AREASLOW_LOCATION[VAL($prm[TASKNO,2]),4]=.lowsp_area[4]
            AREASLOW_RATE[VAL($prm[TASKNO,2])]=VAL($prm[TASKNO,7])
            ZAREASLOWSET VAL($prm[TASKNO,2]): .lowsp_area[1],.lowsp_area[2],.lowsp_area[3],.lowsp_area[4]
            ZAREASLOWRATE VAL($prm[TASKNO,2]): VAL($prm[TASKNO,7])
        VALUE CMD_SET_LOWSPSETTING:
            ;取得ASコマンドが存在しないためGETコマンド用に暫定保持
            AREASLOW_MODE=VAL($prm[TASKNO,2])
            IF VAL($prm[TASKNO,2])==OFF THEN
                ZAREASLOWMODE OFF
            ELSE
                ZAREASLOWMODE ON
            END
        VALUE CMD_SET_ZEROING:
            CALL cmdzero(.rno,VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3]),.ret)
        VALUE CMD_SET_COLCHKMOVE:
            ;ダイレクトティーチモード及びタブレットティーチモード中は実行禁止 15/11/27 add Y.Fujimoto
            IF ROBOT_MODE==MODE_TABLET AND ROBOT_MODE_FLG==FALSE THEN
              .flg=VAL($prm[TASKNO,2])
              CALL chg_colcalflg(.flg)
            END
        VALUE CMD_SET_SLOWLIMIT:
            IF $prm[TASKNO,4]=="1234" THEN
              SLOWLIMIT_ENA=1
              SLOWLIMIT_SPEED=VAL($prm[TASKNO,2])
              SLOWLIMIT_TIME=VAL($prm[TASKNO,3])
            ELSE
              IF VAL($prm[TASKNO,3])>100 OR VAL($prm[TASKNO,3])<1 THEN
                .ret = err_bat_value
                RETURN
              END
              IF VAL($prm[TASKNO,4])>1000 OR VAL($prm[TASKNO,4])<0 THEN
                .ret = err_bat_value
                RETURN
              END
              SLOWLIMIT_ENA=VAL($prm[TASKNO,2])
              SLOWLIMIT_SPEED=VAL($prm[TASKNO,3])
              SLOWLIMIT_TIME=VAL($prm[TASKNO,4])
            END
        VALUE CMD_SET_INTFPARAM:
            FOR .i=2 TO 5
                CALL setparam_range($prm[TASKNO,.i],"REAL",0.1,10000,FALSE,.intf_tool[.i-1],.ret); 領域最小値[0.1]・最大値[10000]確認
                IF .ret<>err_no_error GOTO end
            END
            CALL setparam_range($prm[TASKNO,6],"REAL",0.1,10000,FALSE,.intf_link1r,.ret)
            IF .ret<>err_no_error GOTO end
            CALL setparam_range($prm[TASKNO,7],"REAL",0.1,10000,FALSE,.intf_link2r,.ret)
            IF .ret<>err_no_error GOTO end
            IF .rno==0 OR .rno==1 THEN
                ZINTFTOOLMDL 1:.intf_tool[1],.intf_tool[2],.intf_tool[3],.intf_tool[4]
                ZINTFXLINKRAD  1:.intf_link1r
                ZINTFXLINK2RAD  1:.intf_link2r
            END
            IF .rno==0 OR .rno==2 THEN
                ZINTFTOOLMDL 2:.intf_tool[1],.intf_tool[2],.intf_tool[3],.intf_tool[4]
                ZINTFXLINKRAD  2:.intf_link1r
                ZINTFXLINK2RAD  2:.intf_link2r
            END
.*ASソフト完成までの暫定処理(返信用データは受信データとする)
            FOR .i=2 TO 7
                IF .rno==0 THEN
                  IF .i==2 THEN
                    $set_intf_param[1] = $prm[TASKNO,.i]
                    $set_intf_param[2] = $prm[TASKNO,.i]
                  ELSE
                    $set_intf_param[1] = $set_intf_param[1]+","+$prm[TASKNO,.i]
                    $set_intf_param[2] = $set_intf_param[2]+","+$prm[TASKNO,.i]
                  END
                ELSE
                  IF .i==2 THEN
                    $set_intf_param[.rno] = $prm[TASKNO,.i]
                  ELSE
                    $set_intf_param[.rno] = $set_intf_param[.rno]+","+$prm[TASKNO,.i]
                  END
                END
            END
        VALUE CMD_EXE_SA:
            mode_sa = VAL($prm[TASKNO,2])
            sa_tool[1] = VAL($prm[TASKNO,3])
            sa_tool[2] = VAL($prm[TASKNO,4])
            sa_param[1,1] = VAL($prm[TASKNO,5])
            sa_param[1,2] = VAL($prm[TASKNO,6])
            sa_param[1,3] = VAL($prm[TASKNO,7])
            sa_param[1,4] = VAL($prm[TASKNO,8])
            sa_param[2,1] = VAL($prm[TASKNO,9])
            sa_param[2,2] = VAL($prm[TASKNO,10])
            sa_param[2,3] = VAL($prm[TASKNO,11])
            sa_param[2,4] = VAL($prm[TASKNO,12])
            $sa_param = $prm[TASKNO,2]
            FOR .i=5 TO 12
                $sa_param = $sa_param+","+$prm[TASKNO,.i]
            END
            flg_sa_change = 3
        VALUE CMD_EXE_FLASH:
            CALL setparam_range($prm[TASKNO,2],"REAL",0,100,TRUE,CHECK_LAMP_TIME,.ret)
            CALL setparam_range($prm[TASKNO,3],"INT",1,100,TRUE,CHECK_LAMP_CNT,.ret)
            CALL setparam_range($prm[TASKNO,4],"INT",0,1,TRUE,CHECK_LAMP_MODE,.ret)
            EXOUT_BOTH_FLASH_MODE = TRUE
        VALUE CMD_SET_GENPARAM:
            .pno = VAL($prm[TASKNO,2])
            CASE .pno OF
              VALUE 1:; 安全距離
                IF .rno<>1 AND .rno<>2 THEN; ロボット番号確認[1-2]
                    .ret=err_bad_rno
                    RETURN
                END
                chk_gohome[.rno] = VAL($prm[TASKNO,3])
              VALUE 2:; ツール間距離
                chk_dist_here = VAL($prm[TASKNO,3])
              ANY
                .ret=err_bad_ptype
            END
        VALUE CMD_SET_COLR:
            .colr_type = VAL($prm[TASKNO,2])
            .pno = VAL($prm[TASKNO,3])
            CASE .colr_type OF
                VALUE 1:;衝突検知
                    FOR .i = 4 TO 9
                        IF VAL($prm[TASKNO,.i])<0 OR VAL($prm[TASKNO,.i])>1000 THEN
                            .ret=err_bat_value
                            RETURN
                        END
                    END
                    COLR .rno:VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),VAL($prm[TASKNO,9])
                VALUE 2:;衝撃検知
                    FOR .i = 4 TO 9
                        IF VAL($prm[TASKNO,.i])<0 OR VAL($prm[TASKNO,.i])>500 THEN
                            .ret=err_bat_value
                            RETURN
                        END
                    END
                    COLRJ .rno:VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),VAL($prm[TASKNO,9])
                ANY
                    .ret=err_bad_ptype
            END
        VALUE CMD_SET_WSET
            ;作業グルーピング設定
            IF VAL($prm[TASKNO,2])==1 THEN
                DATA_WSET_ENA = 1; 有効
                CALL get_workno(.work_no,.ret)
                .ret = err_no_error
                data_cur_workno = .work_no
            ELSE
                DATA_WSET_ENA = 0; 無効(1以外は全て無効とする)
                data_cur_workno = -999
            END
            .work_num = VAL($prm[TASKNO,3])
            IF .work_num<MIN_WORKNUM OR MAX_WORKNUM<.work_num THEN
                .ret = err_bad_ptype
            ELSE
                DATA_CUR_MAXNUM = .work_num
            END
        VALUE CMD_SET_WSPEC
            ;作業グループ番号指定方法設定
            .spec = VAL($prm[TASKNO,2])
            IF .spec<0 OR 1<.spec THEN
                .ret=err_bad_ptype
            ELSE
                IF .spec==1 THEN; タブレット
                    DATA_WSET_SPEC = .spec
                    DATA_WSET_SET[1] = 0
                    DATA_WSET_SET[2] = 0
                ELSE; 信号入力
                    .signo = VAL($prm[TASKNO,3])
                    CALL get_iotype(.signo,.sigtype,.ret)
                    IF .ret<>err_no_error OR .sigtype==IO_DO THEN
                        .ret=err_bad_signo
                    ELSE
                        IF VAL($prm[TASKNO,4])<1 OR 8<VAL($prm[TASKNO,4]) THEN
                            .ret=err_bad_ptype
                        ELSE
                            .signo2 = .signo+(VAL($prm[TASKNO,4])-1)
                            CALL get_iotype(.signo2,.sigtype,.ret)
                            IF .ret<>err_no_error OR .sigtype==IO_DO THEN
                                .ret=err_bad_signo
                            ELSE
                                DATA_WSET_SPEC = .spec
                                DATA_WSET_SET[1] = .signo
                                DATA_WSET_SET[2] = VAL($prm[TASKNO,4])
                            END
                        END
                    END
                END
            END
        VALUE CMD_SET_WNO:
            .work_no = VAL($prm[TASKNO,2])
            IF .work_no<1 OR MAX_WORKNUM<.work_no THEN
                .ret = err_bad_ptype
            ELSE
                DATA_WSET_NO = .work_no
            END
        ANY
            .ret=err_cmd_type
    END
end:
.END

.PROGRAM setparam_range(.$strings,.$prm_type,.lower,.upper,.prm_mode,.param,.ret)
;-------------------------------- 
;機能：文字列を数値に上下限つきで変換
;引数：設定値(文字列)、設定値形式、設定値丸め処理（「FALSE」の時、範囲外の場合はエラーとする）、上限、下限
;戻値：設定値(数値)、成否
;-------------------------------- 
    .ret = err_no_error
    .param = VAL(.$strings); 文字列を数値に変換
    IF .$prm_type== "INT" THEN
      .param = INT(.param+0.5)
    END
    IF .param<.lower THEN; 下限確認
      IF .prm_mode==TRUE THEN
        .param = .lower
      ELSE
        .ret = err_bat_value
        RETURN
      END
    END
    IF .upper<.param THEN; 上限確認
      IF .prm_mode==TRUE THEN
        .param = .upper
      ELSE
        .ret = err_bat_value
        RETURN
      END
    END
.END

.PROGRAM nameset(.cmd,.ret)
;-------------------------------- 
;機能：名称設定コア
;引数：文字列配列
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CASE .cmd OF
        VALUE CMD_SET_L1INFO:
            $DATA_CUR_L1NAME = $prm[TASKNO,2]
            DATA_L2NUM = VAL($prm[TASKNO,3])
        VALUE CMD_SET_L2INFO:
            $DATA_L2NAME[VAL($prm[TASKNO,2])]=$prm[TASKNO,3]
            DATA_L3NUM[VAL($prm[TASKNO,2])]=VAL($prm[TASKNO,4])
            DATA_L2EXETBLNUM[VAL($prm[TASKNO,2])]=VAL($prm[TASKNO,5])
            IF $prm[TASKNO,6]=="1234" THEN
                DATA_L2WORKNO[VAL($prm[TASKNO,2])]=0
            ELSE
                DATA_L2WORKNO[VAL($prm[TASKNO,2])]=VAL($prm[TASKNO,6])
            END
        VALUE CMD_SET_L3INFO:
            $DATA_L3NAME[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])]=$prm[TASKNO,4]
        VALUE CMD_SET_WINFO:
            ;作業グループ名称設定
            .wno = VAL($prm[TASKNO,2])
            IF .wno<1 OR MAX_WORKNUM<.wno THEN
                .ret=err_bad_ptype
            ELSE
                $DATA_WORKNAME[.wno] = $prm[TASKNO,3]
            END
        ANY
            .ret = err_bad_name
    END
.END

.PROGRAM setstep(.ret)
;-------------------------------- 
;機能：作業情報の設定コア
;引数：実数配列
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .l2num=VAL($prm[TASKNO,2])
    .l3num=VAL($prm[TASKNO,3])
    .l3type=VAL($prm[TASKNO,4])
    NOEXIST_SET_S $prm[TASKNO,10]="0"
    .sp=VAL($prm[TASKNO,10])
    IF .l3type==L3TYPE_MOVE AND (.sp<=0 OR .sp>100) THEN
        PRINT "TASKNO=",TASKNO,", err_bad_speed"
        .ret=err_bad_speed
        RETURN
    END
    $DATA_L3NAME[.l2num,.l3num]=$prm[TASKNO,5]
    DATA_L3TYPE[.l2num,.l3num] = .l3type    ; @@@ ADD 20140926 A.kobayashi
    DATA_ROBOTTYPE[.l2num,.l3num]=VAL($prm[TASKNO,1])
    ;.prm[5]以降が設定データ
    CASE .l3type OF
        VALUE L3TYPE_MOVE:
            DATA_VISION_STATUS[.l2num,.l3num]=VAL($prm[TASKNO,6])
            ;ビジョンID変換(引数順でID割当番号)
            DATA_VISION_ID1[.l2num,.l3num] = VAL($prm[TASKNO,7])
            CALL convert_vid(MODE_ADD,TYPE_POS,VAL($prm[TASKNO,8]),DATA_VISION_ID2[.l2num,.l3num])
            CALL convert_vid(MODE_ADD,TYPE_POS,VAL($prm[TASKNO,9]),DATA_VISION_ID3[.l2num,.l3num])
            DATA_REPSPEED[.l2num,.l3num]=VAL($prm[TASKNO,10])
            DATA_POSTYPE[.l2num,.l3num]=VAL($prm[TASKNO,11])
            DATA_WAIT_BEFORE[.l2num,.l3num]=VAL($prm[TASKNO,12])
            DATA_WAIT_AFTER[.l2num,.l3num]=VAL($prm[TASKNO,13])
            IF $prm[TASKNO,14]=="1234" THEN
              $prm[TASKNO,14]=$ENCODE(DATA_ACC)
              $prm[TASKNO,15]=$ENCODE(DATA_DEC)
              $prm[TASKNO,16]=$ENCODE(DATA_ACCU)
              $prm[TASKNO,17]="0"
            END
            IF VAL($prm[TASKNO,16])<=0 THEN
              $prm[TASKNO,16]="0.01"
            END
            DATA_ACCEL[.l2num,.l3num]=VAL($prm[TASKNO,14])
            DATA_DECEL[.l2num,.l3num]=VAL($prm[TASKNO,15])
            DATA_ACCURACY[.l2num,.l3num]=VAL($prm[TASKNO,16])
            DATA_ABSSP_MODE[.l2num,.l3num]=VAL($prm[TASKNO,17])
        VALUE L3TYPE_IO_WAIT:
            DATA_SIGNUM[.l2num,.l3num]=VAL($prm[TASKNO,6])
            DATA_SIGSTATUS[.l2num,.l3num]=VAL($prm[TASKNO,7])
            DATA_WAIT_BEFORE[.l2num,.l3num]=VAL($prm[TASKNO,8])
            DATA_WAIT_AFTER[.l2num,.l3num]=VAL($prm[TASKNO,9])
            DATA_WAIT_TIMEOUT[.l2num,.l3num]=VAL($prm[TASKNO,10])
            IF $prm[TASKNO,11]=="1234" THEN
              DATA_WAIT_TOCON[.l2num,.l3num]=0
            ELSE
              DATA_WAIT_TOCON[.l2num,.l3num]=VAL($prm[TASKNO,11])
            END
        VALUE L3TYPE_IO_CHANGE:
            DATA_SIGNUM[.l2num,.l3num]=VAL($prm[TASKNO,6])
            DATA_SIGSTATUS[.l2num,.l3num]=VAL($prm[TASKNO,7])
            DATA_WAIT_BEFORE[.l2num,.l3num]=VAL($prm[TASKNO,8])
            DATA_WAIT_AFTER[.l2num,.l3num]=VAL($prm[TASKNO,9])
            DATA_KEEP_WAIT[.l2num,.l3num]=VAL($prm[TASKNO,10])
        VALUE L3TYPE_CSTART,L3TYPE_CEND,L3TYPE_WSTART,L3TYPE_WEND,L3TYPE_RETURN:
            ;No need parameters for this commands.
        VALUE L3TYPE_VISION,L3TYPE_CALVISION:
            DATA_VISION_CALPOS[.l2num,.l3num]=VAL($prm[TASKNO,7])
            IF $prm[TASKNO,8]=="1234" THEN
              DATA_VISION_CNT[.l2num,.l3num]=0
            ELSE
              DATA_VISION_CNT[.l2num,.l3num]=VAL($prm[TASKNO,8]); ビジョンNG続行フラグ(0:停止,1:続行)
            END
            ;ビジョンID変換
            CALL convert_vid(MODE_ADD,VAL($prm[TASKNO,7]),VAL($prm[TASKNO,6]),DATA_VISION_ID[.l2num,.l3num])
        VALUE L3TYPE_L2RESET:
            DATA_L2RESETNUM[.l2num,.l3num]=VAL($prm[TASKNO,6])
        VALUE L3TYPE_HAND_CHANGE:
            DATA_HAND_CTL[.l2num,.l3num]=VAL($prm[TASKNO,6])
        VALUE L3TYPE_COLCHK:
            DATA_COLCHK[.l2num,.l3num]=VAL($prm[TASKNO,6])
        VALUE L3TYPE_IFGOTO:
            DATA_L3IFGOTO_ID[.l2num,.l3num]=VAL($prm[TASKNO,6])
            DATA_L3IFGOTO_LABEL[.l2num,.l3num]=VAL($prm[TASKNO,7])
        VALUE L3TYPE_IFLABEL:
            DATA_L3LABEL[.l2num,.l3num]=VAL($prm[TASKNO,6])
        VALUE L3TYPE_CNT:
            DATA_CNTID[.l2num,.l3num]=VAL($prm[TASKNO,6])
            DATA_CNTTYPE[.l2num,.l3num] = VAL($prm[TASKNO,7])
        VALUE L3TYPE_CNTSET:
            DATA_CNTID[.l2num,.l3num]=VAL($prm[TASKNO,6])
            DATA_CNTVAL[.l2num,.l3num]=VAL($prm[TASKNO,7])
        VALUE L3TYPE_STOP:
            DATA_RESTART_FLG[.l2num,.l3num]=VAL($prm[TASKNO,6])
        ANY
            .ret=err_bad_l3type
    END
.END

.PROGRAM setsteppos(.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .l2num=VAL($prm[TASKNO,2])
    .l3num=VAL($prm[TASKNO,3])
    DATA_MODE[.l2num,.l3num]=VAL($prm[TASKNO,4])
    DATA_TOOL[.l2num,.l3num] = VAL($prm[TASKNO,5])
    ;並び替え
    IF DATA_MODE[.l2num,.l3num]==MODE_JT THEN
        DATA_POS1[.l2num,.l3num]=VAL($prm[TASKNO,5+1]);JT1
        DATA_POS2[.l2num,.l3num]=VAL($prm[TASKNO,5+2]);JT2
        DATA_POS3[.l2num,.l3num]=VAL($prm[TASKNO,5+3]);JT3
        DATA_POS4[.l2num,.l3num]=VAL($prm[TASKNO,5+4]);JT4
        DATA_POS5[.l2num,.l3num]=0;固定
        DATA_POS6[.l2num,.l3num]=0;固定
    ELSE
        DATA_POS1[.l2num,.l3num]=VAL($prm[TASKNO,5+1]);X
        DATA_POS2[.l2num,.l3num]=VAL($prm[TASKNO,5+2]);Y
        DATA_POS3[.l2num,.l3num]=VAL($prm[TASKNO,5+3]);Z
        DATA_POS4[.l2num,.l3num]=VAL($prm[TASKNO,5+4]);R1
        DATA_POS5[.l2num,.l3num]=0;固定
        DATA_POS6[.l2num,.l3num]=0;固定
    END
.END

.PROGRAM setstepifgoto(.ret)
;-------------------------------- 
;機能：作業用条件分岐詳細設定コア
;引数：2:第2階層番号、3:第3階層番号、4:条件番号、
;      5:分岐指定、6:分岐判断種類、7:分岐判断材料、8:分岐判定閾値
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    .l2num = VAL($prm[TASKNO,2])
    .l3num = VAL($prm[TASKNO,3])
    .ifconid = VAL($prm[TASKNO,4])
    DATA_IFMODE[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,5])
    DATA_IFTYPE[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,6])
    DATA_IFITEM[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,7])
    DATA_IFCNT[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,8])
.END
.REALS
MODE_TCP = 0
MODE_UDP = 1
MODE_CTYPE = 0
.END

.REALS
ip[0] = 0
ip[1] = 0
ip[2] = 0
ip[3] = 0
.*動作コマンド用
.*送信
port_udp[0] = 60001
.*受信
port_udp[1] = 60002
.*非動作コマンド用
.*送信
port_udppc[0] = 60003
.*受信
port_udppc[1] = 60004
TCP_SID[0] = -1
TCP_SID[1] = -1
TCP_SID_PORT[0] = -1
TCP_SID_PORT[1] = -1
TCP_CONNECTED[0] = 0
TCP_CONNECTED[1] = 0
TCP_TIMEOUT = 0.5
TCP_LISTEN_LOCK = 0
TCP_LISTEN_SID[0] = 0
TCP_LISTEN_SID[1] = 0
TCP_LISTEN_PORT[0] = 60001
TCP_LISTEN_PORT[1] = 60003
.END

.REALS
TYPE_OPEN = 0
TYPE_RECV = 1
TYPE_SEND = 2
.END

.PROGRAM get_cominfo(.type,.tcp_port,.tcp_sid,.tcp_sid_num,.udp_port)
;-------------------------------- 
;機能：通信ターゲット情報取得
;引数：なし
;戻値：受信文字列、成否
;-------------------------------- 
    .tcp_port=-1
    .tcp_sid=-1
    .tcp_sid_num=-1
    .udp_port=-1
    .task_no=TASKNO
    CASE .type OF
        VALUE TYPE_OPEN:
            IF .task_no==PG_COM_ACT THEN
                ;動作命令用(PCプログラム)
                .tcp_port=TCP_LISTEN_PORT[0]
                .tcp_sid_num=0
            ELSE
                IF .task_no==PG_COM_NOACT THEN
                    ;非動作命令用(PCプログラム)
                    .tcp_port=TCP_LISTEN_PORT[1]
                    .tcp_sid_num=1
                ELSE
                    PRINT "TYPE_OPEN -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
                    RETURN
                END
            END
        VALUE TYPE_RECV:
            IF .task_no==PG_COM_ACT THEN
                ;動作命令用(PCプログラム)
                .udp_port=port_udp[1]
                .tcp_sid=TCP_SID[0]
            ELSE
                IF .task_no==PG_COM_NOACT THEN
                    ;非動作命令用(PCプログラム)
                    .udp_port=port_udppc[1]
                    .tcp_sid=TCP_SID[1]
                ELSE
                    PRINT "TYPE_RECV -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
                END
            END
        VALUE TYPE_SEND:
            IF .task_no==PG_MASTER OR .task_no==PG_SLAVE OR .task_no==PG_COM_ACT OR .task_no==1001 THEN
                ;動作命令用(メインプログラム、もしくはPCプログラム)
                .udp_port=port_udp[0]
                .tcp_sid=TCP_SID[0]
            ELSE
                IF .task_no==PG_COM_NOACT THEN
                    ;非動作命令用(PCプログラム)
                    .udp_port=port_udppc[0]
                    .tcp_sid=TCP_SID[1]
                ELSE
                    PRINT "TYPE_SEND -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
                END
            END
    END
.END

.PROGRAM check_disp_sockinfo(.$buf,.flg_disp)
;-------------------------------- 
;機能：プロトコル詳細デバッグフラグ設定
;引数：受信文字列
;戻値：デバッグ文表示フラグ
;-------------------------------- 
    .flg_disp=TRUE
    IF DEBUG.PRT.PROC==TRUE THEN
        RETURN
    END
    IF TASKNO==1006 AND (INSTR(.$buf,"1017")<>0 OR INSTR(.$buf,"1001")<>0 OR INSTR(.$buf,"1015")<>0 OR INSTR(.$buf,"1005")<>0 OR INSTR(.$buf,"1006")<>0 OR INSTR(.$buf,"1010")<>0 OR INSTR(.$buf,"1011")<>0 OR INSTR(.$buf,"1018")<>0) THEN
        .flg_disp=FALSE
    END
.END

.PROGRAM recv(.$str,.ret)
;-------------------------------- 
;機能：UDP受信処理(動作プログラム用)
;引数：なし
;戻値：受信文字列、成否
;-------------------------------- 
    .$str = ""
    .$cmd[1]=""
    .ret=-1
    .timeout=TCP_TIMEOUT

    ;受信先選択
    CALL get_cominfo(TYPE_RECV,.nouse,.sid,nouse,.port)

    IF (.sid==-1) OR ((TASKNO==1005) AND (TCP_RECONNECT_BUSY[0]==TRUE)) OR ((TASKNO==1006) AND (TCP_RECONNECT_BUSY[1]==TRUE)) THEN
        IF (TCP_RECONNECT_BUSY[0]==TRUE) OR (TCP_RECONNECT_BUSY[1]==TRUE) THEN
            PRINT "recv()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
        END
        RETURN
    END

    ;受信処理開始
    IF MODE_CTYPE==MODE_UDP THEN
        UDP_RECVFROM .ret, .port, .$cmd[1], .len, .timeout, ip[0],255
    ELSE
        IF .sid!=-1 THEN
            TCP_RECV .ret, .sid, .$cmd[1], .num, .timeout,255
        END
    END
    IF .ret==0 THEN
        IF .$cmd[1]=="" THEN
            .ret=-1
        ELSE
            .$str = .$cmd[1]
            IF DEBUG.PRT.SOCK==TRUE THEN
                CALL check_disp_sockinfo(.$cmd[1],.flg_disp)
                IF .flg_disp==TRUE THEN
                    PRINT "TASKNO=",TASKNO," recv()->.sid=",.sid," port=",.port,",.$cmd[1]=",.$cmd[1]
                END
            END
        END
    END

    ;受信文字列保存
    IF .ret==0 THEN
      CALL commu_log(2,.$str)
    END
.END

.PROGRAM send(.$str,.ret)
;-------------------------------- 
;機能：UDP送信処理(動作プログラム専用)
;引数：送信文字列
;戻値：成否
;-------------------------------- 
    .ret=-1
    .$buf[1] = .$str
    .timeout=TCP_TIMEOUT
    
    ;送信先選択
    CALL get_cominfo(TYPE_SEND,.nouse,.sid,nouse,.port)

    IF (.sid==-1) OR ((TASKNO==1005) AND (TCP_RECONNECT_BUSY[0]==TRUE)) OR ((TASKNO==1006) AND (TCP_RECONNECT_BUSY[1]==TRUE)) THEN
        IF (TCP_RECONNECT_BUSY[0]==TRUE) OR (TCP_RECONNECT_BUSY[1]==TRUE) THEN
            PRINT "send()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
        END
        RETURN
    END

    ;送信処理開始
    IF MODE_CTYPE==MODE_UDP THEN
        UDP_SENDTO .ret, ip[0], .port, .$buf[1], 1, .timeout
    ELSE
        ;CALL tcp_open(1,.ret)
        IF .sid!=-1 THEN
            TCP_SEND .ret,.sid,.$buf[1],1,.timeout
        ELSE
            IF DEBUG.PRT.SOCK==TRUE THEN
                PRINT "send NG .sid=-1"
            END
        END
    END
    IF DEBUG.PRT.SOCK==TRUE THEN
        CALL check_disp_sockinfo(.$buf[1],.flg_disp)
        IF .flg_disp==TRUE THEN
            PRINT "TASKNO=",TASKNO," send()->.sid=",.sid," port=",.port,",.$buf[1]=",.$buf[1],".ret=",.ret
        END
    END

    ;送信文字列保存
    CALL commu_log(1,.$str)
.END

.PROGRAM tcp_open(.timeout,.ret)
;---------------------------------------------------
;機能:TCP/IP通信開始（サーバ側)(動作命令用ポートオープン)
;　　 同時接続数1でクライアント側任意のタイミングで接続切断繰返しに対応
;引数:タイムアウト
;戻値:成否
;---------------------------------------------------
    .ret = err_no_error
    TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
    IF TCP_LISTEN_LOCK==FALSE AND .num==0 THEN
        TCP_CONNECTED[0]=FALSE
        TCP_SID[0]=-1
        TCP_SID_PORT[0]=-1
        TCP_CONNECTED[1]=FALSE
        TCP_SID[1]=-1
        TCP_SID_PORT[1]=-1
        IF DEBUG.PRT.SOCK==TRUE THEN
            PRINT "tcp_open()->TCP_LISTEN START port_tcp[0]=",TCP_LISTEN_PORT[0]
            PRINT "tcp_open()->TCP_LISTEN START port_tcp[1]=",TCP_LISTEN_PORT[1]
        END
        TCP_LISTEN .ret,TCP_LISTEN_PORT[0]
        TCP_LISTEN .ret,TCP_LISTEN_PORT[1]
        TCP_LISTEN_LOCK = TRUE
        ;LISTENポートの保存
        TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
        FOR .i=0 TO .num-1
            IF .port_no[.i]==TCP_LISTEN_PORT[0] THEN
                TCP_LISTEN_SID[0] = .sid[.i]
                PRINT "tcp_open()->TCP_LISTEN_PORTSID[0]=",TCP_LISTEN_SID[0]
            END
            IF .port_no[.i]==TCP_LISTEN_PORT[1] THEN
                TCP_LISTEN_SID[1] = .sid[.i]
                PRINT "tcp_open()->TCP_LISTEN_PORTSID[1]=",TCP_LISTEN_SID[1]
            END
        END
    END

    ;オープン先選択
    CALL get_cominfo(TYPE_OPEN,.port,.nouse,.idnum,.nouse)
    
    ;オープン受付処理開始
    TCP_ACCEPT .sid[0],.port,.timeout,ip[0]
    IF .sid[0] < 0 THEN
        .ret = -1
        RETURN
    ELSE
        IF .port==TCP_LISTEN_PORT[0] THEN
            TCP_RECONNECT_BUSY[0]=TRUE
        ELSE
            TCP_RECONNECT_BUSY[1]=TRUE
        END
        ;初期接続、もしくは再接続
        TCP_CONNECTED[.idnum]=TRUE
        ;ポート入替対策、再接続中のsend()/recv()エラー対策
        FOR .i=0 TO 1
            IF TCP_SID_PORT[.i]==.port THEN
                PRINT "tcp_open()->DELETE TCP-PORT SETTINGS FOR RECONNECT. i=",.i
                TCP_CONNECTED[.i]=FALSE
            END
        END
        IF DEBUG.PRT.SOCK==TRUE THEN
            PRINT "tcp_open()->NEW TCP_ACCEPT .sid[0]=",.sid[0]," .port=",.port
        END
        ;TCP_STATUSで取得できないのでSIDに対応するポート仮記録
        .new_port=.port
        ;ACCEPTした新しいSIDを仮記録
        .new_sid=.sid[0]
        ;前回ACCEPTしたポートを閉じる
        TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
        FOR .i=0 TO .num-1
            ;LISTENポートはCLOSEしない
            ;SIDチェック
            IF (.sid[.i]<>TCP_LISTEN_SID[0]) AND (.sid[.i]<>TCP_LISTEN_SID[1]) THEN
                ;開きなおし対象ポート検索
                ;SIDチェック
                FOR .j=0 TO 1
                    IF (.sid[.i]==TCP_SID[.j]) THEN
                        IF .new_port==TCP_SID_PORT[.j] THEN
                            IF DEBUG.PRT.SOCK==TRUE THEN
                                PRINT "tcp_open()->CLOSING .sid[i]=",.sid[.i]," .new_port=",.new_port
                            END
                            TCP_CLOSE .ret,.sid[.i]
                            IF .ret < 0 THEN
                                .ret=-1
                            ELSE
                                CALL updateTCPInfo(.sid[.i])
                                GOTO 10
                            END
                        END
                    END
                END
            END
        END
10
        ;ACCEPTした新しいSIDの仮記憶をグローバル変数のSIDに上書き
        PRINT "tcp_open()->NEW->.port=",.new_port,",.sid=",.new_sid
        TCP_SID[.idnum] = .new_sid
        ;TCP_STATUSで取得できないのでSIDに対応するポート記録
        TCP_SID_PORT[.idnum]=.new_port
        IF .port==TCP_LISTEN_PORT[0] THEN
            TCP_RECONNECT_BUSY[0]=FALSE
        ELSE
            TCP_RECONNECT_BUSY[1]=FALSE
        END
    END
.END

.PROGRAM tcp_close()
;---------------------------------------------------
;機能:TCP/IP 通信終了（サーバ側）
;引数:.sock_id
;戻値:.port
;---------------------------------------------------
    .ret = err_no_error
    ;ポート閉処理
    TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
    IF DEBUG.PRT.SOCK==TRUE THEN
        PRINT "tcp_close()->TCP_STATUS .num=",.num
    END
    IF .num <= 0 THEN
        IF DEBUG.PRT.SOCK==TRUE THEN
            PRINT "tcp_close()->TCP_CLOSE <no connection>"
        END
        RETURN
    ELSE
        FOR .i=0 TO .num-1
            ;LISTENポートは閉じない
            IF (.sid[.i]<>TCP_LISTEN_SID[0]) AND (.sid[.i]<>TCP_LISTEN_SID[1]) THEN
                IF DEBUG.PRT.SOCK==TRUE THEN
                    PRINT "tcp_close()->TCP_CLOSE .sid=",.sid[.i]
                END
                TCP_CLOSE .ret,.sid[.i]
                IF .ret < 0 THEN
                    .ret=-1
                ELSE
                    CALL updateTCPInfo(.sid[.i])
                END
            END
        END
    END
.END

.PROGRAM updateTCPInfo(.sid)
;---------------------------------------------------
;機能:TCP接続情報の初期化
;引数:SID
;戻値:なし
;---------------------------------------------------
    FOR .j=0 TO 1
        IF TCP_SID[.j]==.sid THEN
            IF TCP_SID_PORT[.j]==TCP_LISTEN_PORT[0] THEN
                PRINT "updateTCPInfo()->TCP_CLOSE port=",TCP_LISTEN_PORT[0],",.sid=",.sid
                TCP_CONNECTED[0]=FALSE
                TCP_SID[0]=-1
                TCP_SID_PORT[0]=-1
            ELSE
                PRINT "updateTCPInfo()->TCP_CLOSE port=",TCP_LISTEN_PORT[1],",.sid=",.sid
                TCP_CONNECTED[1]=FALSE
                TCP_SID[1]=-1
                TCP_SID_PORT[1]=-1
            END
        END
    END
.END
                        
.PROGRAM tcp_check(.num,.ret)
;---------------------------------------------------
;機能:TCP接続状態の確認
;引数:なし
;戻値:接続数、成否
;---------------------------------------------------
    .ret = err_no_error
    TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
    IF DEBUG.PRT.SOCK==TRUE THEN
        PRINT "TCP_STATUS .num=",.num
        IF .num > 0 THEN
            FOR .i=0 TO .num-1
                PRINT ".port_no[",.i,"]=",.port_no[.i]," .sid[",.i,"]=",.sid[.i]," .ecode[",.i,"]=",.ecode[.i]," .scode[",.i,"]=",.scode[.i]
            END
        END
    END
.END
.*****************************************************
.*  定数定義ファイル
.*  変数として扱いたい情報はini.pgに記載すること
.*  定数定義ファイルはロボット動作中のロード可
.*****************************************************

.STRINGS
$appli_ver_tbl = "ADU00005 2016/06/06";半角20文字まで
.END


.REALS
MODE_CUSTOMER = 0
.END

.REALS
.*ロボット状態遷移変数
robot_status_max = 9
sta_direct = 5
sta_error = 2
sta_exe = 3
sta_gen = 7
sta_gravityadj = 9
sta_hold = 1
sta_l2exe = 4
sta_nomove = 0
sta_tablet = 6
sta_vscalib = 8
.END

.REALS
.*停止後ロボット操作不許可フラグ(-1:操作不許可、0:操作許可)
DISABLE_READJ_POS = -1
.END

.REALS
.*第2階層作業起動条件設定(-1:条件起動不可、0:条件起動可)
DISABLE_L2CHK = 0
.END

.REALS
.*並列実行機能設定(-1:並列実行不可、0:並列実行可)
DISABLE_WCMD = 0
.END

.REALS
.*作業再開機能設定(-1:作業再開不可、0:作業再開可)
DISABLE_CONTINUE = 0
FLG_MASTER_CON = 0
FLG_SLAVE_CON = 0
.END

.REALS
.*教示操作(MODE_XYZR1EXT1、MODE_TOOL)RZ回転設定(-1:マスタースレーブハンド中心位置旋回、0:マスターハンド先端位置旋回)
DISABLE_AVETOOL = 0
.END

.REALS
.*************
.*エラーコード
.*************
err_no_error = 0

.*制御用エラーコード
err_robot_busy = 1000
err_poweron = 1001
err_teach_lock = 1002
err_repeat = 1003
err_pccom_start = 1007
err_motor_off = 1011
err_cs_off = 1012
err_main_stop = 1013
err_main_start = 1014
err_robotmode = 1015
err_extio_unknown = 1016
err_extio_disable = 1017
err_extio_change = 1018
err_roboterror[0] = 1020;ロボット本体異常発生中（2台同時発生中）
err_roboterror[1] = 1021;下アーム異常発生中
err_roboterror[2] = 1022;上アーム異常発生中
err_emg_stop = 1023;非常停止中
err_out_range = 1024;目標位置動作範囲外
err_cant_convert = 2000
err_sig_timeout = 2002
err_exe_name = 2003
err_emg_on = 2004
err_bad_axesno = 2009
err_bad_areano = 2010
err_bad_position = 2011
err_gravityadj = 2012
err_l3type_stop = 2013
err_gen_noptn = 2030
err_gen_jt1 = 2031
err_gen_jt2 = 2032
err_gen_base[1] = 2033
err_gen_base[2] = 2034
err_gen_pos = 2035
err_bat_value = 2036
err_work_set = 2037
err_work_unmatch = 2038

.*コマンド用エラーコード
err_cmd_type = 3000
err_cmd_prmnum = 3001
err_bad_mode = 3003
err_bad_ptype = 3004
err_bad_name = 3005
err_bad_num = 3006
err_bad_l3type = 3007
err_bad_rno = 3008
err_cmd_timeout = 3009
err_srobot_timeout = 3010
err_srobot_error = 3011
err_bad_homeno = 3012
err_bad_signo = 3013
err_bad_tableno = 3014
err_bad_speed = 3015
err_bad_handio = 3016
err_robot_cmon = 3018
err_chg_sp = 3019
err_bad_visionnum = 3020
err_still_working = 3021

.*ビジョン用エラーコード
err_vis_cmd = 4001
err_vis_cam = 4002
err_vis_setting = 4003
err_vis_measure = 4004
err_vis_nocalib = 4005
err_vis_recog0 = 4006
err_vis_teach = 4020
err_vis_lesspos = 4050
err_vis_poschk = 4051
err_vis_distchk = 4052
err_vis_calst = 4061
err_vis_calmeas = 4062
err_vis_calend = 4063
err_vis_chkng = 4064
err_vis_contng = 4070
err_vis_locmas = 4080
err_vis_locsla = 4081
err_vis_only = 4088
err_vis_unknow = 4089
err_vis_send = 4091
err_vis_recv = 4092
err_vis_tout1 = 4093
err_vis_tout2 = 4094
err_vis_tout3 = 4095
err_vis_tout4 = 4096
err_vis_tout5 = 4097
err_vis_tout6 = 4098
err_vis_tout7 = 4099

.*内部制御用エラーコード(タブレットに表示されたら実装不具合、関数戻り値で使用するためerr_*で番号重複管理対象とする)
err_slave_actend = 5001
err_l3_actend = 5002
.END

.REALS
.*************
.*内部制御
.*************

.*ロボットモード(0:タブレット、1:ティーチ)
ROBOT_MODE = 0
ROBOT_MODE_FLG = 0
MODE_TABLET = 0
MODE_DIRECT = 1

.*TASKNOプログラムチェック番号
PG_MASTER = 1
PG_SLAVE = 2

.*PCプログラム番号
PG_COM_ACT = 1005
PG_COM_NOACT = 1006

.*タイムアウト設定
BOOT_TIMEOUT = 10
SLAVE_TIMEOUT = 100
MASTER_TIMEOUT = 10
WAIT_MASTE_TIMEOUT = 1
WAIT_SLAVE_TIMEOUT = 1
EXTOUT_FLASHTIME = 0.5
POWER_TIMEOUT = 0.1

.*教示画面位置指定移動時速度設定mm/sec
SAFTY_MOVE_SP = 102;原点復帰、指定位置移動とティーチ移動のJMOVEに使用（現状102以下に設定してはいけない）
SAFTY_LMOVE_SP = 120;指定位置移動とティーチ移動のLMOVEのみに使用（現状102以下に設定してはいけない）

.*************
.* 信号設定
.*************

.* サイクルタイム計測用信号
ix_cycle_time = 2001

.*リセット信号設定
SIG_EXT_REBOOT = 2002

.* 信号待ちＮＧ(タイムアウト)信号
ix_iowait_to[1] = 2051
ix_iowait_to[2] = 2052

.* ビジョン並列インターロック信号
ix_vloc_mas = 2110;                        ビジョン並列作業インターロック(マスター)
ix_vloc_sla = 2111;                        ビジョン並列作業インターロック(スレーブ) 
ix_vloc_now = 2112;                        ビジョン並列作業インターロック(スレーブロック確認中) 

.* ビジョン結果ＮＧ信号
ix_result_vng[1] = 2113
ix_result_vng[2] = 2114

.*専用信号出力設定
SIG_EMG_OUTPUT = 2099
SIG_R1GEN1_OUTPUT = 2097
SIG_R2GEN1_OUTPUT = 2098
SIG_R1GEN2_OUTPUT = 2095
SIG_R2GEN2_OUTPUT = 2096

.*外部制御パネル入力信号割付
.*FOR REAL
REAL_START_BUTTON = 1017
REAL_STOP_BUTTON = 1018
REAL_TEACH_TGLSW = 1019
REAL_REPEAT_TGLSW = 1020
.*FOR DEBUG
SIM_START_BUTTON = 2017
SIM_STOP_BUTTON = 2018
SIM_TEACH_TGLSW = 2019
SIM_REPEAT_TGLSW = 2020
.*FOR OFF
OFF_TEACH_TGLSW = 2019
OFF_REPEAT_TGLSW = 2019
.*内部制御用(シミュレータと実機で分岐設定処理有)
.*EXTIN_START_BUTTON = 0
.*EXTIN_STOP_BUTTON = 0
.*EXTIN_TEACH_TGLSW = 0
.*EXTIN_REPEAT_TGLSW = 0
WAIT_EXTIN_TIME = 1
EXTOUT_START_BUTTON = 17
EXTOUT_STOP_BUTTON = 18
EXOUT_START_FLASH_MODE = 0
EXOUT_STOP_FLASH_MODE = 0
EXOUT_BOTH_FLASH_MODE = 0
FLG_L2CHK_WAIT = 0
.* ビジョンシミュレーションフラグ
VSIM_FLG = 0
.* ビジョンシミュレーション補正量
VSIM_X = 0
VSIM_Y = 0
VSIM_Z = 0

.*ROBOT種類
ROBOT_ALL = 0
ROBOT_MASTER = 1
ROBOT_SLAVE = 2

.*コマンド種類
CMD_GET_INFO = 1001
CMD_GET_L1INFO = 1002
CMD_GET_L2INFO = 1003
CMD_GET_L3INFO = 1004
CMD_GET_SP = 1005
CMD_GET_PITCH = 1006
CMD_GET_CORD = 1007
CMD_GET_TNUM = 1008
CMD_GET_TOOL = 1009
CMD_GET_POS = 1010
CMD_GET_IO = 1011
CMD_GET_HOME = 1012
CMD_GET_SIGNAME = 1013
CMD_GET_SIGNUM = 1014
CMD_GET_MONSP = 1015
CMD_GET_L2EXETBL = 1016
CMD_GET_INFOEX = 1017
CMD_GET_HAND = 1018
CMD_GET_HANDIO = 1019
CMD_GET_VTB = 1020
CMD_GET_VTBNUM = 1021
CMD_GET_VRESULT = 1022
CMD_GET_ROBOTMODE = 1023
CMD_GET_LOWSPAREA = 1024
CMD_GET_LOWSPSETTING = 1025
CMD_GET_GRAVITYADJMOVE = 1026
CMD_GET_COLCHKMOVE = 1027
CMD_GET_SLOWLIMIT = 1028
CMD_GET_SA = 1029
CMD_GET_VERSION = 1030
CMD_GET_INTFPARAM = 1031
CMD_GET_IOSTAT = 1032
CMD_GET_COUNT = 1033
CMD_GET_GENPARAM = 1034
CMD_GET_COLR = 1035
CMD_GET_WSET = 1036
CMD_GET_WSPEC = 1037
CMD_GET_WNO = 1038
CMD_GET_WINFO = 1039

CMD_SET_SP = 1101
CMD_SET_PITCH = 1102
CMD_SET_CORD = 1103
CMD_SET_TNUM = 1104
CMD_SET_TOOL = 1105
CMD_SET_HOME = 1106
CMD_SET_SIGNAME = 1107
CMD_SET_SIGNUM = 1108
CMD_SET_L2EXETBL = 1109
CMD_SET_HANDIO = 1110
CMD_SET_VTB = 1111
CMD_SET_VTBNUM = 1112
CMD_SET_LOWSPAREA = 1113
CMD_SET_LOWSPSETTING = 1114
CMD_SET_ZEROING = 1115
CMD_SET_COLCHKMOVE = 1116
CMD_SET_SLOWLIMIT = 1117
CMD_SET_INTFPARAM = 1118
CMD_SET_GENPARAM = 1119
CMD_SET_COLR = 1120
CMD_SET_WSET = 1121
CMD_SET_WSPEC = 1122
CMD_SET_WNO = 1123

CMD_SET_L1INFO = 1201
CMD_SET_L2INFO = 1202
CMD_SET_L3INFO = 1203
CMD_SET_WINFO = 1204

CMD_GET_STEP = 1301
CMD_GET_STEPPOS = 1302
CMD_GET_STEPIFGOTO = 1303
CMD_SET_STEP = 1401
CMD_SET_STEPPOS = 1402
CMD_SET_STEPIFGOTO = 1403

CMD_EXE_RESET = 1501
CMD_EXE_GEN = 1502
CMD_EXE_TEACH = 1503
CMD_EXE_START = 1504
CMD_EXE_HOLD = 1505
CMD_EXE_ABORT = 1506
CMD_EXE_MOVE = 1507
CMD_EXE_IO = 1508
CMD_EXE_RESTART = 1509
CMD_EXE_VISION = 1510
CMD_EXE_MONSP = 1511
CMD_EXE_L2EXE = 1512
CMD_EXE_HAND = 1513
CMD_EXE_RESETIO = 1514
CMD_EXE_WAITEND = 1515
CMD_EXE_ROBOTMODE = 1516
CMD_EXE_GRAVITYADJ = 1517
CMD_EXE_VSCALIB = 1518
CMD_EXE_SA = 1519
CMD_EXE_FLASH = 1520
CMD_EXE_VLESCAL = 1521
CMD_EXE_VCALCHK = 1522
CMD_EXE_CON = 1601
CMD_EXE_ONE = 1602

.*コマンド応答待ち種類
.*実行完了を保証する=1/実行完了前に応答する=0
CMD_TYPE_WAIT = 1
CMD_TYPE_NO_WAIT = 0
CMD_WAIT_TYPE[1001] = 1
CMD_WAIT_TYPE[1002] = 1
CMD_WAIT_TYPE[1003] = 1
CMD_WAIT_TYPE[1004] = 1
CMD_WAIT_TYPE[1005] = 1
CMD_WAIT_TYPE[1006] = 1
CMD_WAIT_TYPE[1007] = 1
CMD_WAIT_TYPE[1008] = 1
CMD_WAIT_TYPE[1009] = 1
CMD_WAIT_TYPE[1010] = 1
CMD_WAIT_TYPE[1011] = 1
CMD_WAIT_TYPE[1012] = 1
CMD_WAIT_TYPE[1013] = 1
CMD_WAIT_TYPE[1014] = 1
CMD_WAIT_TYPE[1015] = 1
CMD_WAIT_TYPE[1016] = 1
CMD_WAIT_TYPE[1017] = 1
CMD_WAIT_TYPE[1018] = 1
CMD_WAIT_TYPE[1019] = 1
CMD_WAIT_TYPE[1020] = 1
CMD_WAIT_TYPE[1021] = 1
CMD_WAIT_TYPE[1022] = 1
CMD_WAIT_TYPE[1023] = 1
CMD_WAIT_TYPE[1024] = 1
CMD_WAIT_TYPE[1025] = 1
CMD_WAIT_TYPE[1026] = 1
CMD_WAIT_TYPE[1027] = 1
CMD_WAIT_TYPE[1028] = 1
CMD_WAIT_TYPE[1029] = 1
CMD_WAIT_TYPE[1030] = 1
CMD_WAIT_TYPE[1031] = 1
CMD_WAIT_TYPE[1032] = 1
CMD_WAIT_TYPE[1033] = 1
CMD_WAIT_TYPE[1034] = 1
CMD_WAIT_TYPE[1035] = 1
CMD_WAIT_TYPE[1036] = 1
CMD_WAIT_TYPE[1037] = 1
CMD_WAIT_TYPE[1038] = 1
CMD_WAIT_TYPE[1039] = 1

CMD_WAIT_TYPE[1101] = 1
CMD_WAIT_TYPE[1102] = 1
CMD_WAIT_TYPE[1103] = 1
CMD_WAIT_TYPE[1104] = 1
CMD_WAIT_TYPE[1105] = 1
CMD_WAIT_TYPE[1106] = 1
CMD_WAIT_TYPE[1107] = 1
CMD_WAIT_TYPE[1108] = 1
CMD_WAIT_TYPE[1109] = 1
CMD_WAIT_TYPE[1110] = 1
CMD_WAIT_TYPE[1111] = 1
CMD_WAIT_TYPE[1112] = 1
CMD_WAIT_TYPE[1113] = 1
CMD_WAIT_TYPE[1114] = 1
CMD_WAIT_TYPE[1115] = 1
CMD_WAIT_TYPE[1116] = 1
CMD_WAIT_TYPE[1117] = 1
CMD_WAIT_TYPE[1118] = 1
CMD_WAIT_TYPE[1119] = 1
CMD_WAIT_TYPE[1120] = 1
CMD_WAIT_TYPE[1121] = 1
CMD_WAIT_TYPE[1122] = 1
CMD_WAIT_TYPE[1123] = 1

CMD_WAIT_TYPE[1201] = 1
CMD_WAIT_TYPE[1202] = 1
CMD_WAIT_TYPE[1203] = 1
CMD_WAIT_TYPE[1204] = 1

CMD_WAIT_TYPE[1301] = 1
CMD_WAIT_TYPE[1302] = 1
CMD_WAIT_TYPE[1303] = 1
CMD_WAIT_TYPE[1401] = 1
CMD_WAIT_TYPE[1402] = 1
CMD_WAIT_TYPE[1403] = 1

CMD_WAIT_TYPE[1501] = 1
CMD_WAIT_TYPE[1502] = 0
CMD_WAIT_TYPE[1503] = 0
CMD_WAIT_TYPE[1504] = 0
CMD_WAIT_TYPE[1505] = 1
CMD_WAIT_TYPE[1506] = 1
CMD_WAIT_TYPE[1507] = 0
CMD_WAIT_TYPE[1508] = 1
CMD_WAIT_TYPE[1509] = 1
CMD_WAIT_TYPE[1510] = 1
CMD_WAIT_TYPE[1511] = 0
CMD_WAIT_TYPE[1512] = 0
CMD_WAIT_TYPE[1513] = 1
CMD_WAIT_TYPE[1514] = 0
CMD_WAIT_TYPE[1515] = 1
CMD_WAIT_TYPE[1516] = 1
CMD_WAIT_TYPE[1517] = 0
CMD_WAIT_TYPE[1518] = 0
CMD_WAIT_TYPE[1519] = 0
CMD_WAIT_TYPE[1520] = 0
CMD_WAIT_TYPE[1521] = 0
CMD_WAIT_TYPE[1522] = 0

CMD_WAIT_TYPE[1601] = 0
CMD_WAIT_TYPE[1602] = 0

.*コマンド実行方法種類
.*動作プログラム=1/非動作プログラム=0
CMD_TYPE_MONPG = 1
CMD_TYPE_PCPG  = 0
CMD_EXEC_TYPE[1001] = 0
CMD_EXEC_TYPE[1002] = 0
CMD_EXEC_TYPE[1003] = 0
CMD_EXEC_TYPE[1004] = 0
CMD_EXEC_TYPE[1005] = 0
CMD_EXEC_TYPE[1006] = 0
CMD_EXEC_TYPE[1007] = 0
CMD_EXEC_TYPE[1008] = 0
CMD_EXEC_TYPE[1009] = 0
CMD_EXEC_TYPE[1010] = 0
CMD_EXEC_TYPE[1011] = 0
CMD_EXEC_TYPE[1012] = 0
CMD_EXEC_TYPE[1013] = 0
CMD_EXEC_TYPE[1014] = 0
CMD_EXEC_TYPE[1015] = 0
CMD_EXEC_TYPE[1016] = 0
CMD_EXEC_TYPE[1017] = 0
CMD_EXEC_TYPE[1018] = 0
CMD_EXEC_TYPE[1019] = 0
CMD_EXEC_TYPE[1020] = 0
CMD_EXEC_TYPE[1021] = 0
CMD_EXEC_TYPE[1022] = 0
CMD_EXEC_TYPE[1023] = 0
CMD_EXEC_TYPE[1024] = 0
CMD_EXEC_TYPE[1025] = 0
CMD_EXEC_TYPE[1026] = 0
CMD_EXEC_TYPE[1027] = 0
CMD_EXEC_TYPE[1028] = 0
CMD_EXEC_TYPE[1029] = 0
CMD_EXEC_TYPE[1030] = 0
CMD_EXEC_TYPE[1031] = 0
CMD_EXEC_TYPE[1032] = 0
CMD_EXEC_TYPE[1033] = 0
CMD_EXEC_TYPE[1034] = 0
CMD_EXEC_TYPE[1035] = 0
CMD_EXEC_TYPE[1036] = 0
CMD_EXEC_TYPE[1037] = 0
CMD_EXEC_TYPE[1038] = 0
CMD_EXEC_TYPE[1039] = 0

CMD_EXEC_TYPE[1101] = 0
CMD_EXEC_TYPE[1102] = 0
CMD_EXEC_TYPE[1103] = 0
CMD_EXEC_TYPE[1104] = 0
CMD_EXEC_TYPE[1105] = 0
CMD_EXEC_TYPE[1106] = 0
CMD_EXEC_TYPE[1107] = 0
CMD_EXEC_TYPE[1108] = 0
CMD_EXEC_TYPE[1109] = 0
CMD_EXEC_TYPE[1110] = 0
CMD_EXEC_TYPE[1111] = 0
CMD_EXEC_TYPE[1112] = 0
CMD_EXEC_TYPE[1113] = 0
CMD_EXEC_TYPE[1114] = 0
CMD_EXEC_TYPE[1115] = 0
CMD_EXEC_TYPE[1116] = 0
CMD_EXEC_TYPE[1117] = 0
CMD_EXEC_TYPE[1118] = 0
CMD_EXEC_TYPE[1119] = 0
CMD_EXEC_TYPE[1120] = 0
CMD_EXEC_TYPE[1121] = 0
CMD_EXEC_TYPE[1122] = 0
CMD_EXEC_TYPE[1123] = 0

CMD_EXEC_TYPE[1201] = 0
CMD_EXEC_TYPE[1202] = 0
CMD_EXEC_TYPE[1203] = 0
CMD_EXEC_TYPE[1204] = 0

CMD_EXEC_TYPE[1301] = 0
CMD_EXEC_TYPE[1302] = 0
CMD_EXEC_TYPE[1303] = 0
CMD_EXEC_TYPE[1401] = 0
CMD_EXEC_TYPE[1402] = 0
CMD_EXEC_TYPE[1403] = 0

CMD_EXEC_TYPE[1501] = 1
CMD_EXEC_TYPE[1502] = 1
CMD_EXEC_TYPE[1503] = 1
CMD_EXEC_TYPE[1504] = 1
CMD_EXEC_TYPE[1505] = 0
CMD_EXEC_TYPE[1506] = 0
CMD_EXEC_TYPE[1507] = 1
CMD_EXEC_TYPE[1508] = 0
CMD_EXEC_TYPE[1509] = 0
CMD_EXEC_TYPE[1510] = 0
CMD_EXEC_TYPE[1511] = 0
CMD_EXEC_TYPE[1512] = 1
CMD_EXEC_TYPE[1513] = 0
CMD_EXEC_TYPE[1514] = 0
CMD_EXEC_TYPE[1515] = 0
CMD_EXEC_TYPE[1516] = 0
CMD_EXEC_TYPE[1517] = 1
CMD_EXEC_TYPE[1518] = 1
CMD_EXEC_TYPE[1519] = 0
CMD_EXEC_TYPE[1520] = 0
CMD_EXEC_TYPE[1521] = 0
CMD_EXEC_TYPE[1522] = 1

CMD_EXEC_TYPE[1601] = 1
CMD_EXEC_TYPE[1602] = 1

.*補間方法種類
MODE_LMOVE = 0
MODE_JMOVE = 1

.*動作方法種類
MODE_JT = 0
MODE_XYZR1EXT1 = 1

.*手動教示時の動作座標系種類
MODE_TOOL = 1
MODE_BASE = 0

.*ハンド種類
HAND_SINGLE = 0
HAND_DOUBLE = 1
HAND_CLOSE = 0
HAND_OPEN = 1

.*IO種類
IO_DO = 0
IO_DI = 1
IO_INT = 2
IO_UNKNOWN = 3

.*第3階層種類
L3TYPE_IO_WAIT = 0
L3TYPE_IO_CHANGE = 1
L3TYPE_MOVE = 2
L3TYPE_CSTART = 3
L3TYPE_CEND = 4
L3TYPE_VISION = 5
L3TYPE_WSTART = 6
L3TYPE_WEND = 7
L3TYPE_L2RESET = 8
L3TYPE_HAND_CHANGE = 9
L3TYPE_CALVISION = 10
L3TYPE_COLCHK = 11
L3TYPE_RETURN = 12
L3TYPE_IFGOTO = 13
L3TYPE_IFLABEL = 14
L3TYPE_CNT = 15
L3TYPE_CNTSET = 16
L3TYPE_STOP = 17

.*IFGOTO条件判定種類
IFCON_CNT = 1
IFCON_IO = 2
IFCON_FLG = 3

.*不等号種類
.*[>=]greater than or equal
INEQ_SIGN_GTEQ = 4
.*[<=]less than or equal
INEQ_SIGN_LTEQ = 3
.*[=]equal
INEQ_SIGN_EQ = 1
.*[<>]not equal
INEQ_SIGN_NOTEQ = 2

.*内部制御用カウンタ数上限値
MAX_CNTNUM = 99

.*内部制御用作業グループ数上限値
MIN_WORKNUM = 0
MAX_WORKNUM = 99

.*ロボット動作状態
.*非動作中
STATUS_NOMOVE = 0
.*動作中
STATUS_MOVE = 1
.*HOLD中
STATUS_HOLD = 2

.*計測箇所
TYPE_POS = 0
TYPE_DEVICE1 = 1
TYPE_DEVICE2 = 2
TYPE_DEVICE3 = 3
OFFSET_DEVICE1NUM = 1000
OFFSET_DEVICE2NUM = 2000
OFFSET_DEVICE3NUM = 3000
.*計測箇所3箇所個別最大数(ビジョンID3個の場合は×3)
MAX_VISIONID_NUM = 1000
MODE_ADD = 0
MODE_DEL = 1

.*軸種別
MODE_LIN = 0
MODE_ROT = 1
MODE_NONE = -1

.*外部軸種別
EXTTYPE_NONE = 0
EXTTYPE_ROT = 1
EXTTYPE_LINEAR = 2

.*CコンRUNタイム
ascycle = 0.016
.END
.PROGRAM SAVMOD
;-------------------------------- 
;ダイレクトティーチ用プログラム
;引数：無し
;戻値：無し
;--------------------------------
    IF DISABLE_READJ_POS==TRUE THEN
        ;停止位置記憶有効フラグ
        FLG_ENABLE_STOPPOS=FALSE
    END
    NOEXIST_SET_R FLG_SA_CHANGE = OFF
    FLG_DIRECT_RUN = TRUE
    PRINT "Booted DIrect-teach program. This program name is SAV."
    IF (ROBOT_MODE<>MODE_DIRECT) OR (ROBOT_MODE_FLG==FALSE) THEN
        RETURN
    END
    IF TASKNO==ROBOT_MASTER THEN
        GETULIMIT 1:.#ulim
        GETLLIMIT 1:.#llim
    ELSE
        GETULIMIT 2:.#ulim
        GETLLIMIT 2:.#llim
    END
    FOR .i = 1 TO 4;本体軸のみ
        .ulim[.i] = DEXT(.#ulim,.i)
        .llim[.i] = DEXT(.#llim,.i)
        .lim[.i] = ABS(.ulim[.i])+ABS(.llim[.i])-1;上下限の絶対値の和をそのまま使うと、下アームのJT1のみ本体異常となる場合があり、念のため全軸1引いた値にしておく
    END
    SADEGREE .lim[1],.lim[2],.lim[3],.lim[4]
    SAENVCHKOFF
    SAGAIN 1,1,1,1
    SASTART
    DO
  	    IF (FLG_SA_CHANGE BAND TASKNO) <> 0 THEN
           SAEND
           .lock = NOT( sa_param[TASKNO,1] OR sa_param[TASKNO,2] OR sa_param[TASKNO,3] OR sa_param[TASKNO,4])
           IF .lock==ON THEN
              SAGAIN 100,100,100,100
           ELSE
    	        CASE mode_sa
    	         VALUE SA.JT
  	               FOR .jt=1 TO 4
                       .sa_gain[.jt] = 100-sa_param[TASKNO,.jt]*99;規制しない軸はGAIN 1
  	               END
                   SAGAIN .sa_gain[1],.sa_gain[2],.sa_gain[3],.sa_gain[4]
    	         VALUE SA.BASE
                   SAGAIN sa_gain_org[1],sa_gain_org[2],sa_gain_org[3],sa_gain_org[4]
                   SAXYZ sa_param[TASKNO,1],sa_param[TASKNO,2],sa_param[TASKNO,3],sa_param[TASKNO,4]
    	         VALUE SA.TOOL
                   SAGAIN sa_gain_org[1],sa_gain_org[2],sa_gain_org[3],sa_gain_org[4]
                   SATXYZ sa_param[TASKNO,1],sa_param[TASKNO,2],sa_param[TASKNO,3],sa_param[TASKNO,4]
    	        END
    	     END
           FLG_SA_CHANGE = FLG_SA_CHANGE BAND (COM TASKNO)
           SASTART
  	    END
  	    TWAIT 0.016
    UNTIL ((ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG==TRUE));プログラム終了後status_check関数が反応してエラー状態に遷移する
    SAEND
    SAENVCHKON
    FLG_DIRECT_RUN = FALSE
.END
.REALS
SA.JT = 0
SA.BASE = 1
SA.TOOL = 2
.* sa_gain_org[] : ソフトアブソーバBASE,TOOL時のゲイン
sa_gain_org[1] = 5
sa_gain_org[2] = 5
sa_gain_org[3] = 5
sa_gain_org[4] = 5
.END
.PROGRAM gravityadj_core(.rno,.mode,.setval,.ret)
;-------------------------------- 
;重力補償自動調整処理
;引数：ロボット番号、モード(0:自動、1:手動)、ロボット番号に対応した設定値
;戻値：成否
;-------------------------------- 
    .ret=err_no_error
    ;停止位置記憶有効フラグ
    FLG_ENABLE_STOPPOS=FALSE
    PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... .rno=",.rno,",.mode=",.mode,",.setval=",.setval
    IF .mode==1 THEN
        IF .setval>=500 THEN
            .setval = 500
        END
        IF .setval<=-500 THEN
            .setval = -500
        END
        ZSAGRAV .rno:3,.setval
        GRAV_CUR_VAL[.rno-1] = .setval
    ELSE
        CALL SETGRAV(.rno,.ret)
    END
    IF .ret<>err_no_error AND TASKNO==ROBOT_SLAVE THEN
        FLG_SLAVE_GRAVERR = TRUE
    END
    NOEXIST_SET_R GRAV_CUR_VAL[0]=0
    NOEXIST_SET_R GRAV_CUR_VAL[1]=0
    PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... GRAV_CUR_VAL[0]=",GRAV_CUR_VAL[0],",GRAV_CUR_VAL[1]=",GRAV_CUR_VAL[1]
.END

.PROGRAM setgrav(.rno,.ret)
;-------------------------------- 
;重力補償自動調整実行ﾌﾟﾛｸﾞﾗﾑ
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    NOEXIST_SET_R grav_retry = 30
    NOEXIST_SET_R GRAV_CUR_VAL[0] = -25
    NOEXIST_SET_R GRAV_CUR_VAL[1] = -25
    NOEXIST_SET_R grav_chk_lim = 0.5
    NOEXIST_SET_R grav_chk_tim = 3
    NOEXIST_SET_R grav_deg = 3
    NOEXIST_SET_R grav_pul = 5
    NOEXIST_SET_R grav_ret_pul = 1
    GETULIMIT .rno:.#ulim
    GETLLIMIT .rno:.#llim
    DECOMPOSE .rno:.ulim[1] = .#ulim
    DECOMPOSE .rno:.llim[1] = .#llim
    DECOMPOSE .rno:.ho[1] = #HOME(1)
    .retry = 0;ﾘﾄﾗｲ回数ﾘｾｯﾄ
    .jt3grav = GRAV_CUR_VAL[.rno-1];重力補償値初期値設定
    .jt3pos = (.ulim[3]+.llim[3])/2;3軸初期位置
    .flg_pul = 5;重力補償値きざみﾌﾗｸﾞ初期化
    .jt3gravpul = grav_pul;重力補償値きざみ値
    .flg_finish = FALSE;重力補償設定最終段階ﾌﾗｸﾞ
    IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで適切な位置へ移動処理を入れる
        JMOVE #grav_pos[.rno]
        BREAK
    END
;
retry:
    COLROFF .rno: 
    COLRJOFF .rno: 
    PRINT TASKNO,.jt3grav
    ZSAGRAV .rno: 3,.jt3grav
    grav_cur_val[.rno-1] = .jt3grav
    DECOMPOSE .jt[1] = #S_HERE(.rno)
    SPEED 200 MM/S
    ZL3LMOVE #PPOINT(.jt[1],.jt[2],.jt3pos,.jt[4],.jt[5],.jt[6]),1,1
    BREAK
;
    SADEGREE ,,grav_deg
    SAENVCHKOFF
    SAGAIN 100,100,1,100,100,100
    .pre_jt3 = DEXT(#S_HERE(.rno),3)
    UTIMER .@tim = 0
    SASTART
    TWAIT 0.5
    DO
        .now_jt3 = DEXT(#S_HERE(.rno),3)
        IF UTIMER(.@tim)>=60 OR .retry>=grav_retry THEN ;60秒以上経過orﾘﾄﾗｲ上限を越えた
            .ret = err_gravityadj
            SAEND
            COLRON .rno: 
            COLRJON .rno: 
            SPEED 200 MM/S
            ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
            PRINT "TASKNO=",TASKNO,",ZSAGRAV Set NOT complete."
            RETURN
        END
        IF (SACHK:.rno)==0 OR (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)>grav_chk_lim) THEN ;3軸が指定動作範囲を超えたor指定時間経過後に指定角度以上3軸が動いている
            SAEND
            .retry = .retry+1
            IF .jt3pos-DEXT(#S_HERE(.rno),3)>0 THEN
                IF .flg_pul==FALSE THEN
                    .jt3gravpul = grav_ret_pul
                END
                .jt3grav = .jt3grav-.jt3gravpul
                .flg_pul = TRUE
            ELSE
                IF .flg_pul==TRUE THEN
                    .jt3gravpul = grav_ret_pul
                END
                .jt3grav = .jt3grav+.jt3gravpul
                .flg_pul = FALSE
            END
            GOTO retry
        END
        TWAIT 0.016
    UNTIL (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)<grav_chk_lim) ;指定時間以上経過しても3軸が指定値以上動いていない
    SAEND
    .jt3gravpul = grav_ret_pul
    .retry = 0
    IF .flg_finish<>TRUE THEN
        CASE .jt3pos OF
            VALUE (.ulim[3]+.llim[3])/2:
                .jt3pos = .llim[3]+1
                GOTO retry
            VALUE (.llim[3]+1):
                .jt3pos = .ulim[3]-1
                GOTO retry
            VALUE (.ulim[3]-1):
                .jt3pos = (.ulim[3]+.llim[3])/2
                .flg_finish = TRUE
                GOTO retry
        END
    END
    grav_cur_val[.rno-1] = .jt3grav
    COLRON .rno: 
    COLRJON .rno: 
    IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで初期位置に戻す。
        JMOVE #grav_pos[.rno]
        BREAK
    END
    SPEED 200 MM/S
    ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
    PRINT "TASKNO=",TASKNO,",ZSAGRAV Set complete."
    RETURN
.END

.PROGRAM vision_main(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
;-------------------------------- 
;機能：ビジョン実行
;引数：ロボット番号、ビジョンID、カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、マスター登録フラグ
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    CALL vcom_init;                              ビジョン変数初期化
    SIG -ix_result_vng[.rno];                    ビジョン結果ＮＧ信号初期化
;
    IF DEBUG.PRT.VISION==TRUE THEN
        PRINT "vision_main()->.rno=",.rno
        PRINT "vision_main()->.id=",.id
        PRINT "vision_main()->.camno=",.camno
        PRINT "vision_main()->.calno=",.calno
        PRINT "vision_main()->.camtype=",.camtype
        PRINT "vision_main()->.holdtype=",.holdtype
        PRINT "vision_main()->.calpos=",.calpos
        PRINT "vision_main()->.recflg=",.recflg
    END
;
    CALL vision_exe(.camno,.calno,.rno,.camtype,.holdtype,.recflg,.id,.calpos,.ret)
    IF .ret<>err_no_error THEN
      SIG ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
    END
    IF .recflg==OFF AND .ret==err_no_error THEN
        POINT vision_shift[.rno,.id] = -v_master[.id,1]+vwork[.id,1]
    ELSE
        ;マスター登録時はシフト量0
        POINT vision_shift[.rno,.id] = TRANS(0,0,0,0,0,0)
    END
    IF DEBUG.PRT.VISION==TRUE THEN
        DECOMPOSE .buf[1] = vision_shift[.rno,.id]
        PRINT "vision_main()->XYR1(TRANS)=",$ENCODE(.buf[1]),",",$ENCODE(.buf[2]),",",$ENCODE(.buf[3]),",",$ENCODE(.buf[4]),",",$ENCODE(.buf[5]),",",$ENCODE(.buf[6])
    END
.END

.PROGRAM calvision(.rno,.id,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン計算実行
;引数：ロボット番号、ビジョンID()、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正)
;戻値：成否
;-------------------------------- 
    .ret = err_no_error
    SIG -ix_result_vng[.rno]; ビジョンＮＧ信号初期化
;
    IF DEBUG.PRT.VISION==TRUE THEN
        PRINT "calvision()->TASKNO=",TASKNO
        PRINT "calvision()->ROBOT No.=",.rno
        PRINT "calvision()->.id=",.id
        PRINT "calvision()->.calpos=",.calpos
    END
    ; ID変換
    CALL convert_vid(mode_add,1,.id,.vid1);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
    CALL convert_vid(mode_add,2,.id,.vid2);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
    ; 装置補正計測フラグONチェック
    IF vequip_flg[.vid1]!=ON OR vequip_flg[.vid2]!=ON THEN
        .ret = err_vis_lesspos
        IF log_error_ena<>FALSE THEN
          CALL error_log(.ret)
        END
        SIG ix_result_vng[.rno]; ビジョンＮＧ信号ＯＮ
        RETURN
    END
;
    NOEXIST_SET_R vc_chkflg[.id] = OFF
    IF vc_chkflg[.id]<>OFF THEN
      ; 位置ズレチェック
      .dist1 = DISTANCE(v_master[.vid1,1],vwork[.vid1,1]); 装置1点目の位置ズレ量
      .dist2 = DISTANCE(v_master[.vid2,1],vwork[.vid2,1]); 装置2点目の位置ズレ量
      NOEXIST_SET_R vc_poschk[.id] = 100
      IF .dist1>vc_poschk[.id] OR .dist2>vc_poschk[.id] THEN; 閾値判定
        .ret = err_vis_poschk
        IF log_error_ena<>FALSE THEN
          CALL error_log(.ret)
        END
        RETURN
      END
      ; 距離ズレチェック
      .dist1 = DISTANCE(v_master[.vid1,1],v_master[.vid2,1])
      .dist2 = DISTANCE(vwork[.vid1,1],vwork[.vid2,1])
      NOEXIST_SET_R vc_distchk = 5
      IF ABS(.dist1-.dist2)>vc_distchk THEN
        .ret = err_vis_distchk
        IF log_error_ena<>FALSE THEN
          CALL error_log(.ret)
        END
        RETURN
      END
    END
    ;第2、第3階層を探索
    FOR .i=1 TO DATA_L2NUM
        FOR .j=1 TO DATA_L3NUM[.i]
            IF DATA_L3TYPE[.i,.j]==L3TYPE_MOVE THEN
                IF DATA_MODE[.i,.j]==MODE_JT THEN
                    ;各軸値
                ELSE
                    ;変換値
                    IF .id==data_vision_id1[.i,.j] THEN; 計算実行する装置IDと動作の装置ID(DATA_VISION_ID)が一致
                        POINT .in_pos = TRANS(data_pos1[.i,.j],data_pos2[.i,.j],data_pos3[.i,.j],data_pos4[.i,.j],0,0); 変換値
                        CALL vcorrect_table(.&in_pos,.id,.&out_pos); 装置補正実行
                        DECOMPOSE .out_p[1] = .out_pos; 補正後の変換値分解
                        ; 補正値を書き換え
                        data_pos1[.i,.j] = .out_p[1]
                        data_pos2[.i,.j] = .out_p[2]
                        data_pos3[.i,.j] = .out_p[3]
                        data_pos4[.i,.j] = .out_p[4]
                        data_pos5[.i,.j] = 0
                        data_pos6[.i,.j] = 0
                    END
                END
            END
        END
    END
    ; 実行後、装置補正計測結果のマスターを現在値で上書き
    POINT v_master[.vid1,1] = vwork[.vid1,1]
    POINT v_master[.vid2,1] = vwork[.vid2,1]
    ; 装置補正計測フラグOFF
    vequip_flg[.vid1] = OFF
    vequip_flg[.vid2] = OFF
    CALL vlog_cal(.vid1,.vid2,1,0)
.END

.PROGRAM get_vision_info(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン設定テーブルから条件取得
;引数：ロボット番号、ビジョンID
;戻値：カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、成否
;-------------------------------- 
    .ret = err_no_error
    ;実行中のロボット種別取得
    ;テーブル中から条件検索してあれば応答する
    FOR .i=1 TO DATA_VS_TBNUM
        IF DATA_VS_VID[.i]==.id THEN
            .camno=DATA_VS_CAM_NUM[.i]
            .calno=DATA_VS_CALC_NUM[.i]
            .camtype=DATA_VS_CAM_TYPE[.i]
            .holdtype=DATA_VS_HOLD_TYPE[.i]
            .calpos=DATA_VS_CALC_POS[.i]
            IF DEBUG.PRT.VISION==TRUE THEN
                PRINT "get_vision_info()->.rno=",.rno
                PRINT "get_vision_info()->.id=",.id
                PRINT "get_vision_info()->.camno=",.camno
                PRINT "get_vision_info()->.calno=",.calno
                PRINT "get_vision_info()->.camtype=",.camtype
                PRINT "get_vision_info()->.holdtype=",.holdtype
                PRINT "get_vision_info()->.calpos=",.calpos
            END
            RETURN
        END
    END
    .ret=err_bad_visionnum
.END

.PROGRAM get_vision_result(.id,.type,.calpos,.x,.y,.rot,.ret)
;-------------------------------- 
;機能：ビジョン計測結果取得
;引数：ビジョンID、結果種類(1:マスター、0:非マスター)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正ツール)
;戻値：X座標値、Y座標値、θ座標値、成否
;-------------------------------- 
    .ret = err_no_error
    IF DEBUG.PRT.VISION==TRUE THEN
        PRINT "get_vision_result()->.id=",.id,", .type=",.type,", .calpos=",.calpos
    END
;
    IF .calpos<>TYPE_DEVICE3 THEN
      IF .type==1 THEN
          ;マスター
          NOEXIST_SET_L v_master[.id,1] = TRANS(0,0,0,0,0,0)
          DECOMPOSE .buf[1] = v_master[.id,1]
          .x = .buf[1]
          .y = .buf[2]
          .rot = .buf[4]
      ELSE
          ;非マスター
          NOEXIST_SET_L vwork[.id,1] = TRANS(0,0,0,0,0,0)
          DECOMPOSE .buf[1] = vwork[.id,1]
          .x = .buf[1]
          .y = .buf[2]
          .rot = .buf[4]
      END
    ELSE
      ; ビジョンなし装置補正・マスター登録時のツールを返す
      NOEXIST_SET_L vless_tool[.id] = TRANS(0,0,0,0,0,0)
      DECOMPOSE .buf[1] = vless_tool[.id]
      .x = .buf[1]
      .y = .buf[2]
      .rot = .buf[4]
    END
.END

.PROGRAM check_vsl3data(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン補正設定有効・無効判定
;引数：第2階層番号、第3階層番号
;戻値：補正要否(TRUE:有効、FALSE:無効)
;-------------------------------- 
    ;ビジョン有効（初期値）
    .ret = TRUE
    IF debug.prt.visio==TRUE THEN
        PRINT "check_vs_l3data()->DATA_VISION_ID1[",.l2num,",",.l3num,"]=",DATA_VISION_ID1[.l2num,.l3num]
        PRINT "check_vs_l3data()->DATA_VISION_ID2[",.l2num,",",.l3num,"]=",DATA_VISION_ID2[.l2num,.l3num]
        PRINT "check_vs_l3data()->DATA_VISION_ID3[",.l2num,",",.l3num,"]=",DATA_VISION_ID3[.l2num,.l3num]
    END
    ;ビジョンIDが0
    IF DATA_VISION_ID2[.l2num,.l3num]==0 AND DATA_VISION_ID3[.l2num,.l3num]==0 THEN
        ;ビジョン無効
        .ret = FALSE
        RETURN
    END
    IF DEBUG.PRT.VISION==TRUE THEN
        PRINT "check_vs_l3data()->DATA_ROBOTTYPE[",.l2num,",",.l3num,"]=",DATA_ROBOTTYPE[.l2num,.l3num]
    END
    ;動作モードがXYZであることを確認
    IF DATA_MODE[.l2num,.l3num]<>MODE_XYZR1EXT1 THEN
      .ret = FALSE
      RETURN
    END
.END

.PROGRAM update_vspos(.l2num,.l3num,.#inpos,.#outpos,.ret)
;-------------------------------- 
;機能：ビジョン計測結果反映
;引数：入力変換値配列
;戻値：出力変換値配列,成否
;-------------------------------- 
    .ret = err_no_error
    DECOMPOSE .inpos[1] = .#inpos
    POINT .#outpos = .#inpos
    ;補正なしの場合は入力値はそのまま返すために出力値を入力値で初期化する
    FOR .i = 1 TO 6
        .outpos[.i] = .inpos[.i]
    END
;
    ;ビジョン補正設定有効・無効判定確認
    CALL check_vsl3data(.l2num,.l3num,.chk)
    IF .chk<>TRUE THEN
        ;ビジョン補正設定無効(エラーではない)
        RETURN
    END
    ; 補正値チェック（ビジョンNG続行フラグONなのに補正動作に来てしまった場合の対策処理）
    .id2 = DATA_VISION_ID2[.l2num,.l3num]
    .id3 = DATA_VISION_ID3[.l2num,.l3num]
    IF .id2<>0 THEN
      .$tmp = "vwork["+$ENCODE(.id2)+",1]"
      IF EXISTDATA(.$tmp,T)==OFF THEN; 補正値変数なし
        .ret = err_vis_contng; ビジョン補正作業続行不可
        RETURN
      ELSE
        IF ABS(DX(vwork[.id2,1])-vis_init)<0.1 AND ABS(DY(vwork[.id2,1])-vis_init)<0.1 THEN; 補正値変数に初期値が入っていた場合
          .ret = err_vis_contng; ビジョン補正作業続行不可
          RETURN
        END
      END
    END
    IF .id3<>0 THEN
      .$tmp = "vwork["+$ENCODE(.id3)+",1]"
      IF EXISTDATA(.$tmp,T)==OFF THEN; 補正値変数なし
        .ret = err_vis_contng; ビジョン補正作業続行不可
        RETURN
      ELSE
        IF ABS(DX(vwork[.id3,1])-vis_init)<0.1 AND ABS(DY(vwork[.id3,1])-vis_init)<0.1 THEN; 補正値変数に初期値が入っていた場合
          .ret = err_vis_contng; ビジョン補正作業続行不可
          RETURN
        END
      END
    END
    ;補正演算
    ;DATA_VISION_ID1、DATA_VISION_ID2、DATA_VISION_ID3=装置補正用ビジョンID、ワーク位置補正用ビジョンID、ツール位置補正用ビジョンIDの順番固定とする
    POINT .in = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
    CALL vcorrect(.&in,.id2,.id3,.&pos)
    DECOMPOSE .outpos[1] = .pos
    POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
.END

.PROGRAM convert_vid(.mode,.calpos,.in_id,.out_id)
;-------------------------------- 
;機能：ビジョンID変換
;引数：mode(MODE_DEL/MODE_ADD)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正)、変換元ビジョンID
;戻値：変換後ビジョンID(変換元ビジョンIDが想定外の場合でもそのまま戻す)
;-------------------------------- 
    ;初期化
    NOEXIST_SET_R .in_id=0
    .out_id=.in_id
    CASE .mode OF
        VALUE MODE_ADD:
            CASE .calpos OF
                VALUE TYPE_POS:
                    ;そのままでOK
                VALUE TYPE_DEVICE1:
                    .out_id=.in_id+OFFSET_DEVICE1NUM
                VALUE TYPE_DEVICE2:
                    .out_id=.in_id+OFFSET_DEVICE2NUM
                VALUE TYPE_DEVICE3:
                    .out_id=.in_id+OFFSET_DEVICE3NUM
            END
        VALUE MODE_DEL:
            IF .out_id>MAX_VISIONID_NUM THEN
                DO
                    .out_id=.out_id-MAX_VISIONID_NUM
                UNTIL(.out_id<MAX_VISIONID_NUM)
            END
    END
.END

.PROGRAM vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;引数：ロボット番号、カメラ番号、計測番号、カメラ種類、ターゲット位置(XYZR1)、移動距離、移動前逃げ高さ、ツール(XY)
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  gs_excalib_err = .ret
  IF DEBUG.PRT.VISIO==TRUE THEN
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .rno=",.rno
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camno=",.camno
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .calno=",.calno
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camtype=",.camtype
    DECOMPOSE .buf1[1]=.target
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_x=",.buf1[1]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_y=",.buf1[2]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_z=",.buf1[3]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_o(r1)=",.buf1[4]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_a=",.buf1[5]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_t=",.buf1[6]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .len=",.len
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .height=",.height
    DECOMPOSE .buf2[1]=.tool_p
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_x=",.buf2[1]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_y=",.buf2[2]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_z=",.buf2[3]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_o=",.buf2[4]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_a=",.buf2[5]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_t=",.buf2[6]
    PRINT "TASKNO=",TASKNO,",vision_execalib()-> .ret=",.ret
  END
  ; calib実行
  CALL vcalib_exe(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
  IF log_error_ena<>FALSE AND .ret>err_no_error THEN
    CALL error_log(.ret)
  END
  gs_excalib_err = .ret  
.END

.PROGRAM vless_calexe(.&in_pos,.&tool_p,.id,.&out_pos)
;-------------------------------- 
;機能：ビジョンなし装置補正実行
;引数：補正前データ、実行時ツール、ビジョンＩＤ、補正後データ
;戻値：なし
;-------------------------------- 
  POINT .sm1 = v_master[.id,1] + vless_tool[.id] ;
  POINT .sm2 = v_master[.id,2] + vless_tool[.id] ;
  POINT .sw1 = vwork[.id,1] + .tool_p;
  POINT .sw2 = vwork[.id,2] + .tool_p;
;
  POINT/Z .sm2 = .sm1; 2点目のZは1点目に合わせる
  POINT vless_frm_m = FRAME(.sm1,.sm2,TRANS(,,100)+.sm1,.sm1)
  POINT vless_frm_m = vless_frm_m+RX(-90); マスター穴で作成したフレーム
;
  POINT/Z .sw2 = .sw1; 2点目のZは1点目に合わせる
  POINT vless_frm_w = FRAME(.sw1,.sw2,TRANS(,,100)+.sw1,.sw1)
  POINT vless_frm_w = vless_frm_w+RX(-90); 現在の穴で作成したフレーム
;
  POINT .salfa = -vless_frm_m+.in_pos; マスターフレームから見た教示位置
  POINT .out_pos = vless_frm_w+.salfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
  .a = DEXT(.out_pos,4)
  .t = DEXT(.out_pos,6)
  POINT/OAT .out_pos = TRANS(,,,.a+.t,,0)
;
.END

.PROGRAM vision_excalchk(.rno,.camno,.height,.ret)
;-------------------------------- 
;機能：カメラキャリブレーション精度チェック実行
;引数：ロボット番号、カメラ番号、逃げ高さ
;戻値：成否
;-------------------------------- 
  .ret = err_no_error
  gs_excalchk_err = .ret
  IF DEBUG.PRT.VISIO==TRUE THEN
    PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .rno=",.rno
    PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .camno=",.camno
    PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .height=",.height
    PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .ret=",.ret
  END
  .$cam = $ENCODE(/I1,.camno); カメラ番号
  .$chk_r = "vcal_robot["+.$cam+"]"
  .$chk_m = "vcal_mes["+.$cam+"]"
  .$chk_h = "vcal_handeye["+.$cam+"]"
  IF EXISTDATA(.$chk_r,R)==OFF || EXISTDATA(.$chk_h,R)==OFF || EXISTDATA(.$chk_m,R)==OFF THEN
    .ret = err_vis_nocalib; キャリブレーション未実施
    gs_excalchk_err = .ret
    CALL error_log(.ret)
    RETURN
  END
  .mes_no = vcal_mes[.camno];
  .robot_no = vcal_robot[.camno];
  .handeye = vcal_handeye[.camno];
  .correct_no = 1000;
  .nige = .height;
; --------------------------------------
;   キャリブレーション精度チェック動作
; --------------------------------------
  CALL vcalib_check(.camno,.mes_no,.robot_no,.handeye,.correct_no,.nige,.ret)
  IF log_error_ena<>FALSE AND .ret>err_no_error THEN
    CALL error_log(.ret)
  END
  gs_excalchk_err = .ret
.END
.*デバッグ出力全OFF用
.REALS
DEBUG.PRT.SOCK = 0
DEBUG.PRT.PROC = 0
DEBUG.PRT.ACT = 0
DEBUG.PRT.CMD = 0
DEBUG.PRT.CORE = 0
DEBUG.PRT.MAIN = 0
DEBUG.PRT.SUB = 0
DEBUG.PRT.GEN = 0
DEBUG.PRT.COM = 0
DEBUG.PRT.FUNC = 0
DEBUG.PRT.VISION = 0
DEBUG.PRT.REBOOT = 0
DEBUG.PRT.EXTIO = 0
DEBUG.PRT.POS = 0
DEBUG.PRT.MOVE = 0
DEBUG.PRT.L2EXEC = 0
DEBUG.PRT.LOG = 0
DEBUG.PRT.ITEM = 0
.END
.PROGRAM commu_log(.mode_no,.$str)
;-------------------------------- 
;機能：通信制御ログ保存
;引数：送信(1)or受信(2),送受信文字列
;戻値：なし
;-------------------------------- 
; 実行タスク取得
  IF TASKNO==1006 THEN
    .task_no = 2; 非動作系
  ELSE
    .task_no = 1; 動作系
  END
; 実行コマンド取得
  .$buf = .$str
  .$res_command = $DECODE(.$buf,",",0)
  .res_command = VAL(.$res_command); 今回
; ログの保存確認
  IF (LOG_MODE[.task_no] BAND .mode_no)==FALSE THEN
    IF DEBUG.PRT.LOG<>FALSE AND bef_res<>.res_command THEN
      PRINT "commu_log()->RETURN[mode] task_no=",.task_no,", .mode_no=",.mode_no
    END
    GOTO end
  END
; 常時実行コマンドの送信データは保存しない
  IF (.task_no==2 AND (.res_command==1001 OR .res_command==1006 OR .res_command==1009 OR .res_command==1017 OR .res_command==1026)) THEN
    IF DEBUG.PRT.LOG<>FALSE AND bef_res<>.res_command THEN
      PRINT "commu_log()->RETURN[command] task_no=",.task_no,", .res_command=",.res_command
    END
    GOTO end
  END
;
  IF LOG_MODE[.task_no]==3 THEN
    IF .mode_no==1 THEN
      .$mode = " SEND ->"; 送信
    ELSE
      .$mode = " RECV <- "; 受信
    END
  ELSE
    IF LOG_MODE[.task_no]==1 THEN
      .$mode = ""; 送信
    ELSE
      .$mode = " "; 受信
    END
  END
  .$log = $DATE(3)+" "+$TIME+" :"+.$mode+.$str; ログデータ作成
  $log_commu[.task_no,log_count[.task_no]] = .$log; ログデータ保存
  log_count[.task_no] = log_count[.task_no]+1; ログカウンタカウントアップ
  IF log_count[.task_no]>log_max_num THEN; ログカウンタ上限超えの為リセット
    log_count[.task_no] = 1
  END
;
  IF DEBUG.PRT.LOG<>FALSE THEN
    PRINT "commu_log()->LOGGING task_no=",.task_no,", $log=",.$log
  END
end:
  bef_res = .res_command; 1つ前
  RETURN
.END
.REALS
  bef_res = 0
.END

.PROGRAM error_log(.err_code)
;-------------------------------- 
;機能：ASアプリエラーログ保存
;引数：エラーコード
;戻値：なし
;-------------------------------- 
;
  IF LOG_ERROR_ENA==FALSE THEN; 機能が有効か確認
    IF DEBUG.PRT.LOG<>FALSE THEN
      PRINT "error_log()->RETURN[disable]"
    END
    RETURN
  END
  IF .err_code<=err_no_error THEN; エラーコード確認
    IF DEBUG.PRT.LOG<>FALSE THEN
      PRINT "error_log()->RETURN[err_code] err_code=",.err_code
    END
    RETURN
  END
;
  CALL get_error_mess(.err_code,.$err_mess); エラーコードからエラーの内容を取得
  .$log = $DATE(3)+" "+$TIME+$DELIMITER+$ENCODE(/L,.err_code)+$DELIMITER+.$err_mess; ログデータ作成
  $log_error[log_count[9]] = .$log; ログデータ保存
  log_count[9] = log_count[9]+1; ログカウンタカウントアップ
  IF log_count[9]>log_max_num THEN; ログカウンタ上限超えの為リセット
    log_count[9] = 1
  END
  $log_error[log_count[9]] = "*"; 最新ログには「*」を書き込む（検索し易くする為）
;
  IF DEBUG.PRT.LOG<>FALSE THEN
    PRINT "error_log()->LOGGING $log=",.$log
  END
  RETURN
.END
.PROGRAM get_error_mess(.err_code,.$err_mess)
;-------------------------------- 
;機能：エラーの内容を取得
;引数：エラーコード
;戻値：エラーメッセージ
;-------------------------------- 
;
  CASE .err_code OF
   VALUE err_no_error; 0
     .$err_mess = ""
.*制御用エラーコード
   VALUE err_robot_busy:; 1000
     .$err_mess = "動作中に実行できないコマンドを受信した"
   VALUE err_poweron:; 1001
     .$err_mess = "モータ電源をONにできないので自動運転できない"
   VALUE err_teach_lock:; 1002
     .$err_mess = "ティーチロックがONなので自動運転できない"
   VALUE err_repeat:; 1003
     .$err_mess = "リピートモードで無い"
   VALUE err_pccom_start:; 1007
     .$err_mess = "通信プログラムを開始できない"
   VALUE err_motor_off:; 1011
     .$err_mess = "モータ電源をOFFにできない"
   VALUE err_cs_off:; 1012
     .$err_mess = "実行中作業が不正に停止した"
   VALUE err_main_stop:; 1013
     .$err_mess = "実行中作業停止異常"
   VALUE err_main_start:; 1014
     .$err_mess = "作業実行開始異常"
   VALUE err_robotmode:; 1015
     .$err_mess = "実行可能条件が未成立"
   VALUE err_extio_unknown:; 1016
     .$err_mess = "操作パネルのモード切替スイッチ状態が不明"
   VALUE err_extio_disable:; 1017
     .$err_mess = "操作パネルのモード切替スイッチ状態が不適"
   VALUE err_extio_change:; 1018
     .$err_mess = "操作パネルのモード切替スイッチが動作中に切り替わった"
   VALUE err_roboterror[0]:; 1020
     CALL get_error_robot(1,.$err_rob); ロボット本体のエラーの内容を取得
     .$err_mess = "ロボット本体異常発生中（2台同時発生中）"+.$err_rob
   VALUE err_roboterror[1]:; 1021
     CALL get_error_robot(1,.$err_rob); ロボット本体のエラーの内容を取得
     .$err_mess = "下アーム異常発生中"+.$err_rob
   VALUE err_roboterror[2]:; 1022
     CALL get_error_robot(2,.$err_rob); ロボット本体のエラーの内容を取得
     .$err_mess = "上アーム異常発生中"+.$err_rob
   VALUE err_emg_stop:; 1023
     .$err_mess = "動作中にモータ電源がOFFした"
   VALUE err_out_range:; 1024
     .$err_mess = "動作目標位置が範囲外の為移動不可"
   VALUE err_cant_convert:; 2000
     .$err_mess = "文字列を実数配列または文字列配列に切り出せない"
   VALUE err_sig_timeout:; 2002
     .$err_mess = "信号がタイムアウト"
   VALUE err_exe_name:; 2003
     .$err_mess = "実行ファイル名が不正"
   VALUE err_emg_on:; 2004
     .$err_mess = "非常停止がON中でコマンドを実行できない"
   VALUE err_bad_axesno:; 2009
     .$err_mess = "軸番号に不正値を指定した"
   VALUE err_bad_areano:; 2010
     .$err_mess = "低速動作エリア番号に不正値を指定した"
   VALUE err_bad_position:; 2011
     .$err_mess = "位置チェック異常"
   VALUE err_gravityadj:; 2012
     .$err_mess = "重力補償自動調整異常(スレーブロボット)"
   VALUE err_l3type_stop:; 2013
     .$err_mess = "作業停止"
   VALUE err_gen_noptn:;2030
     .$err_mess = "原点復帰条件未成立"
   VALUE err_gen_jt1:;2031
     .$err_mess = "1軸回転量異常"
   VALUE err_gen_jt2:;2032
     .$err_mess = "2軸回転量異常"
   VALUE err_gen_base[1]:;2033
     .$err_mess = "下ｱｰﾑが安全距離まで引けてない"
   VALUE err_gen_base[2]:;2034
     .$err_mess = "上ｱｰﾑが安全距離まで引けてない"
   VALUE err_gen_pos:;2035
     .$err_mess = "原点姿勢異常"
   VALUE err_bat_value:;2036
     .$err_mess = "設定値が範囲外です"
   VALUE err_work_set:;2037
     .$err_mess = "作業グルーピン設定異常"
   VALUE err_work_unmatch:;2038
     .$err_mess = "作業グループ番号不一致異常"
.*コマンド用エラーコード
   VALUE err_cmd_type:; 3000
     .$err_mess = "コマンドIDにサポート外の番号を指定した"
   VALUE err_cmd_prmnum:; 3001
     .$err_mess = "タブレットからの指令受信異常(01)"
   VALUE err_bad_mode:; 3003
     .$err_mess = "タブレットからの指令受信異常(03)"
   VALUE err_bad_ptype:; 3004
     .$err_mess = "タブレットからの指令受信異常(04)"
   VALUE err_bad_name:; 3005
     .$err_mess = "タブレットからの指令受信異常(05)"
   VALUE err_bad_num:; 3006
     .$err_mess = "タブレットからの指令受信異常(06)"
   VALUE err_bad_l3type:; 3007
     .$err_mess = "タブレットからの指令受信異常(07)"
   VALUE err_bad_rno:; 3008
     .$err_mess = "タブレットからの指令受信異常(08)"
   VALUE err_cmd_timeout:; 3009
     .$err_mess = "コマンドがタイムアウトした"
   VALUE err_srobot_timeout:; 3010
     .$err_mess = "上アームが協調動作を開始できなかった"
   VALUE err_srobot_error:; 3011
     .$err_mess = "上アームが協調動作を終了できなかった"
   VALUE err_bad_homeno:; 3012
     .$err_mess = "ホーム番号に不正値を指定した"
   VALUE err_bad_signo:; 3013
     .$err_mess = "信号番号に不正値を指定した"
   VALUE err_bad_tableno:; 3014
     .$err_mess = "タブレットからの指令受信異常(09)"
   VALUE err_bad_speed:; 3015
     .$err_mess = "速度指定値に不正値を指定した"
   VALUE err_bad_handio:; 3016
     .$err_mess = "ハンドIO番号に不正値を指定した"
   VALUE err_robot_cmon:; 3018
     .$err_mess = "協調解除処理に失敗した"
   VALUE err_chg_sp:; 3019
     .$err_mess = "速度変更に失敗した"
   VALUE err_bad_visionnum:; 3020
     .$err_mess = "ビジョンIDに不正値を指定した"
   VALUE err_still_working:; 3021
     .$err_mess = "作業実行中"
.*ビジョン用エラーコード
   VALUE err_vis_cmd:; 4001
     .$err_mess = "ビジョン通信コマンド異常"
   VALUE err_vis_cam:; 4002
     .$err_mess = "カメラ画像取込異常"
   VALUE err_vis_setting:; 4003
     .$err_mess = "計測設定異常"
   VALUE err_vis_measure:; 4004
     .$err_mess = "想定外の計測異常"
   VALUE err_vis_nocalib:; 4005
     .$err_mess = "キャリブレーション未実施"
   VALUE err_vis_recog0:; 4006
     .$err_mess = "認識個数0個異常"
   VALUE err_vis_teach:; 4020
     .$err_mess = "マスター登録時複数個認識"
   VALUE err_vis_lesspos:; 4050
     .$err_mess = "装置補正計測点数不足"
   VALUE err_vis_poschk:; 4051
     .$err_mess = "装置位置ズレ異常"
   VALUE err_vis_distchk:; 4052
     .$err_mess = "装置2点間距離異常"
   VALUE err_vis_calst:; 4061
     .$err_mess = "キャリブレーション開始エラー"
   VALUE err_vis_calmeas:; 4062
     .$err_mess = "キャリブレーション計測エラー"
   VALUE err_vis_calend:; 4063
     .$err_mess = "キャリブレーション完了エラー"
   VALUE err_vis_locmas:; 4080
     .$err_mess = "並列作業インターロックタイムアウトエラー（マスター）"
   VALUE err_vis_locsla:; 4081
     .$err_mess = "並列作業インターロックタイムアウトエラー（スレーブ）"
   VALUE err_vis_only:; 4088
     .$err_mess = "片方向通信モードエラー"
   VALUE err_vis_unknow:; 4089
     .$err_mess = "不明な通信エラー"
   VALUE err_vis_send:; 4091
     .$err_mess = "送信エラー"
   VALUE err_vis_recv:; 4092
     .$err_mess = "受信エラー"
   VALUE err_vis_tout1:; 4093
     .$err_mess = "受信開始待ちタイムアウトエラー"
   VALUE err_vis_tout2:; 4094
     .$err_mess = "受信完了待ちタイムアウトエラー"
   VALUE err_vis_tout3:; 4095
     .$err_mess = "受信ＰＧ起動待ちタイムアウトエラー"
   VALUE err_vis_tout4:; 4096
     .$err_mess = "送信ＰＧ起動待ちタイムアウトエラー"
   VALUE err_vis_tout5:; 4097
     .$err_mess = "通信完了(実行中)待ちタイムアウトエラー"
   VALUE err_vis_tout6:; 4098
     .$err_mess = "送信ＰＧ実行待ちタイムアウトエラー"
   VALUE err_vis_tout7:; 4099
     .$err_mess = "通信完了待ちタイムアウトエラー"
.*内部制御用エラーコード(タブレットに表示されたら実装不具合、関数戻り値で使用するためerr_*で番号重複管理対象とする)
   VALUE err_slave_actend:; 5001
     .$err_mess = "5001"
   VALUE err_l3_actend:; 5002
     .$err_mess = "5002"
   ANY :
    .$err_mess = "Unknown error"
  END
.END
.PROGRAM get_error_robot(.rob_no,.$err_rob)
;-------------------------------- 
;機能：ロボット本体のエラーの内容を取得
;引数：ロボット番号
;戻値：エラーコード＋エラーメッセージ
;-------------------------------- 
;
  .$err_rob = ""
  .err_code = SYSDATA(ERROR.CODE,.rob_no); 指定されたロボットで発生しているエラーの番号を取得
  IF .err_code<>err_no_error THEN
    .$err_msg = $ERROR(.err_code); エラーの番号からメッセージを取得
;
    .err_axis = SYSDATA(ERROR.AXIS,.rob_no); 指定されたロボットで発生しているエラーの軸番号を取得
    IF .err_axis<>0 THEN; エラー発生中の軸がある場合
      .$axis = ""
      FOR .jt_no = 1 TO 4
        IF .err_axis BAND 2^(.jt_no-1) THEN
          IF .$axis=="" THEN
            .$axis = $ENCODE(/L,.jt_no)
          ELSE
            .$axis = .$axis+","+$ENCODE(/L,.jt_no)
          END
        END
      END
      .$err_msg = $REPLACE(.$err_msg,"%-M",.$axis,-1) ;軸番号に置き換え
      .$err_msg = $REPLACE(.$err_msg,"%-ld",.$axis,-1) ;軸番号に置き換え
      .$err_msg = $REPLACE(.$err_msg,"%-d",.$axis,-1) ;軸番号に置き換え
      .$err_msg = $REPLACE(.$err_msg,"%ld",.$axis,-1) ;軸番号に置き換え
      .$err_msg = $REPLACE(.$err_msg,"%d",.$axis,-1) ;軸番号に置き換え
    END
;
    .$str_code = $ENCODE(.err_code)
    .err_type = INT(.err_code/10000)
    CASE .err_type OF
     VALUE -4:
      .$err_code = "D"+$RIGHT(.$str_code,4)
     VALUE -3:
      .$err_code = "E"+$RIGHT(.$str_code,4)
     VALUE -2:
      .$err_code = "W"+$RIGHT(.$str_code,4)
     VALUE -1:
      .$err_code = "P"+$RIGHT(.$str_code,4)
     ANY :
      .$err_code = .$str_code
    END
    .$err_rob = " >>> ("+.$err_code+")"+.$err_msg
  END
.END
