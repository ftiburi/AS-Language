.PROGRAM adj_pos(.rno,.mode,.#inpos,.#outpos)
;-------------------------------- 
;機能：目標位置が動作範囲上下限を超えている場合に目標位置を動作範囲ギリギリに上書きする
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)、目標位置(実数配列)
;戻値：調整後位置(実数配列)
;--------------------------------
;    FOR .i=1 TO 6
;        .outpos[.i]=.inpos[.i]
;        .calpos[.i]=.inpos[.i]
;    END
DECOMPOSE .inpos[1] = .#inpos
DECOMPOSE .calpos[1] = .#inpos
DECOMPOSE .outpos[1] = .#inpos
.mergin = 0.1
;動作範囲取得
GETULIMIT 1: .#ulimit[robot_master]
GETLLIMIT 1: .#llimit[robot_master]
GETULIMIT 2: .#ulimit[robot_slave]
GETLLIMIT 2: .#llimit[robot_slave]
DECOMPOSE .ulim_master[1] = .#ulimit[robot_master]
DECOMPOSE .llim_master[1] = .#llimit[robot_master]
DECOMPOSE .ulim_slave[1] = .#ulimit[robot_slave]
DECOMPOSE .llim_slave[1] = .#llimit[robot_slave]
;XYZR1EXT1値から各軸値算出
IF .mode==mode_xyzr1ext1 THEN
IF .rno==robot_slave THEN
ZL3JNT 2: .#tpos=.inpos[1],#S_HERE(2),1;逆変換
ELSE
ZL3JNT 1: .#tpos=.inpos[1],#S_HERE(1),1;逆変換
END
DECOMPOSE .outpos[1] = .#tpos
DECOMPOSE .calpos[1] = .#tpos
END
;各軸値で動作範囲チェック
FOR .i = 1 TO 6
IF .rno==robot_slave THEN
IF .calpos[.i]>.ulim_slave[.i]-.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_slave[.i]-.mergin
END
.outpos[.i] = .ulim_slave[.i]-.mergin
END
IF .calpos[.i]<.llim_slave[.i]+.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_slave[.i]+.mergin
END
.outpos[.i] = .llim_slave[.i]+.mergin
END
ELSE
IF .calpos[.i]>.ulim_master[.i]-.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_master[.i]-.mergin
END
.outpos[.i] = .ulim_master[.i]-.mergin
END
IF .calpos[.i]<.llim_master[.i]+.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_master[.i]+.mergin
END
.outpos[.i] = .llim_master[.i]+.mergin
END
END
END
;各軸値からXYZR1EXT1値算出
IF .mode==mode_xyzr1ext1 THEN
POINT .temp = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
DECOMPOSE .outpos[1] = .temp
END
POINT .#temp = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
.END
.PROGRAM autostart.pc()
;-------------------------------- 
;機能：自動起動プログラム
;引数：無し
;戻値：無し
;--------------------------------
PRINT "TASKNO=",TASKNO,", autostart.pc() -> CALL noexist_init()"
CALL noexist_init
UTIMER @slowlimit_timer = 0
flg_exec_first_ = TRUE
SETAPPLIVER $appli_ver_tbl
data_execute = FALSE
CALL resetstartinfo
CALL rebootsystem
.END
.PROGRAM bootpcprogram(.ret)
;-------------------------------- 
;PCプログラム再起動(PCプログラムは停止しない方針に変更)
;引数：無し
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;**********動作命令用*************
IF TASK(1005)<>1 THEN
UTIMER .@nowtime = 0
DO
PCEXECUTE 5: pccom,-1
IF UTIMER(.@nowtime)>.time_out THEN
.ret = err_pccom_start
CALL update_error(.ret)
RETURN
END
TWAIT 0.5
UNTIL TASK(1005)==1
END
;**********非動作命令用*************
IF TASK(1006)<>1 THEN
UTIMER .@nowtime = 0
DO
PCEXECUTE 6: pccompc,-1
IF UTIMER(.@nowtime)>.time_out THEN
.ret = err_pccom_start
CALL update_error(.ret)
RETURN
END
TWAIT 0.5
UNTIL TASK(1006)==1
END
.END
.PROGRAM calvision(.rno,.id,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン計算実行
;引数：ロボット番号、ビジョンID()、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)==2 THEN
RETURN
END
IF debug.prt.visio==TRUE THEN
PRINT "calvision()->TASKNO=",TASKNO
PRINT "calvision()->ROBOT No.=",.rno
PRINT "calvision()->.id=",.id
PRINT "calvision()->.calpos=",.calpos
END
; ID変換
CALL convert_vid(mode_add,1,.id,.vid1);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
CALL convert_vid(mode_add,2,.id,.vid2);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
; 装置補正計測フラグONチェック
IF vequip_flg[.vid1]!=ON OR vequip_flg[.vid2]!=ON THEN
.ret = 4050
RETURN
END
;第2、第3階層を探索
FOR .i = 1 TO data_l2num
FOR .j = 1 TO data_l3num[.i]
IF data_l3type[.i,.j]==l3type_move THEN
IF data_mode[.i,.j]==mode_jt THEN
;各軸値
ELSE
;変換値
IF .id==data_vision_id1[.i,.j] THEN; 計算実行する装置IDと動作の装置ID(DATA_VISION_ID)が一致
POINT .in_pos = TRANS(data_pos1[.i,.j],data_pos2[.i,.j],data_pos3[.i,.j],data_pos4[.i,.j],0,0); 変換値
CALL vcorrect_table(.&in_pos,.id,.&out_pos); 装置補正実行
DECOMPOSE .out_p[1] = .out_pos; 補正後の変換値分解
; 補正値を書き換え
data_pos1[.i,.j] = .out_p[1]
data_pos2[.i,.j] = .out_p[2]
data_pos3[.i,.j] = .out_p[3]
data_pos4[.i,.j] = .out_p[4]
data_pos5[.i,.j] = 0
data_pos6[.i,.j] = 0
END
END
END
END
END
; 実行後、装置補正計測結果のマスターを現在値で上書き
POINT v_master[.vid1,1] = vwork[.vid1,1]
POINT v_master[.vid2,1] = vwork[.vid2,1]
; 装置補正計測フラグOFF
vequip_flg[.vid1] = OFF
vequip_flg[.vid2] = OFF
.END
.PROGRAM change_ms_mode(.timeout,.ret)
;-------------------------------- 
;機能：協調動作モードに移行
;引数：
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() MASTER-SLAVE MODE"
END
flg_req_mamode = TRUE
flg_slave_move = TRUE
UTIMER .@nowtime = 0
WHILE (1) DO
IF flg_slave_rdy==TRUE THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() SLAVE STATUS IS RDY! MASTER ROBOT CHANGE TO RDY TOO."
END
MASTER
RETURN
END
IF (UTIMER(.@nowtime)>.timeout) THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() Cannot Slave robot change to RDY status."
END
.ret = err_srobot_time
RETURN
END
IF g_last_error<>err_no_error THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() Detected error. g_last_error=",g_last_error
END
.ret = err_srobot_erro
RETURN
END
END
.END
.PROGRAM check_disp_sock(.$buf,.flg_disp)
;-------------------------------- 
;機能：プロトコル詳細デバッグフラグ設定
;引数：受信文字列
;戻値：デバッグ文表示フラグ
;-------------------------------- 
.flg_disp = TRUE
IF debug.prt.proc==TRUE THEN
RETURN
END
IF TASKNO==1006 AND (INSTR(.$buf , "1017")<>0 OR INSTR(.$buf , "1001")<>0 OR INSTR(.$buf , "1015")<>0 OR INSTR(.$buf , "1005")<>0 OR INSTR(.$buf , "1006")<>0 OR INSTR(.$buf , "1010")<>0 OR INSTR(.$buf , "1011")<>0 OR INSTR(.$buf , "1018")<>0) THEN
.flg_disp = FALSE
END
.END
.PROGRAM check_exec_cmd(.cmd,.flg_exec_cmd)
;-------------------------------- 
;機能：コマンド実行制限
;引数：無し
;戻値：可否
;--------------------------------
.flg_exec_cmd = TRUE
IF (robot_mode==mode_tablet) AND (robot_mode_flg==FALSE) THEN
;タブレットモード(手動教示)OFF
;ティーチ系禁止
CASE .cmd OF
VALUE cmd_exe_teach,cmd_exe_move:
.flg_exec_cmd = FALSE
END
END
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) THEN
;タブレットモード(手動教示)ON
;作業実行系、原点復帰禁止
CASE .cmd OF
VALUE cmd_exe_gen,cmd_exe_start,cmd_exe_restart:
.flg_exec_cmd = FALSE
END
END
.END
.PROGRAM check_exec_pg(.flg_exec_main)
;-------------------------------- 
;機能：動作プログラム実行要否判定
;引数：無し
;戻値：動作プログラム実行要否
;--------------------------------
.flg_exec_main = FALSE
;サイクルランプが落ちてる場合
IF (SWITCH(CS ,1)==OFF OR SWITCH(CS ,2)==OFF) THEN
.flg_exec_main = TRUE
RETURN
END
;要求ロボットモードと動作中のプログラムが異なる場合
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) AND (flg_main_run==TRUE) THEN
.flg_exec_main = TRUE
RETURN
END
;要求ロボットモードと動作中のプログラムが異なる場合
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) AND (flg_direct_run==TRUE) THEN
.flg_exec_main = TRUE
RETURN
END
.END
.PROGRAM check_holdpos(.rno,.ret)
;-------------------------------- 
;機能：現在位置と記録位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "check_home()-> .rno=",.rno
END
IF .rno==robot_master THEN
POINT .#pos = #S_HERE(1)
DECOMPOSE .buf1[1] = #rec_holdpos[1]
ELSE
POINT .#pos = #S_HERE(2)
DECOMPOSE .buf1[1] = #rec_holdpos[2]
END
DECOMPOSE .buf2[1] = .#pos
FOR .i = 1 TO 6
IF (.buf1[.i]-poslimit_restar<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_restar) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_holdpos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-poslimit_restar,"<",.buf2[.i],"<",.buf1[.i]+poslimit_restar
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_holdpos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-poslimit_restar,"<",.buf2[.i],"<",.buf1[.i]+poslimit_restar
END
.ret = err_bad_positio
RETURN
END
END
.END
.PROGRAM check_home(.rno,.ret)
;-------------------------------- 
;機能：現在位置とホーム位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
.ret = err_bad_positio
IF debug.prt.cmd==TRUE THEN
PRINT "check_home()-> .rno=",.rno
END
.homeno = 1
POINT .rno: .#home = #HOME(.homeno)
IF .rno==robot_master THEN
POINT .#pos = #S_HERE(1)
ELSE
POINT .#pos = #S_HERE(2)
END
DECOMPOSE .buf1[1] = .#home
DECOMPOSE .buf2[1] = .#pos
FOR .i = 1 TO 6
IF (.buf1[.i]-poslimit_gen<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_gen) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....OK",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-poslimit_gen,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+poslimit_gen
END
IF .i==6 THEN
.ret = err_no_error
;ホーム1、ホーム2のどちらかにいればOKとする
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....NG",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-poslimit_gen,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+poslimit_gen
END
GOTO 100
END
END
100
.homeno = 2
POINT .rno: .#home = #HOME(.homeno)
IF .rno==robot_master THEN
POINT .#pos = #S_HERE(1)
ELSE
POINT .#pos = #S_HERE(2)
END
DECOMPOSE .buf1[1] = .#home
DECOMPOSE .buf2[1] = .#pos
FOR .i = 1 TO 6
IF (.buf1[.i]-poslimit_gen<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_gen) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-poslimit_gen,"<",.buf2[.i],"<",.buf1[.i]+poslimit_gen
END
IF .i==6 THEN
.ret = err_no_error
;ホーム1、ホーム2のどちらかにいればOKとする
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-poslimit_gen,"<",.buf2[.i],"<",.buf1[.i]+poslimit_gen
END
RETURN
END
END
.END
.PROGRAM check_pos(.rno,.cmd,.ret)
;-------------------------------- 
;機能：位置チェック
;引数：ロボット番号、コマンド
;戻値：成否
;-------------------------------- 
.ret = err_bad_positio
CASE .cmd OF
VALUE cmd_exe_start,cmd_exe_gravity:
;原点位置からの開始のみ許容する
CASE .rno OF
VALUE robot_all:
CALL check_home(robot_master,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL check_home(robot_slave,.ret)
IF .ret<>err_no_error THEN
RETURN
END
VALUE robot_master:
CALL check_home(robot_master,.ret)
VALUE robot_slave:
CALL check_home(robot_slave,.ret)
END
VALUE cmd_exe_restart:
;停止位置記憶有効フラグ
IF flg_enable_stop==TRUE THEN
;ホールド停止した時の位置からの開始のみ許容する
CASE .rno OF
VALUE robot_all:
CALL check_holdpos(robot_master,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL check_holdpos(robot_slave,.ret)
IF .ret<>err_no_error THEN
RETURN
END
VALUE robot_master:
CALL check_holdpos(robot_master,.ret)
VALUE robot_slave:
CALL check_holdpos(robot_slave,.ret)
END
END
END
CALL update_error(.ret)
.END
.PROGRAM check_vsl3data(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン補正設定有効・無効判定
;引数：第2階層番号、第3階層番号
;戻値：補正要否(TRUE:有効、FALSE:無効)
;-------------------------------- 
;ビジョン有効（初期値）
.ret = TRUE
IF debug.prt.visio==TRUE THEN
PRINT "check_vs_l3data()->DATA_VISION_ID1[",.l2num,",",.l3num,"]=",data_vision_id1[.l2num,.l3num]
PRINT "check_vs_l3data()->DATA_VISION_ID2[",.l2num,",",.l3num,"]=",data_vision_id2[.l2num,.l3num]
PRINT "check_vs_l3data()->DATA_VISION_ID3[",.l2num,",",.l3num,"]=",data_vision_id3[.l2num,.l3num]
END
;ビジョンIDが0
IF data_vision_id2[.l2num,.l3num]==0 AND data_vision_id3[.l2num,.l3num]==0 THEN
;ビジョン無効
.ret = FALSE
RETURN
END
IF debug.prt.visio==TRUE THEN
PRINT "check_vs_l3data()->DATA_ROBOTTYPE[",.l2num,",",.l3num,"]=",data_robottype[.l2num,.l3num]
END
;動作モードがXYZであることを確認
IF data_mode[.l2num,.l3num]<>mode_xyzr1ext1 THEN
.ret = FALSE
RETURN
END
.END
.PROGRAM chg_colcalflg(.flg)
;-------------------------------- 
;衝突検知感度自動調整設定変更
;引数：ON/OFF(OFF=0.ON=0以外、通信の場合ON=1、ASのON/TRUE=-1）
;戻値：無し（ASシステムから状態取得できない）
;--------------------------------
IF .flg==OFF THEN
;衝突検知感度自動調整設定OFF
flg_enable_colc = FALSE
COLCALOFF 1: 
COLCALOFF 2: 
ELSE
;衝突検知感度自動調整設定ON
flg_enable_colc = TRUE
COLCALON 1: 
COLCALON 2: 
END
.END
.PROGRAM chg_sp(.sp,.ret)
;-------------------------------- 
;機能：速度変更
;引数：変更希望速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF .sp>0 THEN
IF flg_slowlimit==TRUE THEN
IF UTIMER(@slowlimit_timer)<slowlimit_time THEN
SPEED slowlimit_speed MM/S ALWAYS
IF debug.prt.move==TRUE THEN
PRINT "chg_sp()-> START---SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "chg_sp()-> DONE----SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
flg_slowlimit = FALSE
END
END
IF (.sp>safty_move_sp-1 AND .sp<safty_move_sp+1) OR (.sp>safty_lmove_sp-1 AND .sp<safty_lmove_sp+1) THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[mm/sec]"
END
IF TASKNO==1 THEN
ABS.SPEED 1:  ON
ELSE
ABS.SPEED 2:  ON
END
IF (.sp>safty_move_sp-1 AND .sp<safty_move_sp+1) THEN
SPEED safty_move_sp MM/S ALWAYS
ELSE
SPEED safty_lmove_sp MM/S ALWAYS
END
ELSE
IF .sp<=0 OR .sp>100 THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%]"
END
IF TASKNO==1 THEN
ABS.SPEED 1:  OFF
ELSE
ABS.SPEED 2:  OFF
END
SPEED .sp ALWAYS
END
END
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", sp is invalid value. .sp=",.sp
END
END
.END
.PROGRAM chgprt()
;-------------------------------- 
;機能：デバッグ文表示設定切替
;引数：なし
;戻値：なし
;-------------------------------- 
CALL noexist_init
PRINT ""
PRINT "********************************************************"
PRINT "****  デバッグ表示設定  特殊反映  ************************"
PRINT "********************************************************"
PRINT ""
;CALL chgprtflg("sock.pg(PROTOCOL詳細のみ)設定",DEBUG.PRT.PROC)
CALL chgprtflg("act.pg(l2exeのみ)設定",debug.prt.l2exe)
CALL chgprtflg("move.pg(位置情報詳細のみ)設定",debug.prt.pos)
CALL chgprtflg("core.pg(再起動のみ)設定",debug.prt.reboo)
CALL chgprtflg("com.pg(外部制御盤のみ)設定",debug.prt.extio)
PRINT ""
PRINT "********************************************************"
PRINT "****  デバッグ表示設定　ファイル単位 *********************"
PRINT "********************************************************"
PRINT ""
CALL chgprtflg("act.pgファイル設定",debug.prt.act)
CALL chgprtflg("cmd.pgファイル設定",debug.prt.cmd)
CALL chgprtflg("main.pgファイル設定",debug.prt.main)
CALL chgprtflg("sub.pgファイル設定",debug.prt.sub)
CALL chgprtflg("gen.pgファイル設定",debug.prt.gen)
CALL chgprtflg("com.pgファイル設定",debug.prt.com)
CALL chgprtflg("sock.pgファイル設定",debug.prt.sock)
CALL chgprtflg("func.pgファイル設定",debug.prt.func)
CALL chgprtflg("vision.pgファイル設定",debug.prt.visio)
CALL chgprtflg("move.pgファイル設定",debug.prt.move)
.END
.PROGRAM chgprtflg(.$mes,.val)
;-------------------------------- 
;機能：デバッグ文表示設定変更、問合せ文字列生成、問合わせ発生、設定変更結果表示
;引数：表示文字列の一部
;戻値：操作対象フラグ
;-------------------------------- 
.ret = 0
IF .val==0 THEN
.$sta = "非表示"
ELSE
.$sta = "表示"
END
PROMPT "変更? "+.$mes+":[現在設定="+.$sta+"] (YES:1,NO:ENTER)",.ret 
IF .ret==1 THEN
IF .val==TRUE THEN
.val = FALSE
ELSE
.val = TRUE
END
IF .val==FALSE THEN
PRINT "---------------> [変更後設定=非表示]"
ELSE
PRINT "---------------> [変更後設定=表示]"
END
PRINT ""
ELSE
PRINT "---------------> 変更無し"
PRINT ""
END
.END
.PROGRAM chk_cycle_time()
;-------------------------------- 
;サイクルタイム計測(K-ROSET用)
;引数：無し
;戻値：無し
;-------------------------------- 
IF flg_cycle_time==FALSE THEN
IF SIG(ix_cycle_time) THEN
flg_cycle_time = TRUE
UTIMER .@cycle_time = 0
END
ELSE
IF SIG(-ix_cycle_time) THEN
flg_cycle_time = FALSE
TYPE 6: "cycle_time =",UTIMER(.@cycle_time)," sec"
END
END
.END
.PROGRAM chk_exe_staus(.ret)
;-------------------------------- 
;機能：作業実行中か判定
;引数：無し
;戻値：成否
;-------------------------------- 
.ret = err_no_error
FOR .rno = 1 TO 2
IF data_cur_l2rec[.rno]<>0 OR data_cur_l3rec[.rno]<>0 THEN
.ret = err_still_worki
RETURN
END
END
.END
.PROGRAM chk_extin(.status,.$prm[],.num)
;-------------------------------- 
;機能：外部制御盤入力信号状態チェック
;引数：無し
;戻値：信号状態(0:入力無し、1:入力有)、コマンド
;--------------------------------
.status = FALSE
FOR .i = 1 TO 20
.$prm[.i] = "0"
END
.wait_extin_time = wait_extin_time
;STARTを先に押した場合だけSTOPが押されてるか確認する
;STOPが先に押されてる場合は停止指示の可能性があるので即次の処理に移る
IF SIG(extin_start_but)==ON THEN
UTIMER .@nowtime = 0
DO
IF SIG(extin_start_but)==ON AND SIG(extin_stop_butt)==ON THEN
IF robot_mode==mode_direct THEN
;ダイレクトモード中は実行禁止
RETURN
END
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_GEN"
END
.$prm[0] = $ENCODE(cmd_exe_gen)
.$prm[1] = "0"
.$prm[2] = "0"
.$prm[3] = "1"
.$prm[4] = "1234"
.num = 3
.status = TRUE
RETURN
END
END
UNTIL (UTIMER(.@nowtime)>wait_extin_time)
END
IF SIG(extin_start_but)==ON THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF robot_mode==mode_direct THEN
;ダイレクトモード中は実行禁止
RETURN
END
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESTART"
END
.$prm[0] = $ENCODE(cmd_exe_restart)
.$prm[1] = "0"
.$prm[2] = "1234"
.num = 2
ELSE
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_START"
END
.$prm[0] = $ENCODE(cmd_exe_start)
.$prm[1] = "0"
.$prm[2] = "1"
.$prm[3] = "1234"
.num = 3
END
ELSE
;ロボットモード=ダイレクトティーチ、フラグ=ONに変更
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->ON"
END
.$prm[0] = $ENCODE(cmd_exe_robotmo)
.$prm[1] = "0"
.$prm[2] = "1"
.$prm[3] = "1"
.$prm[4] = "1234"
.num = 4
END
.status = TRUE
RETURN
END
IF SIG(extin_stop_butt)==ON THEN
IF g_last_error<>err_no_error THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESET"
END
.$prm[0] = $ENCODE(cmd_exe_reset)
.$prm[1] = "0"
.$prm[2] = "1234"
.num = 2
.status = TRUE
RETURN
ELSE
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ABORT"
END
.$prm[0] = $ENCODE(cmd_exe_abort)
.$prm[1] = "0"
.$prm[2] = "1234"
.num = 2
ELSE
;ロボットモード=ダイレクトティーチ、フラグ=OFFに変更
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->OFF"
END
.$prm[0] = $ENCODE(cmd_exe_robotmo)
.$prm[1] = "0"
.$prm[2] = "1"
.$prm[3] = "0"
.$prm[4] = "1234"
.num = 4
END
.status = TRUE
RETURN
END
END
.END
.PROGRAM chk_robot_stop_()
;-------------------------------- 
;機能：ロボット状態を停止に変更
;引数：無し
;戻値：無し
;--------------------------------
;動作プログラム実行状態フラグ
flg_main_run = FALSE
flg_tablet_run[1] = FALSE
flg_tablet_run[2] = FALSE
flg_direct_run = FALSE
;作業実行フラグ
data_execute = FALSE
;ロボット動作中フラグ
flg_master_move = FALSE
flg_slave_move = FALSE
;ロボットモードONフラグ
robot_mode_flg = FALSE
;ロボットモード
robot_mode = mode_tablet
;重力補償自動調整プログラム実行状態
flg_gravityadj_ = FALSE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL extout_start_bu,-extout_stop_but
.END
.PROGRAM cmdabort(.$prm[],.ret)
;-------------------------------- 
;機能：中断コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;外部制御盤操作を許容する
IF 0 THEN
IF TASKNO<>pg_com_noact THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,"->cmdabort() 非動作コマンドポートからの実行指示のみ可能"
END
RETURN
END
END
IF flg_master_move==TRUE OR flg_slave_move==TRUE OR SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON THEN
exout_start_fla = FALSE
;status_check関数でエラーを発生させないようにフラグ操作する
flg_main_run = FALSE
;HOLD後、PCプログラムがエラーを検知する←status_check関数でエラーを発生させないように仕様変更する20151006
MC HOLD 1:
MC HOLD 2:
IF data_execute==TRUE THEN
CALL update_holdpos
END
;status_check関数でエラーを発生させないため、本来status_check関数で初期化するパラメータをここで初期化する
CALL chk_robot_stop_
IF debug.prt.cmd==TRUE THEN
PRINT "cmdabort()->ROBOT_NUM=",.$prm[1]
PRINT "cmdabort()->SENDING REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "cmdabort()->ROBOT_NUM=",.$prm[1]
PRINT "cmdabort()->NO NEED SEND REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
END
END
.END
.PROGRAM cmdchgio(.$prm[],.ret)
;-------------------------------- 
;機能：IO変更コマンド
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;-------------------------------- 
IF debug.prt.cmd==TRUE THEN
PRINT ".rno=",.$prm[1]
PRINT "Signal Number=",.$prm[2],", Signal Status=",.$prm[3],", Keed Signal Time=",.$prm[4]
END
CALL iochange(VAL(.$prm[2]),VAL(.$prm[3]),VAL(.$prm[4]),.ret)
.END
.PROGRAM cmdchgrobotmode(.$prm[],.ret)
;-------------------------------- 
;機能：ロボットモード変更
;引数：ロボットモード(0:タブレット、1:ダイレクト)、ON/OFFフラグ(0:OFF、1:ON)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;モードチェンジ可否判定
IF robot_mode==mode_tablet AND robot_mode_flg==FALSE AND flg_master_move==TRUE OR flg_slave_move==TRUE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not change robot-mode, because still moving any robot."
END
.ret = err_robot_busy
RETURN
END
.robot_mode = VAL(.$prm[2])
.flg_onoff = VAL(.$prm[3])
robot_mode = .robot_mode
;動作プログラム起動要否判定
.flg_execute = FALSE
IF .flg_onoff==1 THEN
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
END
CASE .robot_mode OF
VALUE mode_tablet:
IF .flg_onoff==1 THEN
.flg_execute = TRUE
END
VALUE mode_direct:
IF .flg_onoff==1 THEN
.flg_execute = TRUE
END
ANY :
.ret = err_bad_mode
RETURN
END
exout_start_fla = FALSE
IF .flg_execute==TRUE THEN
robot_mode_flg = .flg_onoff
CALL exec_pg(.ret)
IF .ret<>err_no_error THEN
robot_mode_flg = FALSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not execute program."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Executed program successfully."
END
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Start abort program automatically."
END
CALL rdyboot(FALSE,.ret)
IF .ret<>err_no_error THEN
robot_mode_flg = FALSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not abort program."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Aborted program successfully."
END
robot_mode_flg = .flg_onoff
END
END
exout_start_fla = FALSE
.END
.PROGRAM cmdcon(.$prm[],.ret)
;-------------------------------- 
;機能：作業番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdcon() .rno=",.$prm[1]
END
.sp = VAL(.$prm[2])
.id = VAL(.$prm[3])
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
RETURN
END
FOR .i = 1 TO data_l3num[.id]
CALL exec_move(.id,.i,.ret)
END
BREAK
.END
.PROGRAM cmdexe(.$prm[],.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;個別実行記憶フラグ
flg_single_move = FALSE
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
IF disable_continu==FALSE THEN
CALL chk_exe_staus(.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
;位置チェック
CALL check_pos(VAL(.$prm[1]),cmd_exe_start,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
CALL cmdexecore(.$prm[],.ret)
.END
.PROGRAM cmdexecore(.$prm[],.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() .rno=",.$prm[1]
END
.exe_num = VAL(.$prm[2])
IF .exe_num<=0 THEN
.ret = err_bad_num
RETURN
END
IF $data_pgname=="" THEN
.ret = err_exe_name
RETURN
END
data_execute = TRUE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() STARTING $DATA_PGNAME=",$data_pgname
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
END
;K-ROSET
IF kroset THEN
INTFCHK ON
END
;/K-ROSET
FOR .i = 1 TO .exe_num
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() Executing.... ",$data_pgname,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
END
;作業連続実行開始
CALL mainexe
BREAK
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() Done ",$data_pgname,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() DONE $DATA_PGNAME=",$data_pgname
END
.ret = g_last_error
.END
.PROGRAM cmdexevscalib(.$prm[],.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL(.$prm[1])
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master:
.camno = VAL(.$prm[2])
.calno = VAL(.$prm[3])
.camtype = VAL(.$prm[4])
POINT .target = TRANS(VAL(.$prm[5]),VAL(.$prm[6]),VAL(.$prm[7]),VAL(.$prm[8]),0,0)
.len = VAL(.$prm[9])
.height = VAL(.$prm[10])
POINT .tool_p = TRANS(VAL(.$prm[11]),VAL(.$prm[12]),0,0,0,0)
CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = VAL(.$prm[1])
gs_camno = VAL(.$prm[2])
gs_calno = VAL(.$prm[3])
gs_camtype = VAL(.$prm[4])
POINT gs_posxyzr1 = TRANS(VAL(.$prm[5]),VAL(.$prm[6]),VAL(.$prm[7]),VAL(.$prm[8]),0,0)
gs_len = VAL(.$prm[9])
gs_height = VAL(.$prm[10])
POINT gs_toolp = TRANS(VAL(.$prm[11]),VAL(.$prm[12]),0,0,0,0)
;スレーブロボット実行
flg_slave_move = TRUE
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
END
END
.END
.PROGRAM cmdgen(.$prm[],.ret)
;-------------------------------- 
;機能：ホーム移動コマンド
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
exout_start_fla = FALSE
;全作業実行状態初期化
CALL updatel2l3info(TRUE,0,0,TRUE)
CALL gen(.$prm[],.ret)
.END
.PROGRAM cmdgetparam(.cmd,.$prm[],.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
.ret = err_no_error
CALL getparam(.cmd,.$prm[],.$res,.ret)
.END
.PROGRAM cmdgetstep(.$prm[],.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
.ret = err_no_error
CALL getstep(.$prm[],.$res,.ret)
.END
.PROGRAM cmdgetsteppos(.$prm[],.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
CALL getsteppos(.$prm[],.$res,.ret)
.END
.PROGRAM cmdgravityadj(.$prm[],.ret)
;-------------------------------- 
;重力補償自動調整コマンド
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL check_pos(VAL(.$prm[1]),cmd_exe_gravity,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
.rno = VAL(.$prm[1])
;モード(0:自動、1:手動)
.mode = VAL(.$prm[2])
;マスタ設定値
.master_setval = VAL(.$prm[3])
;スレーブ設定値
.slave_setval = VAL(.$prm[4])
CALL gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
.END
.PROGRAM cmdhand(.$prm[],.ret)
;-------------------------------- 
;機能：ハンド操作コマンド
;引数：ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL(.$prm[1])
.status = VAL(.$prm[2])
CALL hand(.rno,.status,.ret)
.END
.PROGRAM cmdhold(.$prm[],.ret)
;-------------------------------- 
;機能：一時停止コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;2015/10/2機能削除
RETURN
.END
.PROGRAM cmdl2exe(.$prm[],.ret)
;-------------------------------- 
;機能：第2階層指定個別実行コマンド
;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;個別実行記憶フラグ
flg_single_move = TRUE
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
.l2num = VAL(.$prm[2])
.flg_l2chk = VAL(.$prm[3])
.repeat_num = VAL(.$prm[4])
PRINT "TASKNO=",TASKNO,",cmdl2exe()->.rno=",VAL(.$prm[1]),",.l2num=",.l2num,",.flg_l2chk=",.flg_l2chk,",.repeat_num=",.repeat_num
FOR .i = 1 TO data_l2num
data_l2status[.i] = FALSE
END
data_execute = TRUE
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
END
;K-ROSET
IF kroset THEN
INTFCHK ON
END
;/K-ROSET
FOR .i = 1 TO .repeat_num
IF disable_l2chk==TRUE THEN
;順次実行
flg_slave_move = FALSE
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
ELSE
IF .flg_l2chk==1 THEN
;第2階層条件チェック実行
;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
DO
CALL l2check(.l2num_ok,.ret)
UNTIL ((.ret==TRUE) AND (.l2num_ok==.l2num))
END
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdl2exe() DONE .l2num=",.l2num,",.repeat_num=",.i
END
END
.END
.PROGRAM cmdmain(.cmd,.$prm[],.$res,.ret)
;-------------------------------- 
;機能：コマンド実行
;引数：コマンド、コマンド引数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.$res = ""
IF debug.prt.cmd==TRUE THEN
IF TASKNO==1006 AND (ope_commandpc<>cmd_get_info OR ope_commandpc<>cmd_get_monsp) THEN
;描画しない
ELSE
PRINT "TASKNO=",TASKNO," ->cmdmain() OPE_COMMAND=",ope_command,".cmd=",.cmd
END
END
IF mode_customer==TRUE THEN
CASE .cmd OF
VALUE cmd_exe_start,cmd_exe_move,cmd_exe_restart,cmd_exe_hold,cmd_exe_abort,cmd_exe_l2exe:
;VALUEに追加すればコマンドを無視する
;誤操作時にエラーリセットするのが手間なのでエラーにしないで抜ける
GOTO 10
END
END
CASE .cmd OF
VALUE cmd_exe_reset:
CALL cmdreset(.ret)
CALL exec_alone(.ret)
VALUE cmd_exe_gen:
;引数：動作速度(.sp)
CALL cmdgen(.$prm[],.ret)
BREAK
VALUE cmd_exe_con:
;引数：動作速度(.sp)、第2階層番号(.id)
CALL cmdcon(.$prm[],.ret)
VALUE cmd_exe_one:
;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
CALL cmdone(.$prm[],.ret)
VALUE cmd_exe_teach:
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
CALL cmdteach(.$prm[],.ret)
VALUE cmd_set_tnum,cmd_set_sp,cmd_set_pitch,cmd_set_cord,cmd_set_tool,cmd_set_home,cmd_set_signame,cmd_set_signum,cmd_set_l2exetb:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.$prm[],.ret)
VALUE cmd_set_handio,cmd_set_vtbnum,cmd_set_vtb,cmd_set_lowspar,cmd_set_lowspse,cmd_set_zeroing,cmd_set_colchkm,cmd_set_slowlim:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.$prm[],.ret)
VALUE cmd_get_tnum,cmd_get_info,cmd_get_l1info,cmd_get_l2info,cmd_get_l3info,cmd_get_sp,cmd_get_pitch,cmd_get_cord,cmd_get_tool,cmd_get_pos,cmd_get_io,cmd_get_home:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$prm[],.$res,.ret)
VALUE cmd_get_signame,cmd_get_signum,cmd_get_monsp,cmd_get_l2exetb,cmd_get_infoex,cmd_get_hand,cmd_get_handio,cmd_get_vtbnum,cmd_get_vtb,cmd_get_vresult,cmd_get_robotmo:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$prm[],.$res,.ret)
VALUE cmd_get_lowspar,cmd_get_lowspse,cmd_get_gravity,cmd_get_colchkm,cmd_get_slowlim:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$prm[],.$res,.ret)
VALUE cmd_set_l1info,cmd_set_l2info,cmd_set_l3info:
;CMD_SET_PARAM設定機能は実数配列専用として文字列設定はこちらで実行する
;引数：名前種類[]、名称
CALL cmdnameset(.cmd,.$prm[],.ret)
VALUE cmd_exe_start:
CALL cmdexe(.$prm[],.ret)
VALUE cmd_set_steppos:
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
CALL cmdsetsteppos(.$prm[],.ret)
VALUE cmd_set_step:
;引数：作業情報種類、作業情報配列
CALL cmdsetstep(.$prm[],.ret)
VALUE cmd_get_step:
;引数：第2階層番号、第3階層番号
CALL cmdgetstep(.$prm[],.$res,.ret)
VALUE cmd_get_steppos:
;引数：第2階層番号、第3階層番号
CALL cmdgetsteppos(.$prm[],.$res,.ret)
VALUE cmd_exe_move:
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
CALL cmdmove(.$prm[],.ret)
VALUE cmd_exe_io:
;信号番号、信号状態、状態保持時間
CALL cmdchgio(.$prm[],.ret)
VALUE cmd_exe_vision:
;引数；ビジョンID
CALL cmdvision(.$prm[],.ret)
VALUE cmd_exe_restart:
CALL cmdrestart(.$prm[],.ret)
VALUE cmd_exe_hold:
CALL cmdhold(.$prm[],.ret)
VALUE cmd_exe_abort:
CALL cmdabort(.$prm[],.ret)
VALUE cmd_exe_monsp:
CALL cmdmonsp(.$prm[],.ret)
VALUE cmd_exe_l2exe:
;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
CALL cmdl2exe(.$prm[],.ret)
VALUE cmd_exe_hand:
;引数：ハンド状態
CALL cmdhand(.$prm[],.ret)
VALUE cmd_exe_resetio:
FOR .i = 1 TO 128
;非常停止割当IOとハンド制御IOは操作しない
IF .i<>sig_emg_output AND .i<>sig_ext_reboot AND .i<>data_hand_io[robot_master,1] AND .i<>data_hand_io[robot_master,2] AND .i<>data_hand_io[robot_master,3] AND .i<>data_hand_io[robot_master,4] THEN
IF .i<>data_hand_io[robot_slave,1] AND .i<>data_hand_io[robot_slave,2] AND .i<>data_hand_io[robot_slave,3] AND .i<>data_hand_io[robot_slave,4] THEN
SIGNAL -(.i)
END
END
END
FOR .i = 1 TO 256
;非常停止割当IOとハンド制御IOは操作しない
IF .i<>sig_emg_output AND .i<>sig_ext_reboot AND .i<>data_hand_io[robot_master,1] AND .i<>data_hand_io[robot_master,2] AND .i<>data_hand_io[robot_master,3] AND .i<>data_hand_io[robot_master,4] THEN
IF .i<>data_hand_io[robot_slave,1] AND .i<>data_hand_io[robot_slave,2] AND .i<>data_hand_io[robot_slave,3] AND .i<>data_hand_io[robot_slave,4] THEN
SIGNAL -(2000+.i)
END
END
END
VALUE cmd_exe_waitend:
flg_wait_end = TRUE
VALUE cmd_exe_robotmo:
;引数：ロボットモード(0:タブレット、1:ダイレクトティーチ)、ON/OFFフラグ
CALL cmdchgrobotmode(.$prm[],.ret)
VALUE cmd_exe_gravity:
CALL cmdgravityadj(.$prm[],.ret)
VALUE cmd_exe_vscalib:
CALL cmdexevscalib(.$prm[],.ret)
ANY :
PRINT "TASKNO=",TASKNO," ->cmdmain() Error occuerd. You try to execute unsupport command."
.ret = err_cmd_type
END
10
IF .ret<>err_no_error THEN
IF TASKNO==pg_com_act THEN
CALL sendresp(.cmd,"",.ret)
END
END
.END
.PROGRAM cmdmonsp(.$prm[],.ret)
;-------------------------------- 
;機能：モニタ速度変更コマンド
;引数：速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL monsp(.$prm[],.ret)
.END
.PROGRAM cmdmove(.$prm[],.ret)
;-------------------------------- 
;機能：指定位置移動コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdmove() .rno=",.$prm[1]
END
.rno = VAL(.$prm[1])
.mode = VAL(.$prm[2])
.t[robot_master] = 0
.t[robot_slave] = 0
CASE .rno OF
VALUE robot_all:
IF 1 THEN
.t[robot_master] = VAL(.$prm[3])
ELSE
;タブレット側UIの都合でこのコマンドでは個別にしか動かせない
.ret = err_bad_rno
RETURN
END
VALUE robot_master:
.t[robot_master] = VAL(.$prm[3])
VALUE robot_slave:
.t[robot_slave] = VAL(.$prm[3])
ANY :
.ret = err_bad_rno
RETURN
END
POINT .#t = #PPOINT(.t[robot_master],.t[robot_slave],0,0,0,0)
.type = VAL(.$prm[4])
;位置情報
IF .mode==mode_jt THEN
.cpos[1] = VAL(.$prm[5]);JT1
.cpos[2] = VAL(.$prm[6]);JT2
.cpos[3] = VAL(.$prm[7]);JT3
.cpos[4] = VAL(.$prm[8]);JT4
.cpos[5] = 0;xxx外部軸仕様未確定xxx
.cpos[6] = 0;xxx外部軸仕様未確定xxx
ELSE
.cpos[1] = VAL(.$prm[5]);X
.cpos[2] = VAL(.$prm[6]);Y
.cpos[3] = VAL(.$prm[7]);Z
.cpos[4] = VAL(.$prm[8]);R1
.cpos[5] = 0;xxx外部軸仕様未確定xxx
.cpos[6] = 0;xxx外部軸仕様未確定xxx
END
POINT .#cpos = #PPOINT(.cpos[1],.cpos[2],.cpos[3],.cpos[4],.cpos[5],.cpos[6])
POINT .#offsetpos = #PPOINT(0,0,0,0,0,0)
;   FOR .i=1 TO 6
;       .offsetpos[.i]=0
;   END
CALL shift_pos(.rno,.mode,data_teachcoord,.#cpos,.#offsetpos,.#outpos,.ret)
IF .mode==mode_jt THEN;JMOVE
.sp = safty_move_sp
ELSE;LMOVE
.sp = safty_lmove_sp;指定位置移動とティーチ移動のLMOVEのみに使用
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
END
;K-ROSET
IF kroset THEN
INTFCHK ON
END
;/K-ROSET
CALL movepos(.rno,.#t,.mode,.type,.#outpos,TRUE,.sp,.ret)
.END
.PROGRAM cmdnameset(.cmd,.$prm[],.ret)
;-------------------------------- 
;機能：名称設定
;引数：文字列配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL nameset(.cmd,.$prm[],.ret)
.END
.PROGRAM cmdone(.$prm[],.ret)
;-------------------------------- 
;機能：作業番号、教示点番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdone() .rno=",.$prm[1]
END
.sp = VAL(.$prm[2])
.id = VAL(.$prm[3])
.num = VAL(.$prm[4])
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL getposdata(.id,.num,.mode,.type,.#pos,.ret)
;移動方法は指定の方法で上書き
CALL exec_move(.id,.num,.ret)
.END
.PROGRAM cmdreset(.ret)
;-------------------------------- 
;機能：エラーリセットコマンド
;引数：なし
;戻値：成否
;-------------------------------- 
IF g_last_error==err_no_error THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() skipped reset command."
END
RETURN
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() Starting reset command."
END
;システム管理のエラー情報の初期化のみのためロボット別処理不要
.ret = err_no_error
CALL update_error(.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() Done reset command."
END
.END
.PROGRAM cmdrestart(.$prm[],.ret)
;-------------------------------- 
;機能：CONTINUEコマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;外部制御盤操作を許容する
IF 0 THEN
IF TASKNO<>pg_com_noact THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,"->cmdrestart() 非動作コマンドポートからの実行指示のみ可能"
END
RETURN
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->TASKNO=",TASKNO,",ROBOT_NUM=",.$prm[1]
END
;PCプログラムから実行するためこのタイミングでOPE_COMMANDを更新する
ope_command = cmd_exe_restart
IF disable_continu==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->START CHECK ROBOT-ACTION STATUS"
END
exout_start_fla = FALSE
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
IF flg_master_move==TRUE OR flg_slave_move==TRUE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->ロボットの動作中のため再開操作を実行できません。"
END
RETURN
END
;位置チェック
IF flg_enable_stop==TRUE THEN
CALL check_pos(VAL(.$prm[1]),cmd_exe_restart,.ret)
END
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
exout_start_fla = FALSE
exout_stop_flas = FALSE
data_execute = TRUE
;中断された作業を継続実行する
.l2num = data_cur_l2rec[robot_master]
.l3num = data_cur_l3rec[robot_master]
CALL get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
IF .req_wstart==TRUE THEN
;並列中のスレーブロボット動作
IF data_cur_l2rec[robot_slave]<>0 AND data_cur_l3rec[robot_slave]<>0 THEN
;並列動作要求
flg_slave_paral = TRUE
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->ロボットの動作を並列モードに変更します。"
END
;開始作業位置設定
gs_l2num = data_cur_l2rec[robot_slave]
gs_l3num = data_cur_l3rec[robot_slave]
;スレーブ動作継続実行
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->スレーブロボットの動作を継続実行を要求します。"
END
flg_slave_move = TRUE
END
END
IF data_cur_l2rec[robot_master]<>0 AND data_cur_l3rec[robot_master]<>0 THEN
;マスターロボット動作
IF .req_cstart==TRUE THEN
sys_force_cmode = TRUE
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->ロボットの動作を協調モードに変更します。"
END
END
;マスター動作継続実行
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->マスターロボットの動作を継続実行を要求します。"
END
flg_master_con = TRUE
flg_master_move = TRUE
ELSE
;非並列中のスレーブロボット単独動作
IF data_cur_l2rec[robot_slave]<>0 AND data_cur_l3rec[robot_slave]<>0 THEN
;並列動作要求
flg_slave_paral = TRUE
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->ロボットの動作を並列モードに変更します。"
END
;開始作業位置設定
gs_l2num = data_cur_l2rec[robot_slave]
gs_l3num = data_cur_l3rec[robot_slave]
;スレーブ動作継続実行
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->スレーブロボットの動作を継続実行を要求します。"
END
flg_slave_con = TRUE
flg_slave_move = TRUE
END
END
RETURN
END
END
.END
.PROGRAM cmdsetparam(.cmd,.$prm[],.ret)
;-------------------------------- 
;機能：変数設定コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setparam(.cmd,.$prm[],.ret)
.END
.PROGRAM cmdsetstep(.$prm[],.ret)
;-------------------------------- 
;機能：作業情報の設定
;引数：実数配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setstep(.$prm[],.ret)
.END
.PROGRAM cmdsetsteppos(.$prm[],.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setsteppos(.$prm[],.ret)
.END
.PROGRAM cmdteach(.$prm[],.ret)
;-------------------------------- 
;機能：手動移動操作コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
;ロボット番号
.rno = VAL(.$prm[1])
;動作方法
.mode = VAL(.$prm[2])
;ツール変換値MASTER
.t[robot_master] = VAL(.$prm[3])
;ツール変換値SLAVE
.t[robot_slave] = VAL(.$prm[4])
POINT .#t = #PPOINT(.t[robot_master],.t[robot_slave],0,0,0,0)
;補間方法
.type = VAL(.$prm[5])
;位置情報(実機調整が必要な可能性有)
IF .mode==mode_jt THEN
;位置情報MASTER
.flag[1,1] = VAL(.$prm[6]);JT1
.flag[1,2] = VAL(.$prm[7]);JT2
.flag[1,3] = VAL(.$prm[8]);JT3
.flag[1,4] = VAL(.$prm[9]);JT4
.flag[1,5] = 0;xxx外部軸仕様未確定xxx
.flag[1,6] = 0;xxx外部軸仕様未確定xxx
;位置情報SLAVE
.flag[2,1] = VAL(.$prm[11]);JT1
.flag[2,2] = VAL(.$prm[12]);JT2
.flag[2,3] = VAL(.$prm[13]);JT3
.flag[2,4] = VAL(.$prm[14]);JT4
.flag[2,5] = 0;xxx外部軸仕様未確定xxx
.flag[2,6] = 0;xxx外部軸仕様未確定xxx
ELSE
;X,Y,Z,R1,EXT
;位置情報MASTER
.flag[1,1] = VAL(.$prm[6]);X
.flag[1,2] = VAL(.$prm[7]);Y
.flag[1,3] = VAL(.$prm[8]);Z
.flag[1,4] = VAL(.$prm[9]);R1
.flag[1,5] = 0;xxx外部軸仕様未確定xxx
.flag[1,6] = 0;xxx外部軸仕様未確定xxx
;位置情報SLAVE
.flag[2,1] = VAL(.$prm[11]);X
.flag[2,2] = VAL(.$prm[12]);Y
.flag[2,3] = VAL(.$prm[13]);Z
.flag[2,4] = VAL(.$prm[14]);R1
.flag[2,5] = 0;xxx外部軸仕様未確定xxx
.flag[2,6] = 0;xxx外部軸仕様未確定xxx
END
CALL get_jttype(.rno,.mode,.#axis_type)
DECOMPOSE .axis_type[1] = .#axis_type
FOR .i = 1 TO 6
CASE .rno OF
VALUE robot_all:
;協調動作
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[1,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[1,.i]
ANY :
.offsetpos[.i] = 0
END
VALUE robot_master:
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[1,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[1,.i]
ANY :
.offsetpos[.i] = 0
END
VALUE robot_slave:
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[2,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[2,.i]
ANY :
.offsetpos[.i] = 0
END
END
END
;基準用現在値取得
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
RETURN
END
POINT .#offsetpos = #PPOINT(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6])
CALL shift_pos(.rno,.mode,data_teachcoord,.#cpos,.#offsetpos,.#outpos,.ret)
CALL adj_pos(.rno,.mode,.#outpos,.#outpos)
IF .mode==mode_jt THEN;JMOVE
.sp = safty_move_sp
ELSE;LMOVE
.sp = safty_lmove_sp;指定位置移動とティーチ移動のLMOVEのみに使用
END
INTFCHK OFF
CALL movepos(.rno,.#t,.mode,.type,.#outpos,TRUE,.sp,.ret)
.END
.PROGRAM cmdvision(.$prm[],.ret)
;-------------------------------- 
;機能：ビジョンコマンド
;引数：ビジョンID
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ビジョンID変換
CALL convert_vid(mode_add,VAL(.$prm[7]),VAL(.$prm[2]),.vision_id)
CALL vision_main(VAL(.$prm[1]),.vision_id,VAL(.$prm[3]),VAL(.$prm[4]),VAL(.$prm[5]),VAL(.$prm[6]),VAL(.$prm[7]),VAL(.$prm[8]),.ret)
.END
.PROGRAM cmdzero(.rno,.jtno,.val,.ret)
;-------------------------------- 
;ゼロイング設定コマンド
;引数：ロボット番号、軸番号、軸設定値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;エラー中実行不可
IF g_last_error<>err_no_error THEN
.ret = g_last_error
RETURN
END
;サイクル中実行不可
IF SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON THEN
.ret = err_robot_busy
RETURN
END
;モータ電源は自動OFF(モータ電源ONは他のシーケンスに任せる)
IF SWITCH(POWER ,1)==ON OR SWITCH(POWER ,2)==ON THEN
CALL cmdabort(.$prm[],.ret)
.time_out = boot_timeout
UTIMER .@nowtime = 0
DO
MC ZPOW 1: OFF
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT motor-off."
.ret = err_motor_off
RETURN
END
UNTIL (SWITCH(POWER ,1)==OFF)
UTIMER .@nowtime = 0
DO
MC ZPOW 2: OFF 
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT motor-off."
.ret = err_motor_off
RETURN
END
UNTIL (SWITCH(POWER ,2)==OFF)
END
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
IF .jtno>=5 THEN
.ret = err_bad_axesno
RETURN
ELSE
IF .jtno<=0 THEN
FOR .i = 1 TO 4
ZJZERO .rno: .i , .val
END
ELSE
ZJZERO .rno: .jtno , .val
END
END
ANY :
.ret = err_bad_rno
RETURN
END
RETURN
.END
.PROGRAM convert_vid(.mode,.calpos,.in_id,.out_id)
;-------------------------------- 
;機能：ビジョンID変換
;引数：mode(MODE_DEL/MODE_ADD)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、変換元ビジョンID
;戻値：変換後ビジョンID(変換元ビジョンIDが想定外の場合でもそのまま戻す)
;-------------------------------- 
;初期化
NOEXIST_SET_R .in_id = 0
.out_id = .in_id
CASE .mode OF
VALUE mode_add:
CASE .calpos OF
VALUE type_pos:
;そのままでOK
VALUE type_device1,type_device:
.out_id = .in_id+offset_device1n
VALUE type_device2:
.out_id = .in_id+offset_device2n
END
VALUE mode_del:
IF .out_id>max_visionid_nu THEN
DO
.out_id = .out_id-max_visionid_nu
UNTIL (.out_id<max_visionid_nu)
END
END
.END
.PROGRAM csv_to_real(.$str,.prm[],.num,.ret)
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
.ret = err_no_error
.num = 0
DO
.$temp = $DECODE(.$str,",",0)
.prm[.num] = VAL(.$temp)
IF .$str=="" THEN
GOTO 100
END
.$temp = $DECODE(.$str,",",1)
.num = .num+1
UNTIL .$str==""
100
IF .num==0 THEN
.ret = err_cant_conver
END
.END
.PROGRAM csv_to_str(.$str,.$prm[],.num,.ret)
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)(動作プログラム実行用)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
.ret = err_no_error
.num = 0
DO
.$temp = $DECODE(.$str,",",0)
.$prm[.num] = .$temp
IF .$str=="" THEN
GOTO 100
END
.$temp = $DECODE(.$str,",",1)
.num = .num+1
UNTIL .$str==""
100
IF .num==0 THEN
.ret = err_cant_conver
END
.END
.PROGRAM exec_alone(.ret)
;-------------------------------- 
;機能：ALONEコマンド実行
;引数：なし
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF (COOPSTATUS(1)==0 AND COOPSTATUS(2)==0) THEN
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中では無い TASKNO=",TASKNO
END
RETURN
END
IF TASKNO<>pg_master AND TASKNO<>pg_slave THEN
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中を検出:ZMONEXE ALONE TASKNO=",TASKNO
END
IF (SWITCH(CS ,1)==OFF OR SWITCH(CS ,2)==OFF) THEN
DO
IF SWITCH(CS ,1)==ON THEN
MC HOLD 1:
END
IF SWITCH(CS ,2)==ON THEN
MC HOLD 2:
END
IF debug.prt.func==TRUE THEN
PRINT "Try to execute hold command before ZONEXE."
END
UNTIL ((SWITCH(CS ,1)==OFF AND SWITCH(CS ,2)==OFF))
END
ZMONEXE "ALONE"
ELSE
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中を検出:ALONE TASKNO=",TASKNO
END
ALONE
END
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "Can not change ALONE-mode for MASTER_ROBOT"
RETURN
END
UNTIL (COOPSTATUS(1)==0)
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "Can not change ALONE-mode for SLAVE_ROBOT"
RETURN
END
UNTIL (COOPSTATUS(2)==0)
.END
.PROGRAM exec_calvision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン計算実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_calvision()"
END
; calposはcalvision内で未使用
CALL calvision(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],1,.ret)
.END
.PROGRAM exec_cend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_cend()->      　同期終了"
END
sys_force_cmode = FALSE
.END
.PROGRAM exec_cntset(.l2num,.l3num,.val,.ret)
;-------------------------------- 
;機能：カウンタ値設定実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)、カウンタ値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
NOEXIST_SET_R data_cntid[.l2num,.l3num] = -1
IF ((.l2num==0) AND (.l3num==0)) OR (data_cntid[.l2num,.l3num]==-1) THEN
FOR .i = 1 TO max_cntnum
;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
data_cntnum[.i] = .val
END
ELSE
data_cntnum[data_cntid[.l2num,.l3num]] = .val
END
.END
.PROGRAM exec_cntup(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：カウンタ値加算実行 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF data_cntid[.l2num,.l3num]==-1 THEN
FOR .i = 1 TO max_cntnum
;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
NOEXIST_SET_R data_cntnum[.i] = 0
data_cntnum[.i] = data_cntnum[.i]+1
.maxnum = 65535
IF data_cntnum[.i]>=.maxnum THEN
data_cntnum[.i] = 0
END
END
ELSE
NOEXIST_SET_R data_cntnum[data_cntid[.l2num,.l3num]] = 0
data_cntnum[data_cntid[.l2num,.l3num]] = data_cntnum[data_cntid[.l2num,.l3num]]+1
END
.END
.PROGRAM exec_cstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_cstart()->      同期開始"
END
sys_force_cmode = TRUE
.END
.PROGRAM exec_hand(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ハンド操作実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_hand()->ハンド操作実行"
END
CALL hand(data_robottype[.l2num,.l3num],data_hand_ctl[.l2num,.l3num],.ret)
.END
.PROGRAM exec_ifchk(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO成立条件判定
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：JUMP可否(FALSE:JUMP不可、TRUE:JUMP可)
;-------------------------------- 
.ret = FALSE
PRINT "exec_ifchk()-> Condition number is DATA_L3IFGOTO_ID[",.l2num,",",.l3num,"]=",data_l3ifgoto_i[.l2num,.l3num]
;DATA_L3IFGOTO_ID:第3階層作業登録情報内の指定条件テーブル番号
;DATA_IFCONTBLNUM:条件テーブル総数
IF data_l3ifgoto_i[.l2num,.l3num]>data_ifcontblnu THEN
RETURN
END
;DATA_IFCONNUM:指定条件テーブル番号内の条件総数
IF data_ifconnum[data_l3ifgoto_i[.l2num,.l3num]]<=0 THEN
;条件が存在しない場合はJUMPしない
RETURN
END
;条件成立数カウント(このチェックの瞬間に全条件が揃ってる場合のみJUMPする)
.cnt = 0
FOR .i = 1 TO data_ifconnum[data_l3ifgoto_i[.l2num,.l3num]]
CASE data_ifcontype[data_l3ifgoto_i[.l2num,.l3num],.i] OF
VALUE ifcon_cnt:
CASE data_ifconsign[data_l3ifgoto_i[.l2num,.l3num],.i] OF
VALUE ineq_sign_gt:
;[>]greater than
IF data_cntnum[data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]]>data_ifconcnt[data_l3ifgoto_i[.l2num,.l3num],.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_lt:
;[<]less than
IF data_cntnum[data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]]<data_ifconcnt[data_l3ifgoto_i[.l2num,.l3num],.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_gteq:
;[>=]greater than or equal
IF data_cntnum[data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]]>=data_ifconcnt[data_l3ifgoto_i[.l2num,.l3num],.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_lteq:
;[<=]less than or equal
IF data_cntnum[data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]]<=data_ifconcnt[data_l3ifgoto_i[.l2num,.l3num],.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_eq:
;[=]equal
IF data_cntnum[data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]]==data_ifconcnt[data_l3ifgoto_i[.l2num,.l3num],.i] THEN
.cnt = .cnt+1
END
END
VALUE ifcon_io:
;OFF=0,ON=0以外
IF data_ifconsign[data_l3ifgoto_i[.l2num,.l3num],.i]<>OFF THEN
IF SIG(data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i])<>OFF THEN
.cnt = .cnt+1
END
ELSE
IF SIG(data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i])==OFF THEN
.cnt = .cnt+1
END
END
VALUE ifcon_flg:
;0以外の数値をDATA_IFCONVALに設定している場合、符号を無視してTRUE扱い
IF data_ifconval[data_l3ifgoto_i[.l2num,.l3num],.i]<>0 THEN
.cnt = .cnt+1
END
END
END
IF .cnt==data_ifconnum[.i] THEN
;JUMP条件数OK
.ret = TRUE
RETURN
END
.END
.PROGRAM exec_ifgoto(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO動作コア 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL exec_ifchk(.l2num,.l3num,.jump_flg)
IF .jump_flg==TRUE THEN
CALL exec_ifjump(.l2num,.l3num,.ret)
END
.END
.PROGRAM exec_ifjump(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTOJUMP動作 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;指定L2階層内でラベルが見つかった場合.l3num数を更新する
PRINT "exec_ifjump()-> Start serch for $DATA_L3IFGOTO_LABEL[",.l2num,",",.l3num,"]=",$data_l3ifgoto_l[.l2num,.l3num]
FOR .i = 1 TO data_l3num[.l2num]
IF data_l3type[.l2num,.i]==l3type_iflabel THEN
;探索指定文字列    =$DATA_L3IFGOTO_LABEL[IFGOTO第2階層,IFGOT第3階層]
;ラベル設定済文字列=$DATA_L3LABEL[LABEL第2階層,LABEL第3階層]
IF $data_l3ifgoto_l[.l2num,.l3num]==$data_l3label[.l2num,.i] THEN
.l3num = .i
PRINT "exec_ifjump()-> Target-label was found in .l2num=",.l2num,",.l3num=",.l3num
RETURN
END
END
END
PRINT "exec_ifjump()-> Target-label wasn\'t found in .l2num=",.l2num
.END
.PROGRAM exec_iochange(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO変更処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_iochange()"
END
IF data_signum[.l2num,.l3num]<=0 THEN
;エラーにするかは上位の実装を考慮したほうが良い
;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
RETURN
END
IF data_wait_befor[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",data_wait_befor[.l2num,.l3num]
END
TWAIT data_wait_befor[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
IF debug.prt.act==TRUE THEN
PRINT "CHANGEING SIGNAL DATA_SIGNUM[.l2num,.l3num]=",data_signum[.l2num,.l3num]," DATA_SIGSTATUS[.l2num,.l3num]=",data_sigstatus[.l2num,.l3num]
END
CALL iochange(data_signum[.l2num,.l3num],data_sigstatus[.l2num,.l3num],data_keep_wait[.l2num,.l3num],.ret)
IF data_wait_after[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",data_wait_after[.l2num,.l3num]
END
TWAIT data_wait_after[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
.END
.PROGRAM exec_iowait(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO待ち処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_iowait()"
END
IF data_signum[.l2num,.l3num]<=0 THEN
;エラーにするかは上位の実装を考慮したほうが良い
;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
RETURN
END
IF data_wait_befor[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",data_wait_befor[.l2num,.l3num]
END
TWAIT data_wait_befor[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
IF debug.prt.act==TRUE THEN
PRINT "START WAITING DATA_SIGNUM[.l2num,.l3num]=",data_signum[.l2num,.l3num]
END
UTIMER .@nowtime = 0
WHILE (TRUE) DO
exout_start_fla = TRUE
IF flg_wait_end==TRUE THEN
flg_wait_end = FALSE
exout_start_fla = FALSE
RETURN
END
IF data_wait_timeo[.l2num,.l3num]>0 THEN
IF UTIMER(.@nowtime)>data_wait_timeo[.l2num,.l3num]/1000 THEN  ; @@@ 20140926 m ミリ秒に変更 A.Kobayashi
IF debug.prt.act==TRUE THEN
PRINT "TIMEOUT"
END
.ret = err_sig_timeout
data_execute = FALSE     ; @@@ 20140926 A.Kobayashi
exout_start_fla = FALSE
RETURN
END
END
IF SIG(data_signum[.l2num,.l3num])==-(data_sigstatus[.l2num,.l3num]) THEN
IF debug.prt.act==TRUE THEN
PRINT "DETECTED INPUT SIGNAL=",data_signum[.l2num,.l3num]," CHANGE TO =",-(data_sigstatus[.l2num,.l3num])
END
IF data_wait_after[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",data_wait_after[.l2num,.l3num]
END
TWAIT data_wait_after[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
exout_start_fla = FALSE
RETURN
END
END
.END
.PROGRAM exec_main(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：作業シーケンス実行処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l3type = data_l3type[.l2num,.l3num]
CASE .l3type OF
VALUE l3type_move,l3type_io_wait,l3type_io_chang,l3type_vision,l3type_hand_cha,l3type_return,l3type_ifgoto,l3type_colchk:
;ロボット別にコマンドを処理したい場合は↑VALUEに追加
IF flg_slave_paral==TRUE THEN
CALL selfcheck(.l2num,.l3num,.ret)
IF .ret<>err_no_error THEN
;スキップは正常扱いにする
.ret = err_no_error
RETURN
END
END
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend:
;マスター専用コマンドとして扱いたい場合は↑VALUEに追加
IF (TASKNO==pg_slave) AND (.l3type==l3type_wend) THEN
.ret = err_slave_acten
RETURN
END
;マスター専用
IF TASKNO<>pg_master THEN
RETURN
END
END
;登録作業実行
CASE .l3type OF
VALUE l3type_move:
IF flg_exec_first_==TRUE THEN
UTIMER @slowlimit_timer = 0
flg_slowlimit = TRUE
flg_exec_first_ = FALSE
END
CALL exec_move(.l2num,.l3num,.ret)
VALUE l3type_io_wait:
CALL exec_iowait(.l2num,.l3num,.ret)
VALUE l3type_io_chang:
CALL exec_iochange(.l2num,.l3num,.ret)
VALUE l3type_vision:
CALL exec_vision(.l2num,.l3num,.ret)
VALUE l3type_cstart:
IF flg_slave_paral==FALSE THEN
CALL exec_cstart(.l2num,.l3num,.ret)
END
VALUE l3type_cend:
IF flg_slave_paral==FALSE THEN
CALL exec_cend(.l2num,.l3num,.ret)
END
VALUE l3type_wstart:
CALL exec_wstart(.l2num,.l3num,.ret)
VALUE l3type_wend:
CALL exec_wend(.l2num,.l3num,.ret)
VALUE l3type_l2reset:
data_l2status[data_l2resetnum[.l2num,.l3num]] = FALSE
VALUE l3type_hand_cha:
CALL exec_hand(.l2num,.l3num,.ret)
VALUE l3type_calvisio:
CALL exec_calvision(.l2num,.l3num,.ret)
VALUE l3type_colchk:
IF data_colchk[.l2num,.l3num]==FALSE THEN
;アーム間干渉チェック機能無効化
INTFCHK OFF
ELSE
;アーム間干渉チェック機能有効化
INTFCHK ON
END
VALUE l3type_return:
.ret = err_l3_actend
VALUE l3type_ifgoto:
CALL exec_ifgoto(.l2num,.l3num,.ret)
VALUE l3type_iflabel:
;何もしない
VALUE l3type_cntup:
CALL exec_cntup(.l2num,.l3num,.ret)
VALUE l3type_cntset:
;カウンタ値セットはカウンタ値リセットと兼用
;全カウンタリセット時はexec_cntset関数に[.l2num,.l3num,.val]を0指定
NOEXIST_SET_R data_cntval[.l2num,.l3num] = 0
.val = data_cntval[.l2num,.l3num]
CALL exec_cntset(.l2num,.l3num,.val,.ret)
END
IF (.ret<>err_no_error) AND (.ret<>err_l3_actend) THEN
IF debug.prt.act==TRUE THEN
PRINT "detected error. tho.. sopping mainexe() .ret=",.ret
END
CALL update_error(.ret)
RETURN
END
.END
.PROGRAM exec_move(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：移動処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_move()"
END
IF data_repspeed[.l2num,.l3num]<=0 OR data_repspeed[.l2num,.l3num]>100 THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
.sp = data_repspeed[.l2num,.l3num]
CALL getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
IF .ret==err_no_error THEN
IF data_wait_befor[.l2num,.l3num]>=1 THEN
TWAIT data_wait_befor[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
.rno = data_robottype[.l2num,.l3num]
.t[1] = 0
.t[2] = 0
CASE .rno OF
VALUE 1:
.t[1] = data_tool[.l2num,.l3num]
VALUE 2:
.t[2] = data_tool[.l2num,.l3num]
END
POINT .#t = #PPOINT(.t[robot_master],.t[robot_slave],0,0,0,0)
IF sys_force_cmode==TRUE THEN
.rno = 0
IF debug.prt.act==TRUE THEN
PRINT "exec_move()->強制協調動作モード"
END
END
;ビジョン処理結果反映
CALL update_vspos(.l2num,.l3num,.#pos,.#outpos,.ret)
;movepos関数のBREAK有無フラグをFALSEにしてBREAK無しで実行する
CALL movepos(.rno,.#t,.mode,.type,.#outpos,FALSE,.sp,.ret)
IF data_wait_after[.l2num,.l3num]>=1 THEN
;完全停止後に待ち始める
BREAK
TWAIT data_wait_after[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
END
.END
.PROGRAM exec_pg(.ret)
;-------------------------------- 
;機能：プログラム実行
;引数：無し
;戻値：成否
;--------------------------------
.ret = err_no_error
CALL check_exec_pg(.flg_exec_main)
IF .flg_exec_main==TRUE THEN
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Start execute program automatically."
END
CALL execmain(robot_mode,robot_mode_flg,.ret)
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>5 THEN
.ret = err_main_stop
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() ExecMain timeout occured."
END
RETURN
END
UNTIL (.ret<>err_no_error OR (((flg_main_run==TRUE) OR (flg_direct_run==TRUE)) AND (SWITCH(CS ,1)==ON AND flg_master_move==FALSE) AND (SWITCH(CS ,2)==ON) AND flg_slave_move==FALSE))
IF .ret<>err_no_error THEN
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Can not executed program."
END
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Executed program successfully."
END
END
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Skipped executed program."
END
END
.END
.PROGRAM exec_vision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_vision()"
END
;作業実行時はマスター登録フラグは常にOFF
.recflg = FALSE
CALL get_vision_info(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL vision_main(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
.END
.PROGRAM exec_wend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_wcmd==TRUE THEN
RETURN
END
DO
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_wend()-> ....waiting SLAVE actioon"
END
UNTIL ((flg_slave_move==FALSE) OR (g_last_error<>err_no_error))
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO," ,exec_wend()->      　マスター・スレーブ並列動作終了"
END
;連続動作要求
flg_slave_paral = FALSE
.END
.PROGRAM exec_wstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_wcmd==TRUE THEN
RETURN
END
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_wstart()->      マスター・スレーブ並列動作開始"
END
;連続動作要求
flg_slave_paral = TRUE
gs_l2num = .l2num
gs_l3num = .l3num
;動作開始指示
flg_slave_move = TRUE
.END
.PROGRAM execmain(.robot_mode,.robot_mode_flg,.ret)
;-------------------------------- 
;動作プログラム実行(初期化)
;引数：ロボットモード(0:タブレット、1:ダイレクト)、プログラム実行要否フラグ(ON/OFF)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;エラー状態を一旦解除する
g_last_error = err_no_error
;作業継続要求を一旦解除する
flg_master_con = FALSE
;ロボット状態初期化
CALL resetctrllinfo
;動作プログラム実行準備
CALL rdyboot(TRUE,.ret)
IF .ret<>err_no_error THEN
PRINT "RdyBoot()-> Error ocured,When called RdyBoot(TRUE,.ret)-function"
RETURN
END
UTIMER .@nowtime = 0
.exec_pg = FALSE
IF (.robot_mode==mode_direct) AND (.robot_mode_flg<>FALSE) THEN
MC EXECUTE 1: SAVMOD
.exec_pg = TRUE
END
IF (.robot_mode<>mode_direct) THEN
MC EXECUTE 1: main
.exec_pg = TRUE
END
IF .exec_pg==FALSE THEN
PRINT "ExecMain()-> MASTER-ROBOT dont execute program."
GOTO 10
END
DO
UNTIL ((SWITCH(CS ,1)==ON) OR UTIMER(.@nowtime)>.time_out)
;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
;MC/ERR .err_code = MC EXECUTE 1: main
;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
IF SWITCH(CS ,1)==OFF THEN
PRINT "Can NOT execute program on MASTER-ROBOT."
.ret = err_main_start
CALL update_error(.ret)
RETURN
END
10
UTIMER .@nowtime = 0
IF (.robot_mode==mode_direct) AND (.robot_mode_flg<>FALSE) THEN
MC EXECUTE 2: SAVMOD
.exec_pg = TRUE
END
IF (.robot_mode<>mode_direct) THEN
MC EXECUTE 2: sub
.exec_pg = TRUE
END
IF .exec_pg==FALSE THEN
PRINT "ExecMain()-> SLAVE-ROBOT dont execute program."
RETURN
END
DO
UNTIL ((SWITCH(CS ,2)==ON) OR UTIMER(.@nowtime)>.time_out)
;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
;MC/ERR .err_code = MC EXECUTE 2: sub 
;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
IF SWITCH(CS ,2)==OFF THEN
PRINT "Can NOT execute program on SLAVE-ROBOT."
.ret = err_main_start
CALL update_error(.ret)
RETURN
END
.END
.PROGRAM extout_ctl()
;-------------------------------- 
;機能：ランプ制御
;引数：無し
;戻値：無し
;--------------------------------
IF exout_start_fla==TRUE THEN
;スタートボタン点滅モード中
IF SIG(extout_start_bu)==ON THEN
SIGNAL -extout_start_bu
ELSE
SIGNAL extout_start_bu
END
TWAIT extout_flashtim
END
IF exout_stop_flas==TRUE THEN
;ストップボタン点滅モード中
IF SIG(extout_stop_but)==ON THEN
SIGNAL -extout_stop_but
ELSE
SIGNAL extout_stop_but
END
TWAIT extout_flashtim
END
IF g_last_error<>err_no_error THEN
;エラー有
exout_stop_flas = TRUE
exout_start_fla = FALSE
SIGNAL -extout_start_bu
ELSE
;エラー無し
exout_stop_flas = FALSE
IF exout_start_fla==FALSE AND exout_stop_flas==FALSE THEN
IF ((robot_mode_flg<>FALSE) AND (SWITCH(CS ,1)==ON) AND (SWITCH(CS ,2)==ON)) OR (data_execute==TRUE) OR (flg_master_move==TRUE) OR (flg_slave_move==TRUE) OR (flg_direct_run==TRUE) THEN
;作業実行中
IF ope_command==cmd_exe_gen AND robot_mode==mode_tablet THEN
SIGNAL extout_start_bu
exout_stop_flas = TRUE
ELSE
SIGNAL extout_start_bu,-extout_stop_but
END
ELSE
;停止中
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
SIGNAL extout_stop_but
exout_start_fla = TRUE
ELSE
SIGNAL -extout_start_bu,extout_stop_but
END
END
END
END
;動作中のスイッチ切替
IF flg_tglsw_repea==FALSE THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (data_execute==TRUE) OR (flg_master_move==TRUE) OR (flg_slave_move==TRUE) THEN
.$prm[1] = "-1"
CALL cmdabort(.$prm[],.ret)
;強制的にロボットモード変更
robot_mode = mode_tablet
robot_mode_flg = OFF
END
flg_tglsw_repea = TRUE
END
ELSE
IF SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (data_execute==TRUE) OR (flg_master_move==TRUE) OR (flg_slave_move==TRUE) THEN
.$prm[1] = "-1"
CALL cmdabort(.$prm[],.ret)
;強制的にロボットモード変更
robot_mode = mode_tablet
robot_mode_flg = OFF
END
flg_tglsw_repea = FALSE
END
END
.END
.PROGRAM gen(.$prm[],.ret)
;-------------------------------- 
;機能：ホーム移動
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() .rno=",.$prm[1]
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
END
;K-ROSET
IF kroset THEN
INTFCHK ON
END
;/K-ROSET
CASE VAL(.$prm[1]) OF
VALUE robot_all:
flg_slave_move = TRUE
IF debug.prt.main==ON THEN
PRINT "TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
END
;原点番号設定
.home_no = VAL(.$prm[3])
;ロボット番号設定
.rno = robot_master
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
END
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
END
END
END
VALUE robot_master:
;原点番号設定
.home_no = VAL(.$prm[3])
;ロボット番号設定
.rno = robot_master
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
END
VALUE robot_slave:
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
END
END
END
END
BREAK
.END
.PROGRAM gen_core(.rno,.home_no,.sp,.ret)
;-------------------------------- 
;機能：ホーム移動コア処理
;引数：ホーム番号、動作速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.gen==ON THEN
PRINT "gen_core()-> TASKNO=",TASKNO,".rno=",.rno,".home_no=",.home_no,",.sp=",.sp
END
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
HOME (.home_no)
.END
.PROGRAM get_cominfo(.type,.tcp_port,.tcp_sid,.tcp_sid_num,.udp_port)
;-------------------------------- 
;機能：通信ターゲット情報取得
;引数：なし
;戻値：受信文字列、成否
;-------------------------------- 
.tcp_port = -1
.tcp_sid = -1
.tcp_sid_num = -1
.udp_port = -1
.task_no = TASKNO
CASE .type OF
VALUE type_open:
IF .task_no==pg_com_act THEN
;動作命令用(PCプログラム)
.tcp_port = tcp_listen_port[0]
.tcp_sid_num = 0
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.tcp_port = tcp_listen_port[1]
.tcp_sid_num = 1
ELSE
PRINT "TYPE_OPEN -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
RETURN
END
END
VALUE type_recv:
IF .task_no==pg_com_act THEN
;動作命令用(PCプログラム)
.udp_port = port_udp[1]
.tcp_sid = tcp_sid[0]
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.udp_port = port_udppc[1]
.tcp_sid = tcp_sid[1]
ELSE
PRINT "TYPE_RECV -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
END
END
VALUE type_send:
IF .task_no==pg_master OR .task_no==pg_slave OR .task_no==pg_com_act OR .task_no==1001 THEN
;動作命令用(メインプログラム、もしくはPCプログラム)
.udp_port = port_udp[0]
.tcp_sid = tcp_sid[0]
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.udp_port = port_udppc[0]
.tcp_sid = tcp_sid[1]
ELSE
PRINT "TYPE_SEND -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
END
END
END
.END
.PROGRAM get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
;-------------------------------- 
;機能：データを遡って協調開始コマンド、並列実行コマンドが無いかチェックする
;引数：第2階層、第3階層
;戻値：並列実行再要求フラグ、協調動作再実行フラグ
;-------------------------------- 
.req_cstart = FALSE
.req_wstart = FALSE
FOR .i = .l3num TO 1 STEP -1
IF data_l3type[.l2num,.i]==l3type_cend THEN
;STARTの前にENDを見つけたら探索中断、再実行不要
GOTO 10
END
IF data_l3type[.l2num,.i]==l3type_cstart THEN
;再度必要
.req_cstart = TRUE
GOTO 10
END
END
10
FOR .i = .l3num TO 1 STEP -1
IF data_l3type[.l2num,.i]==l3type_wend THEN
;STARTの前にENDを見つけたら探索中断、再実行不要
IF data_cur_l2rec[robot_slave]<>0 AND data_cur_l3rec[robot_slave] THEN
;スレーブロボット動作中のため再度必要
.req_wstart = TRUE
END
GOTO 20
END
IF data_l3type[.l2num,.i]==l3type_wstart THEN
;再度必要
.req_wstart = TRUE
GOTO 20
END
END
20
.END
.PROGRAM get_iotype(.signo,.sigtype,.ret)
;-------------------------------- 
;機能：IO種類取得(信号設定範囲外の場合はエラー)
;引数：信号番号
;戻値：IO種類、成否
;-------------------------------- 
.ret = err_no_error
.sigtype = io_unknown
.fb_io = ZOPTION(13,2);汎用フィールドバスI/O設定
IF (0<.signo) AND (.signo<1000) THEN
IF .fb_io<>OFF THEN;汎用FB設定ON
.out_sig_num = SYSDATA(ZSIGSPEC.DO)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
.out_sig_num = SYSDATA(ZSIGSPEC.DO)
END
IF .signo<=.out_sig_num THEN
.sigtype = io_do
RETURN
END
END
IF (1000<.signo) AND (.signo<2000) THEN
IF .fb_io<>OFF THEN;汎用FB設定ON
.in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
.in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)
END
IF .signo<=.in_sig_num THEN
.sigtype = io_di
RETURN
END
END
IF (2000<.signo) AND (.signo<3000) THEN
IF .signo<=(2000+SYSDATA(ZSIGSPEC.INT)) THEN
.sigtype = io_int
RETURN
END
END
.ret = err_bad_signo
IF .fb_io<>OFF THEN;汎用FB設定ON
PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT),SYSDATA(ZSIGSPEC.MAS),SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT)
END
.END
.PROGRAM get_jttype(.rno,.mode,.#axis_type)
;-------------------------------- 
;機能：軸構成情報取得
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)
;戻値：成否
;-------------------------------- 
;初期化
;MODE_LIN = 0
;MODE_ROT = 1
IF .mode==mode_jt THEN
.axis_type[1] = mode_rot;JT1
.axis_type[2] = mode_rot;JT2
.axis_type[3] = mode_lin;JT3
.axis_type[4] = mode_rot;JT4
.axis_type[5] = mode_rot;xxx外部軸仕様未確定xxx
.axis_type[6] = mode_rot;xxx外部軸仕様未確定xxx
ELSE
.axis_type[1] = mode_lin;X
.axis_type[2] = mode_lin;Y
.axis_type[3] = mode_lin;Z
.axis_type[4] = mode_rot;R1
.axis_type[5] = mode_rot;xxx外部軸仕様未確定xxx
.axis_type[6] = mode_rot;xxx外部軸仕様未確定xxx
END
;設定反映
IF 1 THEN
;xxx外部軸仕様未確定xxx
POINT .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6])
RETURN
END
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
IF .mode==mode_jt THEN
.target_axis = 0;xxx外部軸仕様未確定xxx
CASE data_exttype[.temp_rno] OF
VALUE exttype_linear:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->各軸動作、外部軸=直動軸"
END
.axis_type[.target_axis] = mode_lin
VALUE exttype_rot:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->各軸動作、外部軸=回転"
END
.axis_type[.target_axis] = mode_rot
VALUE exttype_none:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->各軸動作、外部軸=切断"
END
.axis_type[.target_axis] = mode_none
END
ELSE
.target_axis = 0;xxx外部軸仕様未確定xxx
CASE data_exttype[.temp_rno] OF
VALUE exttype_linear:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->XYZR1EXT1動作、外部軸=直動"
END
.axis_type[.target_axis] = mode_lin
VALUE exttype_rot:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->XYZR1EXT1動作、外部軸=回転"
END
.axis_type[.target_axis] = mode_rot
VALUE exttype_none:
IF debug.prt.cmd==TRUE THEN
PRINT "get_jttype()->XYZR1EXT1動作、外部軸=切断"
END
.axis_type[.target_axis] = mode_none
END
END
POINT .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6])
.END
.PROGRAM get_vision_info(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン設定テーブルから条件取得
;引数：ロボット番号、ビジョンID
;戻値：カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、成否
;-------------------------------- 
.ret = err_no_error
;実行中のロボット種別取得
;テーブル中から条件検索してあれば応答する
FOR .i = 1 TO data_vs_tbnum
IF data_vs_vid[.i]==.id THEN
.camno = data_vs_cam_num[.i]
.calno = data_vs_calc_nu[.i]
.camtype = data_vs_cam_typ[.i]
.holdtype = data_vs_hold_ty[.i]
.calpos = data_vs_calc_po[.i]
IF debug.prt.visio==TRUE THEN
PRINT "get_vision_info()->.rno=",.rno
PRINT "get_vision_info()->.id=",.id
PRINT "get_vision_info()->.camno=",.camno
PRINT "get_vision_info()->.calno=",.calno
PRINT "get_vision_info()->.camtype=",.camtype
PRINT "get_vision_info()->.holdtype=",.holdtype
PRINT "get_vision_info()->.calpos=",.calpos
END
RETURN
END
END
.ret = err_bad_visionn
.END
.PROGRAM get_vision_resu(.id,.type,.calpos,.x,.y,.rot,.ret)
;-------------------------------- 
;機能：ビジョン計測結果取得
;引数：ビジョンID、結果種類(1:マスター、0:非マスター)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)
;戻値：X座標値、Y座標値、θ座標値、成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "get_vision_result()->.id=",.id,", .type=",.type,", .calpos=",.calpos
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)==2 THEN
.x = 0
.y = 0
.rot = 0
RETURN
END
IF .type==1 THEN
;マスター
NOEXIST_SET_L v_master[.id,1] = TRANS(0,0,0,0,0,0)
DECOMPOSE .buf[1] = v_master[.id,1]
.x = .buf[1]
.y = .buf[2]
.rot = .buf[4]
ELSE
;非マスター
NOEXIST_SET_L vwork[.id,1] = TRANS(0,0,0,0,0,0)
DECOMPOSE .buf[1] = vwork[.id,1]
.x = .buf[1]
.y = .buf[2]
.rot = .buf[4]
END
.END
.PROGRAM getcmd(.$prm[],.num,.ret)
;-------------------------------- 
;機能：コマンドデータ取得(動作プログラム実行用)
;引数：なし
;戻値：実数データ配列(最大20個)、実数データ数、文字列データ配列、文字列データ数、成否
;-------------------------------- 
.ret = err_no_error
CALL recv(.$str,.ret)
IF .ret==0 THEN
.num = 0
;文字列取込み
CALL csv_to_str(.$str,.$prm[],.num,.ret)
IF .num>=20 THEN
;バッファ掃除のために無視する
.ret = err_cmd_prmnum
RETURN
END
END
.END
.PROGRAM getcurrentpos(.rno,.mode,.#pos,.ret)
;-------------------------------- 
;機能：現在値を指定モードで取得してDECOMPOSEした値を返す
;引数：モード(MODE_JT,MODE_XYZR1EXT1)
;戻値：DECOMPOSEした位置要素配列、成否
;-------------------------------- 
.ret = err_no_error
CASE .mode OF
VALUE mode_jt:
IF .rno==0 OR .rno==1 THEN
;両方のロボットを動かすときはMASTER側が基準
POINT .#pos1 = #S_HERE(1)
ELSE
POINT .#pos1 = #S_HERE(2)
END
DECOMPOSE .pos[1] = .#pos1
VALUE mode_xyzr1ext1:
IF .rno==0 OR .rno==1 THEN
;両方のロボットを動かすときはMASTER側が基準
IF 0 THEN
;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
ZL3TRN 1: .pos[1]=#S_HERE(1),1
ELSE
;ツール変換値考慮
DECOMPOSE .pos[1] = S_HERE(1)
END
;                POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
ELSE
IF 0 THEN
;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
ZL3TRN 2: .pos[1]=#S_HERE(2),1
ELSE
;ツール変換値考慮
DECOMPOSE .pos[1] = S_HERE(2)
END
;               POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
END
;            DECOMPOSE .pos[1]=.pos
ANY :
.ret = err_bad_mode
RETURN
END
POINT .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
.END
.PROGRAM getparam(.cmd,.$prm[],.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL(.$prm[1])
CASE .cmd OF
VALUE cmd_get_sp:
;This protcol will delete soon.
.$res = $ENCODE(0)
VALUE cmd_get_pitch:
.$res = $ENCODE(data_teachrot)+","+$ENCODE(data_teachpitch)+","+$ENCODE(data_exttype[robot_master])+","+$ENCODE(data_exttype[robot_slave])
VALUE cmd_get_tnum:
.$res = $ENCODE(tool_data_num[.rno])
VALUE cmd_get_tool:
.mode = VAL(.$prm[2]);モードは無効、後日削除
POINT .toolprm = def_tool[.rno,VAL(.$prm[3])]
DECOMPOSE .toolprm[1] = .toolprm
;重量、重心(XYZイナーシャXYZ)は未対応のため固定値応答
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
.$res = $ENCODE(.toolprm[1])+","+$ENCODE(.toolprm[2])+","+$ENCODE(.toolprm[3])+",0,0,0,0,0,0,0"
VALUE cmd_get_cord:
.$res = $ENCODE(data_teachcoord)
VALUE cmd_get_pos:
.mode = VAL(.$prm[2])
;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
.$res = "err_bad_mode"
ELSE
DECOMPOSE .cpos[1] = .#cpos
.$res = $ENCODE(.cpos[1])+","+$ENCODE(.cpos[2])+","+$ENCODE(.cpos[3])+","+$ENCODE(.cpos[4])+","+$ENCODE(.cpos[5])
END
VALUE cmd_get_info:
IF g_last_error!=0 THEN
.err = 1
ELSE
.err = 0
END
CASE .rno OF
VALUE robot_all:
IF SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON THEN
;両方ONでON
.power_sw = 1
ELSE
.power_sw = 0
END
VALUE robot_master:
IF SWITCH(POWER ,1)==ON THEN
.power_sw = 1
ELSE
.power_sw = 0
END
VALUE robot_slave:
IF SWITCH(POWER ,2)==ON THEN
.power_sw = 1
ELSE
.power_sw = 0
END
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
IF data_execute==TRUE OR flg_master_move==TRUE OR flg_slave_move==TRUE THEN
.robot_status = status_move
ELSE
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
.robot_status = status_hold
ELSE
.robot_status = status_nomove
END
END
.direct_status = 0
IF robot_mode==mode_direct THEN
IF SWITCH(CS ,1)==ON AND SWITCH(CS ,2)==ON AND (robot_mode_flg<>FALSE) THEN
.direct_status = 1
END
END
.tablet_status = 0
IF robot_mode==mode_tablet THEN
IF SWITCH(CS ,1)==ON AND SWITCH(CS ,2)==ON AND (robot_mode_flg<>FALSE) THEN
.tablet_status = 1
END
END
.$res = $data_cur_l1name+","+$ENCODE(data_cur_l2disp)+","+$ENCODE(data_cur_l3disp)+","+$ENCODE(.robot_status)+","+$ENCODE(.power_sw)+","+$ENCODE(.err)
.$res = .$res+","+$ENCODE(-SIG(sig_emg_output))+","+$ENCODE(.tablet_status)+","+$ENCODE(.direct_status)+","+$ENCODE(g_last_error)
IF .rno==robot_slave THEN
.$res = .$res+","+$ENCODE(MSPEED2)+","+$ENCODE(MSPEED2)
ELSE
;両方の場合はマスターを返す
.$res = .$res+","+$ENCODE(MSPEED)+","+$ENCODE(MSPEED)
END
;2015/10/2タブレット未対応のためタブレット対応までの間はIF0とする
IF 0 THEN
;原点位置状態情報追加
IF SIG(sig_r1gen1_outp)==ON THEN
.r1gen1 = 1
ELSE
.r1gen1 = 0
END
IF SIG(sig_r2gen1_outp)==ON THEN
.r2gen1 = 1
ELSE
.r2gen1 = 0
END
.$res = .$res+","+$ENCODE(.r1gen1)+","+$ENCODE(.r2gen1)
END
VALUE cmd_get_l1info:
.$res = $data_cur_l1name+","+$ENCODE(data_l2num)
VALUE cmd_get_l2info:
.$res = $data_l2name[VAL(.$prm[2])]+","+$ENCODE(data_l3num[VAL(.$prm[2])])+","+$ENCODE(data_l2exetblnu[VAL(.$prm[2])])
VALUE cmd_get_l3info:
.$res = $data_l3name[VAL(.$prm[2]),VAL(.$prm[3])]
VALUE cmd_get_io:
IF SIG(VAL(.$prm[2])) THEN
.$res = "1"
ELSE
.$res = "0"
END
VALUE cmd_get_home:
.homeno = VAL(.$prm[2])
IF .rno!=1 && .rno!=2 THEN
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
IF .homeno!=1 && .homeno!=2 THEN
.ret = err_bad_homeno
.$res = "err_bad_homeno"
RETURN
END
POINT .rno: .#home = #HOME(.homeno)
DECOMPOSE .buf[1] = .#home
;精度取得のみ未対応
.buf[7] = robot_hacc[.rno,.homeno]
;.buf[1]-.buf[5]=JT1-JT5,.buf[7]=精度
;タブレット送信データ並び順=JT1,JT2,JT3,JT4,Ext1
.$res = $ENCODE(.buf[1])+","+$ENCODE(.buf[2])+","+$ENCODE(.buf[3])+","+$ENCODE(.buf[4])+","+$ENCODE(.buf[5])+","+$ENCODE(.buf[7])
VALUE cmd_get_signame:
IF VAL(.$prm[2])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $data_io_num[VAL(.$prm[2])]+","+$data_io_name[VAL(.$prm[2])]
VALUE cmd_get_signum:
IF VAL(.$prm[2])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(data_io_tablenu)
VALUE cmd_get_monsp:
CASE .rno OF
VALUE robot_all,robot_master:
;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
.$res = $ENCODE(MSPEED)
VALUE robot_slave:
.$res = $ENCODE(MSPEED2)
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
VALUE cmd_get_l2exetb:
IF VAL(.$prm[3])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(data_l2tbl_sign[VAL(.$prm[2]),VAL(.$prm[3])])+","+$ENCODE(data_l2tbl_stat[VAL(.$prm[2]),VAL(.$prm[3])])
VALUE cmd_get_infoex:
IF .rno!=1 && .rno!=2 THEN
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
;現在位置
.mode = VAL(.$prm[2])
;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
.$res = "err_bad_mode"
RETURN
ELSE
DECOMPOSE .cpos[1] = .#cpos
.$res = $ENCODE(.cpos[1])+","+$ENCODE(.cpos[2])+","+$ENCODE(.cpos[3])+","+$ENCODE(.cpos[4])+","+$ENCODE(.cpos[5])+","
END
CASE .rno OF
VALUE robot_all,robot_master:
;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
.$res = .$res+$ENCODE(MSPEED)
VALUE robot_slave:
.$res = .$res+$ENCODE(MSPEED2)
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
;アーム動作速度、アーム動作ピッチ(回転)、アーム動作ピッチ(直動)
.$res = .$res+","+$ENCODE(data_teachrot)+","+$ENCODE(data_teachpitch)+","
;IO取得
IF SIG(VAL(.$prm[4])) THEN
.$res = .$res+"1,"
ELSE
.$res = .$res+"0,"
END
;ハンド状態取得
.$res = .$res+$ENCODE(data_hand_cur[.rno])
VALUE cmd_get_hand:
.$res = $ENCODE(data_hand_cur[robot_master])+","+$ENCODE(data_hand_cur[robot_slave])
VALUE cmd_get_handio:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
VALUE robot_master,robot_slave:
.$res = $ENCODE(data_hand_type[.rno])+","+$ENCODE(data_hand_io[.rno,1])+","+$ENCODE(data_hand_io[.rno,2])+","+$ENCODE(data_hand_io[.rno,3])+","+$ENCODE(data_hand_io[.rno,4])
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
VALUE cmd_get_vtb:
.vtblno = VAL(.$prm[2])
IF .vtblno<=0 THEN
;タブレット側が番号0で呼出している暫定対策20150804
;.ret=err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
NOEXIST_SET_R data_vs_robot[.vtblno] = 0
NOEXIST_SET_R data_vs_cam_num[.vtblno] = 0
NOEXIST_SET_R data_vs_calc_nu[.vtblno] = 0
NOEXIST_SET_R data_vs_cam_typ[.vtblno] = 0
NOEXIST_SET_R data_vs_hold_ty[.vtblno] = 0
NOEXIST_SET_R data_vs_calc_po[.vtblno] = 0
NOEXIST_SET_S $data_vs_name[.vtblno] = "NO SETTING"
CALL convert_vid(mode_del,data_vs_calc_po[.vtblno],data_vs_vid[.vtblno],.vision_id)
.$res = $ENCODE(.vision_id)+","+$ENCODE(data_vs_cam_num[.vtblno])+","+$ENCODE(data_vs_calc_nu[.vtblno])
.$res = .$res+","+$ENCODE(data_vs_cam_typ[.vtblno])+","+$ENCODE(data_vs_hold_ty[.vtblno])+","+$ENCODE(data_vs_calc_po[.vtblno])
.$res = .$res+","+$data_vs_name[.vtblno]+","+$ENCODE(data_vs_robot[.vtblno])
VALUE cmd_get_vtbnum:
.$res = $ENCODE(data_vs_tbnum)
VALUE cmd_get_vresult:
;ビジョンID変換
CALL convert_vid(mode_add,VAL(.$prm[4]),VAL(.$prm[2]),.vision_id)
CALL get_vision_resu(.vision_id,VAL(.$prm[3]),VAL(.$prm[4]),.x,.y,.rot,.ret)
.$res = $ENCODE(.x)+","+$ENCODE(.y)+","+$ENCODE(.rot)
VALUE cmd_get_robotmo:
.$res = $ENCODE(robot_mode)+","+$ENCODE(robot_mode_flg)
VALUE cmd_get_lowspar:
IF VAL(.$prm[2])<=0 OR VAL(.$prm[2])>=5 THEN
.ret = err_bad_areano
RETURN
END
NOEXIST_SET_R areaslow_locati[VAL(.$prm[2]),1] = 0
NOEXIST_SET_R areaslow_locati[VAL(.$prm[2]),2] = 0
NOEXIST_SET_R areaslow_locati[VAL(.$prm[2]),3] = 0
NOEXIST_SET_R areaslow_locati[VAL(.$prm[2]),4] = 0
NOEXIST_SET_R areaslow_rate[VAL(.$prm[2])] = 0
.$res = $ENCODE(areaslow_locati[VAL(.$prm[2]),1])+","+$ENCODE(areaslow_locati[VAL(.$prm[2]),2])+","+$ENCODE(areaslow_locati[VAL(.$prm[2]),3])+","+$ENCODE(areaslow_locati[VAL(.$prm[2]),4])+","+$ENCODE(areaslow_rate[VAL(.$prm[2])])
VALUE cmd_get_lowspse:
NOEXIST_SET_R areaslow_mode = 0
.$res = $ENCODE(areaslow_mode)
VALUE cmd_get_gravity:
NOEXIST_SET_R grav_cur_val[0] = 0
NOEXIST_SET_R grav_cur_val[1] = 0
.$res = $ENCODE(-flg_gravityadj_)+","+$ENCODE(grav_cur_val[0])+","+$ENCODE(grav_cur_val[1])
VALUE cmd_get_colchkm:
.$res = $ENCODE(flg_enable_colc)
VALUE cmd_get_slowlim:
.$res = $ENCODE(slowlimit_speed)+","+$ENCODE(slowlimit_time)
VALUE cmd_get_iftblnu:
.$res = $ENCODE(data_ifcontblnu)
VALUE cmd_get_ifconnu:
.ifcon_no = VAL(.$prm[3])
;設定タイミングの自由度を上げるために上限チェックはしない
IF .ifcon_no<=0 THEN
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(data_ifconnum[VAL(.$prm[2])])
VALUE cmd_get_iftbl:
.iftbl_no = VAL(.$prm[2])
IF .iftbl_no<=0 THEN
.$res = "err_bad_tableno"
RETURN
END
.ifcon_no = VAL(.$prm[3])
;設定タイミングの自由度を上げるために上限チェックはしない
IF .ifcon_no<=0 THEN
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(data_ifcontype[.iftbl_no,.ifcon_no])+","+$ENCODE(data_ifconsign[.iftbl_no,.ifcon_no])+","+$ENCODE(data_ifconval[.iftbl_no,.ifcon_no])
IF data_ifcontype[.iftbl_no,.ifcon_no]==ifcon_cnt THEN
.$res = .$res+","+$ENCODE(data_ifconcnt[.iftbl_no,.ifcon_no])
END
ANY :
.ret = err_bad_num
.$res = "err_bad_num"
END
.END
.PROGRAM getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
;-------------------------------- 
;機能：1点分の位置情報の取得
;引数：第2階層番号、第3階層番号
;戻値：動作方法(.mode->0;JT、1:XYZR1EXT1)、教示点構成要素(.data実数配列)、補間方法(.type->0:LMOVE、1:JMOVE)、成否
;-------------------------------- 
.ret = err_no_error
.dtype = data_l3type[.l2num,.l3num]
IF .dtype!=l3type_move THEN
.ret = err_bad_l3type
RETURN
END
.mode = data_mode[.l2num,.l3num]
.type = data_postype[.l2num,.l3num]
.pos[1] = data_pos1[.l2num,.l3num]
.pos[2] = data_pos2[.l2num,.l3num]
.pos[3] = data_pos3[.l2num,.l3num]
.pos[4] = data_pos4[.l2num,.l3num]
.pos[5] = data_pos5[.l2num,.l3num]
.pos[6] = data_pos6[.l2num,.l3num]
POINT .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
.END
.PROGRAM getstep(.$prm[],.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
.ret = err_no_error
.l2num = VAL(.$prm[2])
.l3num = VAL(.$prm[3])
.l3type = data_l3type[.l2num,.l3num]
CASE .l3type OF
VALUE l3type_move:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]
;ビジョンID変換(引数順でID割当番号)
.vision_id1 = data_vision_id1[.l2num,.l3num]
CALL convert_vid(mode_del,type_pos,data_vision_id2[.l2num,.l3num],.vision_id2)
CALL convert_vid(mode_del,type_pos,data_vision_id3[.l2num,.l3num],.vision_id3)
.$res = .$res+","+$ENCODE(data_vision_sta[.l2num,.l3num])+","+$ENCODE(.vision_id1)+","+$ENCODE(.vision_id2)+","+$ENCODE(.vision_id3)
.$res = .$res+","+$ENCODE(data_repspeed[.l2num,.l3num])+","+$ENCODE(data_postype[.l2num,.l3num])+","+$ENCODE(data_wait_befor[.l2num,.l3num])+","+$ENCODE(data_wait_after[.l2num,.l3num])
VALUE l3type_io_wait:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_signum[.l2num,.l3num])
.$res = .$res+","+$ENCODE(data_sigstatus[.l2num,.l3num])+","+$ENCODE(data_wait_befor[.l2num,.l3num])+","+$ENCODE(data_wait_after[.l2num,.l3num])+","+$ENCODE(data_wait_timeo[.l2num,.l3num])
VALUE l3type_io_chang:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_signum[.l2num,.l3num])
.$res = .$res+","+$ENCODE(data_sigstatus[.l2num,.l3num])+","+$ENCODE(data_wait_befor[.l2num,.l3num])+","+$ENCODE(data_wait_after[.l2num,.l3num])+","+$ENCODE(data_keep_wait[.l2num,.l3num])
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend,l3type_return:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]
VALUE l3type_vision,l3type_calvisio:
;ビジョンID変換
CALL convert_vid(mode_del,data_vision_cal[.l2num,.l3num],data_vision_id[.l2num,.l3num],.vision_id)
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(.vision_id)+","+$ENCODE(data_vision_cal[.l2num,.l3num])
VALUE l3type_l2reset:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_l2resetnum[.l2num,.l3num])
VALUE l3type_hand_cha:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_hand_ctl[.l2num,.l3num])
VALUE l3type_colchk:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_colchk[.l2num,.l3num])
VALUE l3type_ifgoto:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$ENCODE(data_l3ifgoto_i[.l2num,.l3num])+","+$data_l3ifgoto_l[.l2num,.l3num]
VALUE l3type_iflabel:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$data_l3label[.l2num,.l3num]
VALUE l3type_cntup:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$data_l3label[.l2num,.l3num]+","+$ENCODE(data_cntid[.l2num,.l3num])
VALUE l3type_cntset:
.$res = $ENCODE(data_robottype[.l2num,.l3num])+","+$ENCODE(data_l3type[.l2num,.l3num])+","+$data_l3name[.l2num,.l3num]+","+$data_l3label[.l2num,.l3num]+","+$ENCODE(data_cntid[.l2num,.l3num])+","+$ENCODE(data_cntval[.l2num,.l3num])
ANY :
.ret = err_bad_l3type
END
.END
.PROGRAM getsteppos(.$prm[],.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL(.$prm[2])
.l3num = VAL(.$prm[3])
.$buf1 = $ENCODE(data_mode[.l2num,.l3num])+","+$ENCODE(data_tool[.l2num,.l3num])
IF data_mode[.l2num,.l3num]<>mode_jt THEN
.$res = .$buf1+","+$ENCODE(data_pos1[.l2num,.l3num])+","+$ENCODE(data_pos2[.l2num,.l3num])+","+$ENCODE(data_pos3[.l2num,.l3num])+","+$ENCODE(data_pos4[.l2num,.l3num])+","+$ENCODE(data_pos5[.l2num,.l3num])
ELSE
.$res = .$buf1+","+$ENCODE(data_pos1[.l2num,.l3num])+","+$ENCODE(data_pos2[.l2num,.l3num])+","+$ENCODE(data_pos3[.l2num,.l3num])+","+$ENCODE(data_pos4[.l2num,.l3num])+","+$ENCODE(data_pos5[.l2num,.l3num])
END
.END
.PROGRAM gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
;-------------------------------- 
;重力補償自動調整呼出
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
flg_slave_grave = FALSE
CASE .rno OF
VALUE robot_all:
gs_gravity_mode = .mode
gs_gravity_setv = .slave_setval
flg_slave_move = TRUE
IF debug.prt.main==ON THEN
PRINT "->gravityadj() TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot started gravityadj_core()."
END
CALL gravityadj_core(robot_master,.mode,.master_setval,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot done gravityadj_core()."
END
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF flg_slave_grave==TRUE THEN
.ret = err_gravityadj
flg_slave_grave = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() Slave robot done gravityadj_core()."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
END
END
END
VALUE robot_master:
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot started gravityadj_core()."
END
CALL gravityadj_core(robot_master,.mode,.master_setval,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot done gravityadj_core()."
END
VALUE robot_slave:
gs_gravity_mode = .mode
gs_gravity_setv = .slave_setval
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF flg_slave_grave==TRUE THEN
.ret = err_gravityadj
flg_slave_grave = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() Slave robot done gravityadj_core()."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
END
END
END
END
BREAK
.END
.PROGRAM gravityadj_core(.rno,.mode,.setval,.ret)
;-------------------------------- 
;重力補償自動調整処理
;引数：ロボット番号、モード(0:自動、1:手動)、ロボット番号に対応した設定値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
flg_gravityadj_ = TRUE
PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... .rno=",.rno,",.mode=",.mode,",.setval=",.setval
IF .mode==1 THEN
ZSAGRAV .rno: 3,.setval
grav_init[.rno] = .setval
grav_cur_val[.rno-1] = .setval
ELSE
CALL setgrav(.rno,.ret)
END
IF .ret<>err_no_error AND TASKNO==robot_slave THEN
flg_slave_grave = TRUE
END
NOEXIST_SET_R grav_cur_val[0] = 0
NOEXIST_SET_R grav_cur_val[1] = 0
PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... GRAV_CUR_VAL[0]=",grav_cur_val[0],",GRAV_CUR_VAL[1]=",grav_cur_val[1]
flg_gravityadj_ = FALSE
.END
.PROGRAM hand(.rno,.status,.ret)
;-------------------------------- 
;機能：ハンド操作
;引数：ロボット番号、ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",HAND STATUS=",.status
END
CASE .rno OF
VALUE robot_all:
CALL handiochk(robot_master,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL handiochk(robot_slave,.ret)
IF .ret<>err_no_error THEN
RETURN
END
data_hand_cur[robot_master] = .status
data_hand_cur[robot_slave] = .status
CALL handmove(robot_master,.status,.ret)
CALL handmove(robot_slave,.status,.ret)
VALUE robot_master,robot_slave:
CALL handiochk(.rno,.ret)
IF .ret<>err_no_error THEN
RETURN
END
data_hand_cur[.rno] = .status
CALL handmove(.rno,.status,.ret)
ANY :
.ret = err_bad_rno
PRINT "TASKNO=",TASKNO,",err_bad_rno"
RETURN
END
.END
.PROGRAM handiochk(.rno,.ret)
;-------------------------------- 
;機能：ハンド制御信号設定状態チェック
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF data_hand_type[.rno]==hand_single THEN
IF (data_hand_io[.rno,1]==0) THEN
.ret = err_bad_handio
PRINT "chkhandio()->err_bad_handio"
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",data_hand_type[.rno],"(HAND_SINGLE),io1=",data_hand_io[.rno,1],",io2=",data_hand_io[.rno,2]
RETURN
END
END
IF data_hand_type[.rno]==hand_double THEN
IF (data_hand_io[.rno,1]==0) OR (data_hand_io[.rno,2]==0) THEN
.ret = err_bad_handio
PRINT "chkhandio()->err_bad_handio"
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",data_hand_type[.rno],"(HAND_DOUBLE),io1=",data_hand_io[.rno,1],",io2=",data_hand_io[.rno,2],",io3=",data_hand_io[.rno,3],",io4=",data_hand_io[.rno,4]
RETURN
END
END
.END
.PROGRAM handmove(.rno,.status,.ret)
;-------------------------------- 
;機能：ハンド制御信号変更
;引数：ロボット番号、ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF data_hand_type[.rno]==hand_single THEN
IF .status==hand_close THEN
SIGNAL data_hand_io[.rno,1]
END
IF .status==hand_open THEN
SIGNAL -data_hand_io[.rno,1]
END
END
IF data_hand_type[.rno]==hand_double THEN
IF .status==hand_close THEN
SIGNAL data_hand_io[.rno,1],-data_hand_io[.rno,2]
END
IF .status==hand_open THEN
SIGNAL -data_hand_io[.rno,1],data_hand_io[.rno,2]
END
END
.END
.PROGRAM iochange(.signo,.status,.keeptime,.ret)
;-------------------------------- 
;機能：IO変更実行
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;説明；信号変更前の状態を保持して状態保持時間経過後にIO変更前の状態に戻す
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", Keed Signal Time=",.keeptime
END
IF .signo<=0 THEN
;信号状態は.statusに分離管理しているので.signo負値は存在しない
;操作を無視したいときに上位が意図的に0を設定する可能性があるため許容する
RETURN
END
CALL get_iotype(.signo,.sigtype,.ret)
IF .ret<>err_no_error THEN
RETURN
END
.pre_io_status = SIG(.signo)
IF .status<>FALSE THEN
SIGNAL .signo
ELSE
SIGNAL -.signo
END
IF .keeptime>0 THEN
TWAIT .keeptime/1000
IF .pre_io_status<>FALSE THEN
SIGNAL .signo
ELSE
SIGNAL -.signo
END
END
.END
.PROGRAM killpg()
;---------------------------------
;機能：プログラムロード準備
;    ；全TASK停止、PCプログラム7番で実行専用
;---------------------------------
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " This program have to execute in PC-PROGRAM No.7."
PRINT " "
IF TASKNO<>1007 THEN
PRINT " "
PRINT " *****************************************"
PRINT "  Aborted execute killpg()."
PRINT "  Please execute in PC-PROGRAM No.7."
PRINT "  You doing execute in TASKNO=",TASKNO
PRINT " *****************************************"
PRINT " "
RETURN
END
PRINT " Starting.... killpg()"
flg_start_killp = TRUE
PCABORT 6: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1006)<>1 THEN
PRINT "  1006-PCABORT"
GOTO 12
END
END
12
PCABORT 5: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1005)<>1 THEN
PRINT "  1005-PCABORT"
GOTO 13
END
END
13
PCABORT 1: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1001)<>1 THEN
PRINT "  1001-PCABORT"
GOTO 14
END
END
14
PCABORT 3: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1003)<>1 THEN
PRINT "  1003-PCABORT"
GOTO 15
END
END
15
PCABORT 4: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1004)<>1 THEN
PRINT "  1004-PCABORT"
GOTO 16
END
END
16
MC PCKILL 4: 
PRINT "  1004-PCKILL"
MC PCKILL 3: 
PRINT "  1003-PCKILL"
MC PCKILL 6: 
PRINT "  1006-PCKILL"
MC PCKILL 5: 
PRINT "  1005-PCKILL"
MC PCKILL 1:
PRINT "  1001-PCKILL"
PRINT " "
;ロボットマスター
MC HOLD 1:
PRINT "  1-HOLD"
MC ABORT 1:
PRINT "  1-ABORT"
TWAIT 1
MC KILL 1:
PRINT "  1-KILL"
;ロボットスレーブ
MC HOLD 2:
PRINT "  2-HOLD"
MC ABORT 2:
PRINT "  2-ABORT"
TWAIT 1
MC KILL 2:
PRINT "  2-KILL"
PRINT " "
PRINT " Done killpg(). Now... You can be load some files for controllers in safety."
PRINT " "
MC ZPOW 1: OFF
MC ZPOW 2: OFF
.END
.PROGRAM l2check(.l2num,.ret)
;-------------------------------- 
;機能：第2階層作業条件の成立チェック
;引数：無し
;戻値：成立した第2階層番号、成立有無(FALSE/TRUE)
;-------------------------------- 
.ret = FALSE
.l2num = -1
;.i=第2階層番号、.j=テーブル番号,.cnt=成立条件数
FOR .i = 1 TO data_l2num
IF data_l2exetblnu[.i]<=0 THEN
;実行条件無し即実行
.l2num = .i
.ret = TRUE
RETURN
ELSE
.cnt = 0
FOR .j = 1 TO data_l2exetblnu[.i]
IF data_l2tbl_sign[.i,.j]=<3000 THEN
IF data_l2tbl_stat[.i,.j]==1 THEN
IF SIG(data_l2tbl_sign[.i,.j])==ON THEN
.cnt = .cnt+1
END
ELSE
IF SIG(data_l2tbl_sign[.i,.j])==OFF THEN
.cnt = .cnt+1
END
END
ELSE
IF data_l2tbl_stat[.i,.j]==1 THEN
IF data_l2status[data_l2tbl_sign[.i,.j]-3000]==TRUE THEN
.cnt = .cnt+1
END
ELSE
IF data_l2status[data_l2tbl_sign[.i,.j]-3000]==FALSE THEN
.cnt = .cnt+1
END
END
END
END
IF .cnt==data_l2exetblnu[.i] THEN
;実行条件成立
.l2num = .i
.ret = TRUE
RETURN
END
END
END
.END
.PROGRAM l2exec(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：第2階層実行
;引数：第2階層、第3階層
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()->.l2num=",.l2num,",.l3num=",.l3num
END
;カウンタ値リセット
CALL exec_cntset(0,0,0,.ret)
FOR .i = .l3num TO data_l3num[.l2num]
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> $data_l3name[",.l2num,",",.i,"]=",$data_l3name[.l2num,.i]
END
;作業継続用情報更新
CALL updatel2l3info(TRUE,.l2num,.i,FALSE)
CALL exec_main(.l2num,.i,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CASE .ret OF
VALUE err_slave_acten:
;戻り値：[内部制御用エラーコード]スレーブロボット並列作業完了検知
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> スレーブ作業完了しました .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
;作業継続用情報初期化(スレーブ単体)
CALL updatel2l3info(FALSE,-1,0,FALSE)
VALUE err_l3_actend:
;戻り値：[内部制御用エラーコード]RETURNコマンド検知
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURNコマンド検知 .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
;マスターロボット
IF TASKNO==pg_master THEN
;並列作業中はスレーブロボットの完了を待つ
IF (flg_slave_move==TRUE) OR (flg_slave_paral==TRUE) THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>slave_timeout THEN
.ret = err_srobot_time
RETURN
END
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> WAITING... SLAVE-ROBOT still not booted.OPE_COMMAND=",ope_command
END
TWAIT 0.1
UNTIL (flg_slave_move==FALSE)
END
;作業自体をRETURNする
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
END
.ret = err_no_error
sys_force_cmode = FALSE
flg_slave_paral = FALSE
RETURN
ELSE
;スレーブロボット動作のみRETURNする
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
END
.ret = err_no_error
RETURN
END
ANY :
PRINT "TASKNO=",TASKNO,", 作業実行に失敗しました .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
RETURN
END
END
;第2階層条件起動用作業完了フラグON
IF TASKNO==pg_master THEN
data_l2status[.l2num] = TRUE
END
;作業継続用情報初期化(マスター、スレーブ両方)
CALL updatel2l3info(FALSE,0,0,FALSE)
.END
.PROGRAM main()
;---------------------------------
;機能：動作プログラム(マスター)
;引数：無し
;戻値：無し
;-------------------------------- 
.ret = g_last_error
.$res = ""
IF TASKNO==pg_master THEN
IF debug.prt.main==ON THEN
PRINT "main()-> Booted main program. This program working in ROBOT-MASTER."
END
ELSE
PRINT "main()-> Booted main program in BAD-TASK. TASKNO=",TASKNO
RETURN
END
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
IF debug.prt.main==ON THEN
PRINT "main()-> Done main program. ROBOT_MODE=",robot_mode,",ROBOT_MODE_FLG=",robot_mode_flg
END
GOTO 10
END
CALL exec_alone(.ret)
;ダイレクトティーチモード強制解除
SAEND
SAENVCHKON
999
;初期化：共通処理
CALL chg_sp(100,.ret)
ACCURACY 0.1 ALWAYS
;初期化：ロボット別
flg_tablet_run[1] = TRUE
;スレーブロボット動作準備完了待ち
IF flg_tablet_run[2]==FALSE THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>wait_slave_time THEN
GOTO 10
END
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",WAITING... SLAVE-ROBOT still not booted.OPE_COMMAND=",ope_command
END
UNTIL (flg_tablet_run[2]==TRUE)
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 1"
END
ELSE
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 2"
END
END
sys_force_cmode = FALSE
flg_master_move = FALSE
flg_req_mamode = FALSE
flg_main_run = TRUE
flg_direct_run = FALSE
;コマンド実行指示待ち
DO
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
;プログラム終了後status_check関数が反応してエラー状態に遷移する
PRINT "main()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
GOTO 10
END
UNTIL (flg_master_move==TRUE)
;コマンド実行
IF flg_master_con==TRUE THEN
;マスター作業再開
IF debug.prt.main==ON THEN
PRINT "main()->OPE_COMMAND=",ope_command
PRINT "main()->マスター動作を再実行します。DATA_CUR_L2REC[ROBOT_MASTER]=",data_cur_l2rec[robot_master]
PRINT "main()->マスター動作を再実行します。DATA_CUR_L3REC[ROBOT_MASTER]=",data_cur_l3rec[robot_master]
END
.l2num = data_cur_l2rec[robot_master]
.l3num = data_cur_l3rec[robot_master]
IF .l2num==0 AND .l3num==0 THEN
IF debug.prt.main==ON THEN
PRINT "main()->.l2num and .l3num are Zero for MASTER ROBOT!."
END
flg_master_con = FALSE
GOTO 10
END
CALL l2exec(.l2num,.l3num,.ret)
IF .ret==err_no_error AND flg_single_move==FALSE THEN
data_execute = TRUE
IF debug.prt.main==ON THEN
PRINT "main()->START cmdexe() after RESTART-command."
END
;作業継続用情報初期化(マスター、スレーブ両方)
CALL updatel2l3info(FALSE,0,0,FALSE)
;引き続き作業を続行する
.$prm[0] = $ENCODE(cmd_exe_start)
.$prm[1] = "0"
.$prm[2] = "1"
.$prm[3] = "1234"
CALL cmdexecore(.$prm[],.ret)
END
ELSE
;通常コマンド実行
CALL cmdmain(ope_command,$ope_param[],.$res,.ret)
END
CALL update_error(.ret)
10
;終了処理
;完全初期化後のエラー回避
IF ope_command<>1999 THEN
;動作完了応答
IF cmd_wait_type[ope_command]==cmd_type_wait THEN
BREAK
CALL sendresp(ope_command,.$res,.ret)
END
END
;タブレットティーチモード中はプログラムを終了しない
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) THEN
GOTO 999
END
flg_main_run = FALSE
data_execute = FALSE
flg_master_move = FALSE
flg_tablet_run[1] = FALSE
.END
.PROGRAM mainexe()
;-------------------------------- 
;機能：作業実行メインEXE(マスター側実行専用)
;引数：なし
;戻値：なし
;--------------------------------
FOR .i = 1 TO data_l2num
data_l2status[.i] = FALSE
END
IF disable_l2chk==TRUE THEN
;順次実行
;FLG_SLAVE_MOVE = FALSE
FOR .l2num = 1 TO data_l2num
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
END
ELSE
;第2階層条件チェック実行
;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
WHILE (1) DO
DO
CALL l2check(.l2num,.ret)
UNTIL (.ret==TRUE)
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
END
END
.END
.PROGRAM monsp(.$prm[],.ret)
;-------------------------------- 
;機能：モニタ速度変更
;引数：速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.sp = VAL(.$prm[2])
IF .sp<=0 OR .sp>100 THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
data_monspeed[VAL(.$prm[1])] = .sp
IF VAL(.$prm[1])==robot_all THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,robot_master)),"->",.$prm[2],",.rno=",.$prm[1]
PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,robot_slave)),"->",.$prm[2],",.rno=",.$prm[1]
END
MC SPEED ROBOT_MASTER: .sp
MC SPEED ROBOT_SLAVE: .sp
CALL wait_chg_sp(robot_master,.sp,.ret)
CALL wait_chg_sp(robot_slave,.sp,.ret)
ELSE
IF debug.prt.cmd==TRUE THEN
IF .$prm[1]=="1" THEN
PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,robot_master)),"->",.$prm[2],",.rno=",.$prm[1]
ELSE
PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,robot_slave)),"->",.$prm[2],",.rno=",.$prm[1]
END
END
MC SPEED VAL(.$prm[1]): .sp
IF .$prm[1]=="1" THEN
CALL wait_chg_sp(robot_master,.sp,.ret)
ELSE
CALL wait_chg_sp(robot_slave,.sp,.ret)
END
END
.END
.PROGRAM movepos(.rno,.#tno,.mode,.type,.#inpos,.bflag,.sp,.ret)
;-------------------------------- 
;機能：指定位置移動
;引数：ロボット番号、ツール変換値、動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、教示点構成要素(.data実数配列)、動作後BREAK有無、第3階層指定速度(ティーチ時などは0)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;位置情報生成
DECOMPOSE .inpos[1] = .#inpos
DECOMPOSE .tno[1] = .#tno
IF .mode==mode_jt THEN
POINT .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
ELSE
POINT .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
.ext1 = .inpos[6]
g_ext1 = .ext1
END
IF debug.prt.move==TRUE THEN
PRINT "->movepos() .rno=",.rno," ,TASKNO=",TASKNO
END
ACCEL data_acc ALWAYS
DECEL data_dec ALWAYS
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
RETURN
END
;スレーブ制御用グローバル変数
gs_mode = .mode
gs_type = .type
gs_sp = .sp
IF .rno==0 THEN
;協調モードに移行
CALL change_ms_mode(slave_timeout,.ret)
IF .ret<>err_no_error THEN
GOTO 99
END
END
IF .type==mode_jmove THEN
IF .mode==mode_jt THEN
;JMOVE/JT
DECOMPOSE .d[1] = .#pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO 6
PRINT "->movepos() MODE_JMOVE JT[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
MLJMOVE .#pos
VALUE robot_master:
JMOVE .#pos
VALUE robot_slave:
IF TASKNO==pg_master THEN
gs_tool = .tno[robot_slave]
POINT #g_mpos = .#pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(JMOVE/MODE_JT)"
END
DO
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
JMOVE .#pos
END
END
ELSE
;JMOVE/XYZR1EXT1
DECOMPOSE .d[1] = .pos
.d[6] = .ext1
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO 6
PRINT "->movepos() MODE_JMOVE XYZR1EXT1[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
IF data_toolcur[.rno]<>.tno[robot_master] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_master,.tno[robot_master]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,1)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,1)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,1))
END
ZL3LINKX 1: .toolprm[1]
ZL3LINKX2 1: .toolprm[2]
ZL3LINKH1 1: .toolprm[3]
data_toolcur[.rno] = .tno[robot_master]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
END
DECOMPOSE .p[1] = .pos
.p[6] = .ext1
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
MLJMOVE .#tpos
VALUE robot_master:
IF data_toolcur[.rno]<>.tno[robot_master] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_master,.tno[robot_master]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
ZL3LINKX 1: .toolprm[1]
ZL3LINKX2 1: .toolprm[2]
ZL3LINKH1 1: .toolprm[3]
data_toolcur[.rno] = .tno[robot_master]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
END
DECOMPOSE .p[1] = .pos
.p[6] = .ext1
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
JMOVE .#tpos;変換値指定はできない
VALUE robot_slave:
IF TASKNO==pg_master THEN
gs_tool = .tno[robot_slave]
POINT g_mpos = .pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(JMOVE/NOT MODE_JT)"
END
DO
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
IF data_toolcur[.rno]<>.tno[robot_slave] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_slave,.tno[robot_slave]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,robot_slave)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_slave)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_slave))
END
ZL3LINKX 2: .toolprm[1]
ZL3LINKX2 2: .toolprm[2]
ZL3LINKH1 2: .toolprm[3]
data_toolcur[.rno] = .tno[robot_slave]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_slave)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_slave)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_slave))
END
END
DECOMPOSE .p[1] = .pos
.p[6] = .ext1
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
JMOVE .#tpos;変換値指定はできない
END
END
END
ELSE
IF .mode==mode_jt THEN
;LMOVE/JT
DECOMPOSE .d[1] = .#pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO 6
PRINT "->movepos() MODE_LMOVE JT[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
MLZL3LMOVE .#pos,1,1
VALUE robot_master:
ZL3LMOVE .#pos,1,1;引数は各軸値
VALUE robot_slave:
IF TASKNO==pg_master THEN
gs_tool = .tno[robot_slave]
POINT #g_mpos = .#pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(LMOVE/MODE_JT)"
END
DO
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
ZL3LMOVE .#pos,1,1;引数は各軸値
END
END
ELSE
;LMOVE/XYZR1EXT1
DECOMPOSE .d[1] = .pos
.d[6] = .ext1
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO 6
PRINT "->movepos() MODE_LMOVE XYZR1EXT1[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
IF data_toolcur[.rno]<>.tno[robot_master] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_master,.tno[robot_master]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,1)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,1)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,1))
END
ZL3LINKX 1: .toolprm[1]
ZL3LINKX2 1: .toolprm[2]
ZL3LINKH1 1: .toolprm[3]
data_toolcur[.rno] = .tno[robot_master]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
END
DECOMPOSE .p[1] = .pos
.p[6] = .ext1
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
MLZL3LMOVE .#tpos,1,1
VALUE robot_master:
IF data_toolcur[.rno]<>.tno[robot_master] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_master,.tno[robot_master]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
ZL3LINKX 1: .toolprm[1]
ZL3LINKX2 1: .toolprm[2]
ZL3LINKH1 1: .toolprm[3]
data_toolcur[.rno] = .tno[robot_master]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_master)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_master)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_master))
END
END
DECOMPOSE .p[1] = .pos
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
ZL3LMOVE .#tpos,1,1;引数は各軸値
VALUE robot_slave:
IF TASKNO==pg_master THEN
gs_tool = .tno[robot_slave]
POINT g_mpos = .pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(LMOVE/NOT MODE_JT)"
END
DO
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
IF data_toolcur[.rno]<>.tno[robot_slave] THEN
DECOMPOSE .toolprm[1] = def_tool[robot_slave,.tno[robot_slave]]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.move==TRUE THEN
PRINT "->movepos() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",.tno[1]
PRINT "->movepos() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,robot_slave)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_slave)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_slave))
END
ZL3LINKX 2: .toolprm[1]
ZL3LINKX2 2: .toolprm[2]
ZL3LINKH1 2: .toolprm[3]
data_toolcur[.rno] = .tno[robot_slave]
IF debug.prt.move==TRUE THEN
PRINT "->movepos() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,robot_slave)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,robot_slave)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,robot_slave))
END
END
DECOMPOSE .p[1] = .pos
.p[6] = .ext1
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
ZL3LMOVE .#tpos,1,1;引数は各軸値
END
END
END
END
IF .bflag==TRUE THEN
BREAK
END
99
IF TASKNO==pg_master THEN
;終了処理
flg_req_mamode = FALSE
CALL exec_alone(.ret)
END
BREAK
.END
.PROGRAM nameset(.cmd,.$prm[],.ret)
;-------------------------------- 
;機能：名称設定コア
;引数：文字列配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CASE .cmd OF
VALUE cmd_set_l1info:
$data_cur_l1name = .$prm[2]
data_l2num = VAL(.$prm[3])
VALUE cmd_set_l2info:
$data_l2name[VAL(.$prm[2])] = .$prm[3]
data_l3num[VAL(.$prm[2])] = VAL(.$prm[4])
data_l2exetblnu[VAL(.$prm[2])] = VAL(.$prm[5])
VALUE cmd_set_l3info:
$data_l3name[VAL(.$prm[2]),VAL(.$prm[3])] = .$prm[4]
ANY :
.ret = err_bad_name
END
.END
.PROGRAM noexist_init()
NOEXIST_SET_R debug.prt.sock = -1
NOEXIST_SET_R debug.prt.proc = -1
NOEXIST_SET_R debug.prt.act = -1
NOEXIST_SET_R debug.prt.cmd = -1
NOEXIST_SET_R debug.prt.core = -1
NOEXIST_SET_R debug.prt.main = -1
NOEXIST_SET_R debug.prt.sub = -1
NOEXIST_SET_R debug.prt.gen = -1
NOEXIST_SET_R debug.prt.com = -1
NOEXIST_SET_R debug.prt.func = -1
NOEXIST_SET_R debug.prt.visio = -1
NOEXIST_SET_R debug.prt.reboo = -1
NOEXIST_SET_R debug.prt.extio = -1
NOEXIST_SET_R debug.prt.pos = 0
NOEXIST_SET_R debug.prt.move = -1
NOEXIST_SET_R debug.prt.l2exe = -1
NOEXIST_SET_R flg_start_reboo = 0
NOEXIST_SET_R flg_main_run = 0
NOEXIST_SET_R flg_direct_run = 0
NOEXIST_SET_R flg_master_move = 0
NOEXIST_SET_R flg_slave_move = 0
NOEXIST_SET_R flg_req_mamode = 0
NOEXIST_SET_R flg_slave_rdy = 0
NOEXIST_SET_R flg_slave_paral = 0
NOEXIST_SET_R g_last_error = 0
NOEXIST_SET_R extin_start_but = 0
NOEXIST_SET_R extin_stop_butt = 0
NOEXIST_SET_R extin_teach_tgl = 0
NOEXIST_SET_R extin_repeat_tg = 0
NOEXIST_SET_R flg_gravityadj_ = 0
NOEXIST_SET_R flg_enable_colc = 0
NOEXIST_SET_R poslimit_gen = 1
NOEXIST_SET_R poslimit_restar = 5
NOEXIST_SET_R slowlimit_time = 5
NOEXIST_SET_R slowlimit_speed = 100
NOEXIST_SET_R data_teachpitch = 5
NOEXIST_SET_R data_teachrot = 5
NOEXIST_SET_R data_exttype[0] = 0
NOEXIST_SET_R data_exttype[1] = 0
NOEXIST_SET_R data_exttype[2] = 0
NOEXIST_SET_R data_teachcoord = 0
NOEXIST_SET_R data_toolcur[1] = 1
NOEXIST_SET_R data_toolcur[2] = 1
NOEXIST_SET_R data_acc = 100
NOEXIST_SET_R data_dec = 100
NOEXIST_SET_R data_io_tablenu = 0
NOEXIST_SET_R data_monspeed[0] = 100
NOEXIST_SET_R data_monspeed[1] = 100
NOEXIST_SET_R data_monspeed[2] = 100
NOEXIST_SET_R data_execute = 0
NOEXIST_SET_R data_cur_l2disp = 0
NOEXIST_SET_R data_cur_l3disp = 0
NOEXIST_SET_R data_cur_l2rec[1] = 0
NOEXIST_SET_R data_cur_l2rec[2] = 0
NOEXIST_SET_R data_cur_l3rec[1] = 0
NOEXIST_SET_R data_cur_l3rec[2] = 0
NOEXIST_SET_R data_l2num = 0
NOEXIST_SET_S $data_pgname = "MAINEXE"
NOEXIST_SET_S $data_cur_l1name = "NO SETTING"
NOEXIST_SET_R ope_command = 1999
NOEXIST_SET_R ope_commandpc = 1999
NOEXIST_SET_R ope_param[1] = 0
NOEXIST_SET_R ope_param[2] = 0
NOEXIST_SET_R ope_param[3] = 0
NOEXIST_SET_R ope_param[4] = 0
NOEXIST_SET_R ope_param[5] = 0
NOEXIST_SET_R ope_param[6] = 0
NOEXIST_SET_R ope_param[7] = 0
NOEXIST_SET_R ope_param[8] = 0
NOEXIST_SET_R ope_param[9] = 0
NOEXIST_SET_R ope_param[10] = 0
NOEXIST_SET_R ope_param[11] = 0
NOEXIST_SET_R ope_param[12] = 0
NOEXIST_SET_R ope_param[13] = 0
NOEXIST_SET_R ope_param[14] = 0
NOEXIST_SET_R ope_param[15] = 0
NOEXIST_SET_R ope_param[16] = 0
NOEXIST_SET_R ope_param[17] = 0
NOEXIST_SET_R ope_param[18] = 0
NOEXIST_SET_R ope_param[19] = 0
NOEXIST_SET_R ope_param[20] = 0
NOEXIST_SET_R mfp_param1 = 0
NOEXIST_SET_R mfp_param2 = 0
NOEXIST_SET_R mfp_param3 = 0
NOEXIST_SET_R mfp_param4 = 0
NOEXIST_SET_R mfp_param5 = 0
NOEXIST_SET_R mfp_param6 = 0
NOEXIST_SET_R mfp_param7 = 0
NOEXIST_SET_R mfp_param8 = 0
NOEXIST_SET_R mfp_param9 = 0
NOEXIST_SET_R mfp_param10 = 0
NOEXIST_SET_R mfp_param11 = 0
NOEXIST_SET_R mfp_param12 = 0
NOEXIST_SET_R mfp_param13 = 0
NOEXIST_SET_R mfp_param14 = 0
NOEXIST_SET_R mfp_param15 = 0
NOEXIST_SET_R mfp_param16 = 0
NOEXIST_SET_R mfp_param17 = 0
NOEXIST_SET_R mfp_param18 = 0
NOEXIST_SET_R mfp_param19 = 0
NOEXIST_SET_R mfp_param20 = 0
NOEXIST_SET_R tool_data_num[1] = 999
NOEXIST_SET_R tool_data_num[2] = 999
NOEXIST_SET_R robot_hacc[1,1] = 10
NOEXIST_SET_R robot_hacc[1,2] = 10
NOEXIST_SET_R robot_hacc[2,1] = 10
NOEXIST_SET_R robot_hacc[2,2] = 10
NOEXIST_SET_R data_hand_io[1,1] = 49
NOEXIST_SET_R data_hand_io[1,2] = 50
NOEXIST_SET_R data_hand_io[1,3] = 0
NOEXIST_SET_R data_hand_io[1,4] = 0
NOEXIST_SET_R data_hand_io[2,1] = 65
NOEXIST_SET_R data_hand_io[2,2] = 66
NOEXIST_SET_R data_hand_io[2,3] = 0
NOEXIST_SET_R data_hand_io[2,4] = 0
NOEXIST_SET_R data_hand_type[1] = 1
NOEXIST_SET_R data_hand_type[2] = 1
NOEXIST_SET_R data_hand_cur[1] = 0
NOEXIST_SET_R data_hand_cur[2] = 0
NOEXIST_SET_R data_vs_tbnum = 3
NOEXIST_SET_L def_tool[1,1] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L def_tool[1,2] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L def_tool[2,1] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_L def_tool[2,2] = TRANS(360,400,0,0,0,0)
NOEXIST_SET_R ix_cycle_time = 2001
.END
.PROGRAM oat2rpy(.#xyzoat,.#xyzrpy)
;-------------------------------- 
;機能：座標変換(OAT->RPY)
;引数：OAT
;戻値：RPY
;-------------------------------- 
;外部軸
;.xyzrpy[7]=.xyzoat[7]
DECOMPOSE .xyzoat[1] = .#xyzoat
;XYZOAT
.so = SIN(.xyzoat[4]+90)
.co = COS(.xyzoat[4]+90)
.sa = SIN(.xyzoat[5]-90)
.ca = COS(.xyzoat[5]-90)
.st = SIN(.xyzoat[6])
.ct = COS(.xyzoat[6])
.mat[0,0] = .co*.st-.sa*.ct*.so
.mat[1,0] = .so*.st+.sa*.ct*.co
.mat[2,0] = -.ca*.ct
.mat[3,0] = 0e+00
.mat[0,1] = .co*.ct+.sa*.st*.so
.mat[1,1] = .so*.ct-.sa*.st*.co
.mat[2,1] = .ca*.st
.mat[3,1] = 0e+00
.mat[0,2] = .ca*.so
.mat[1,2] = -.ca*.co
.mat[2,2] = -.sa
.mat[3,2] = 0e+00
.mat[0,3] = .xyzoat[1]
.mat[1,3] = .xyzoat[2]
.mat[2,3] = .xyzoat[3]
.mat[3,3] = 1
;XYZRPY
.xyzrpy[1] = .mat[0,3]
.xyzrpy[2] = .mat[1,3]
.xyzrpy[3] = .mat[2,3]
IF ABS(.mat[0,2])<1e-06 THEN
.xyzrpy[5] = 0e+00
.xyzrpy[4] = ATAN2(-.mat[1,2],.mat[2,2])
.xyzrpy[6] = ATAN2(-.mat[0,1],.mat[0,0])
IF ABS(.xyzrpy[6])<1e-06 THEN
.xyzrpy[6] = 0e+00
END
ELSE
.p = SQRT(.mat[0,0]*.mat[0,0]+.mat[0,1]*.mat[0,1])
IF ABS(.p)<1e-06 THEN
IF (.mat[0,2]>0e+00) THEN
.xyzrpy[5] = 90
ELSE
.xyzrpy[5] = -90
END
.xyzrpy[4] = 0e+00
.xyzrpy[6] = ATAN2(.mat[1,0],.mat[1,1])
ELSE
.xyzrpy[4] = ATAN2(-.mat[1,2],.mat[2,2])
.xyzrpy[5] = ATAN2(.mat[0,2],.p)
.xyzrpy[6] = ATAN2(-.mat[0,1],.mat[0,0])
END
END
POINT .#xyzrpy = #PPOINT(.xyzrpy[1],.xyzrpy[2],xyzrpy[3],.xyzrpy[4],.xyzrpy[5],.xyzrpy[6])
.END
.PROGRAM pc3_handshake(.sig_no)
; FUNCTION: ハンドシェイク待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
WHILE SIG(-.sig_no) DO
TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
END
SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc3_sig_change(.res,.sig_no,.timeout)
; FUNCTION: タイムアウト付き信号状態変更待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(.sig_no) GOTO end
TWAIT ascycle;                           信号の状態変更待ち
UNTIL UTIMER(.@vtime)>=.timeout;           タイムアウトするまで
.res = -1
end:
.END
.PROGRAM pc3_vcom_error(.err,.$res)
; FUNCTION: エラーコード＆内容セット[PC3]
; NOTE    : ver1.0.0[14/02/24]
v.com_err = .err
$vcom_res = .$res
PRINT /X2,$vcom_res," in pc3_vcom_send : ",v.com_err;エラー内容表示
CALL pc3_vcom_log(1,.$res);                ログ保存
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc3_vcom_log(.class,.$string)
; FUNCTION: ログ作成[PC3]
; NOTE    : ver1.0.0[14/02/24]
IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
.$log = $DATE(3)+" "+$TIME+" [pc3_vcom_send] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
$vlog[1,vlog_cnt[1]] = .$log;            ログデータ保存
vlog_cnt[1] = vlog_cnt[1]+1;             ログカウンタカウントアップ
IF vlog_cnt[1]>vlog_max THEN;            ログカウンタ上限超えの為リセット
vlog_cnt[1] = 1
END
END
.END
.PROGRAM pc3_vcom_send()
; FUNCTION: UDP/IP通信 送信[PC3]
; NOTE    : ver1.0.0[14/03/06]
v.com_err = verr_init;                     通信結果クリア(変数定義用)
$vcom_res = "";                            エラー内容クリア(変数定義用)
SIGNAL -ix_vcomm_comp,-ix_vcomm_error;     通信完了信号＆通信エラー信号ＯＦＦ
SIGNAL -ix_vcomm_start,-ix_vcomm_busy;     通信開始信号＆通信中信号ＯＦＦ
CALL pc3_vcom_log(0,"送信ＰＧ起動")
SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
CALL pc3_vcom_log(0,"通信開始信号待ち...")
CALL pc3_handshake(ix_vcomm_start);        通信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
IF SIG(ix_vsend_only) AND SIG(ix_vrecv_only) THEN
CALL pc3_vcom_error(verr_onlymode,"片方向通信モードエラー");片方向通信モードエラー
HALT;                                    停止(片方向通信モードエラー)
END
CALL pc3_vcom_log(0,"通信開始")
SIGNAL ix_vcomm_busy;                      通信中信号ＯＮ
IF SIG(ix_vsend_only) GOTO start;          送信のみ信号ＯＮ時は受信ＰＧ起動確認なし
CALL pc3_vcom_log(0,"受信ＰＧ起動確認")
IF TASK(1004)<>1 THEN;                     受信ＰＧ起動確認
CALL pc3_vcom_log(0,"受信ＰＧ起動実行")
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 4: pc4_vcom_recv;              受信ＰＧ起動
CALL pc3_vcom_log(0,"受信ＰＧ起動完了待ち...")
CALL vchk_pc_start(.chk,1004);           受信ＰＧ[PC4]起動確認
IF .chk!=0 THEN
CALL pc3_vcom_error(verr_timeout3,"受信ＰＧ起動待ちタイムアウトエラー");受信ＰＧ待ちタイムアウトエラー
HALT;                                  停止(受信ＰＧ起動待ちタイムアウトエラー)
END
END
CALL pc3_vcom_log(0,"受信ＰＧ起動確認完了")
start:; 送受信開始
v.com_err = verr_init;                     通信結果クリア
$vcom_res = "";                            エラー内容クリア
IF SIG(ix_vsend_only) GOTO send;           送信のみ信号ＯＮ時は受信ＰＧ起動なし
SIGNAL -ix_vrecv_comp,ix_vrecv_start;      受信完了信号ＯＦＦ＆受信開始信号ＯＮ
CALL pc3_vcom_log(0,"受信開始待ち...")
CALL pc3_sig_change(.chk,-ix_vrecv_start,vhandshake_time);受信開始信号ＯＦＦ待ち
IF .chk!=0 THEN
CALL pc3_vcom_error(verr_timeout1,"受信開始待ちタイムアウトエラー");受信開始待ちタイムアウトエラー
HALT;                                    停止(受信開始待ちタイムアウトエラー)
END
IF SIG(ix_vrecv_only) GOTO recv;           受信のみ信号ＯＮ時は送信なし
send:; 送信
CALL pc3_vcom_log(0,"送信開始")
UDP_SENDTO .vstatus_send,vsend_ip[0],vsend_port,$vsend_data[0],vsend_num,vsend_timeout
IF .vstatus_send<>0 THEN;                  送信ステータス確認
.$log = "送信エラー : "+$ENCODE(/I6,.vstatus_send)
CALL pc3_vcom_error(verr_send,.$log);    送信エラー
HALT;                                    停止(送信エラー)
ELSE
.$log = "送信完了 ["+$ENCODE(/I2,vsend_num)+"] -> "+$vsend_data[0]
CALL pc3_vcom_log(0,.$log)
END
IF SIG(ix_vsend_only) GOTO end;            送信のみ信号ＯＮ時は受信完了待ちなし
recv:; 受信
CALL pc3_vcom_log(0,"受信完了待ち...")
CALL pc3_sig_change(.chk,ix_vrecv_comp,vrecv_timeout+0.2);受信完了信号ＯＮ待ち
IF .chk!=0 THEN
IF v.com_err==verr_init THEN
CALL pc3_vcom_error(verr_timeout2,"受信完了待ちタイムアウトエラー");受信完了待ちタイムアウトエラー
END
HALT;                                    停止(受信完了待ちタイムアウトエラー)
END
end:; 通信完了処理
CALL pc3_vcom_log(0,"通信完了")
v.com_err = verr_ok
SIGNAL -ix_vcomm_busy,ix_vcomm_comp;       通信中信号ＯＦＦ＆通信完了信号ＯＮ
GOTO loop
.END
.PROGRAM pc4_handshake(.sig_no)
; FUNCTION: ハンドシェイク待ち[PC4]
; NOTE    : ver1.0.0[12/10/18]
WHILE SIG(-.sig_no) DO
TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
END
SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc4_vcom_error(.err,.$res)
; FUNCTION: エラーコード＆内容セット[PC4]
; NOTE    : ver1.0.0[14/02/24]
v.com_err = .err
$vcom_res = .$res
PRINT /X2,$vcom_res," in pc4_vcom_recv : ",v.com_err;エラー内容表示
CALL pc4_vcom_log(1,.$res);                ログ保存
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc4_vcom_log(.class,.$string)
; FUNCTION: ログ作成[PC4]
; NOTE    : ver1.0.0[14/02/24]
IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
.$log = $DATE(3)+" "+$TIME+" [pc4_vcom_recv] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
$vlog[2,vlog_cnt[2]] = .$log;            ログデータ保存
vlog_cnt[2] = vlog_cnt[2]+1;             ログカウンタカウントアップ
IF vlog_cnt[2]>vlog_max THEN;            ログカウンタ上限超えの為リセット
vlog_cnt[2] = 1
END
END
.END
.PROGRAM pc4_vcom_recv()
; FUNCTION: UDP/IP通信 受信[PC4]
; NOTE    : ver1.0.0[14/02/24]
SIGNAL -ix_vrecv_start,-ix_vrecv_comp;     受信開始信号＆受信完了信号ＯＦＦ
CALL pc4_vcom_log(0,"受信ＰＧ起動")
SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
CALL pc4_handshake(ix_vrecv_start);        受信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
CALL pc4_vcom_log(0,"受信開始")
UDP_RECVFROM .vstatus_recv,vrecv_port,$vrecv_data[0],vrecv_num,vrecv_timeout,vrecv_ip[0],vrecv_str_num
IF .vstatus_recv<>0 THEN;                  受信ステータス確認
IF v.com_err==verr_init THEN
.$log = "受信エラー : "+$ENCODE(/I6,.vstatus_recv)
CALL pc4_vcom_error(verr_recv,.$log);  受信エラー
END
HALT;                                    停止(受信エラー)
ELSE
.$log = "受信完了 ["+$ENCODE(/I2,vrecv_num)+"] <- "+$vrecv_data[0]
CALL pc4_vcom_log(0,.$log)
END
SIGNAL ix_vrecv_comp;                      受信完了信号ＯＮ
GOTO loop
.END
.PROGRAM pccom()
;-------------------------------- 
;機能：通信制御(動作プログラム実行用)
;-------------------------------- 
IF mode_ctype==mode_tcp THEN
;TCPポート接続、再接続
CALL tcp_open(0,.ret)
END
;外部制御盤からの操作機能を追加するが、通信バッファ溜まり防止のため通信ループは常時回す
CALL getcmd(.$prm[],.num,.ret)
IF .ret==0 THEN
IF SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
;タブレット操作許可、ボタン操作禁止
CALL pccomcore(FALSE,.$prm[],.num,.ret)
ELSE
;タブレット操作禁止、ボタン操作許可
;外部制御盤操作中エラー応答
.ret = err_extio_disab
CALL sendresp(VAL(.$prm[0]),"",.ret)
END
ELSE
;タブレット操作禁止、ボタン操作許可
;通信処理乗っ取りコマンド実行
CALL chk_extin(.status,.$prm[],.num)
IF .status==TRUE THEN
;入力検知
IF (VAL(.$prm[0])<>cmd_exe_reset) AND (g_last_error<>err_no_error) THEN
;エラー発生中はエラーリセットしか受け付けない
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccom:extin()-> Cannot execute command=",VAL(.$prm[0]),",G_LAST_ERROR=",g_last_error
END
GOTO 10
END
;コマンド種類(動作、非動作)に併せた実行方法が必要
CASE VAL(.$prm[0]) OF
VALUE cmd_exe_start,cmd_exe_reset,cmd_exe_gen:
IF (flg_master_move==TRUE OR flg_slave_move==TRUE) THEN
IF debug.prt.com==TRUE THEN
PRINT "pccom()-> Can not execute command,Because still moving any robot."
END
GOTO 10
END
;動作系コマンドのためPCCOMのように動作プログラム(main関数)経由で実行する
CALL pccomcore(TRUE,.$prm[],.num,.ret)
VALUE cmd_exe_restart:
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
CALL exec_pg(.ret)
IF .ret==err_no_error THEN
;コマンド実行
CALL cmdmain(cmd_exe_restart,.$prm[],.$res,.ret)
END
VALUE cmd_exe_abort:
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
CALL cmdabort(.$prm[],.ret)
VALUE cmd_exe_robotmo:
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) THEN
;操作禁止
ELSE
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
CALL cmdchgrobotmode(.$prm[],.ret)
END
ANY :
IF debug.prt.com==TRUE THEN
PRINT "pccom()-> Not Support command for extin_ctl()"
END
END
END
END
10
;再起動プログラムが停止している場合に自動再起動する
IF (TASK(1001)<>1) THEN
PCEXECUTE rebootsystem
PRINT ".......Restart rebootsystem() in task 1001(PC-PROGRAM no.1)"
END
.END
.PROGRAM pccomcore(.flg_force,.$prm[],.num,.ret)
;-------------------------------- 
;機能：通信制御(動作プログラム実行用、コマンド受信後の処理)
;-------------------------------- 
;コマンド受信有り
.$res = ""
;コマンドを取得する
FOR .i = 1 TO .num
$ope_param[.i] = .$prm[.i]
END
;エラー発生中はエラーリセットコマンド以外はエラー応答する
IF (VAL(.$prm[0])<>cmd_exe_reset) AND (g_last_error<>err_no_error) THEN
.ret = g_last_error
CALL sendresp(VAL(.$prm[0]),"",.ret)
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccomcore()-> Cannot execute command=",VAL(.$prm[0]),",G_LAST_ERROR=",g_last_error
END
GOTO 10
END
;リセット操作を受付ける(タブレットがポート変更するまでの暫定)
;ロボット動作中にOPE_COMMANDを更新するとエラーになるため受信文字列で判定する
IF VAL(.$prm[0])==cmd_exe_reset AND flg_start_reboo==FALSE THEN
IF flg_master_move==FALSE AND flg_slave_move==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Start execute reset-command."
END
IF (g_last_error==err_bad_positio) AND (disable_readj_p==TRUE) THEN
flg_enable_stop = FALSE
END
;status_check()でエラーを起こさないようにする
CALL rdyboot(TRUE,.ret)
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Can not start execute reset-command,because robot is busy."
END
.ret = err_robot_busy
END
CALL sendresp(VAL(.$prm[0]),"",.ret)
GOTO 10
END
;コマンド実行可能条件が未成立はエラー応答する
CALL check_exec_cmd(VAL(.$prm[0]),.flg_exec_cmd)
IF .flg_exec_cmd==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Result of judgement by check_exec_cmd() is not authorizing."
END
.ret = err_robotmode
CALL sendresp(VAL(.$prm[0]),"",.ret)
GOTO 10
END
;OPE_COMMAND更新タイミング注意
ope_command = VAL(.$prm[0])
;ダイレクトティーチ中はエラー応答する
IF (robot_mode==mode_direct) THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() CAN NOT ACCEPT COMMAND.BECAUSE ROBOT-MODE IS DIRECT-TEACH-MODE."
END
.ret = err_direct_teac
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;動作命令系コマンドのみ実行する
IF .flg_force==FALSE THEN
IF cmd_exec_type[ope_command]==cmd_type_pcpg THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
END
GOTO 10
END
END
;プログラム実行要否判定後に自動的にプログラムを実行する
CALL exec_pg(.ret)
IF .ret<>err_no_error THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Can not execute program(exec_pg(.ret))."
END
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;動作プログラム(main関数)未実行状態中はエラー応答する
IF flg_main_run==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Not ready for main-program(FLG_MAIN_RUN==FALSE)."
END
.ret = err_main_stop
CALL sendresp(ope_command,"",.ret)
END
;コマンド実行中はエラー応答する
IF flg_master_move==TRUE THEN
;動作中エラー応答
.ret = err_robot_busy
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;動作プログラム起動中はエラー応答する
IF flg_start_reboo==TRUE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() REBOOTING...."
END
.ret = err_robot_busy
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;コマンドを実行する
flg_master_move = TRUE
;コマンド種別が終了確認タイプで無ければ実行完了応答する
IF cmd_wait_type[ope_command]==cmd_type_no_wai THEN
.ret = err_no_error
CALL sendresp(ope_command,"",.ret)
END
10
.END
.PROGRAM pccompc()
;-------------------------------- 
;機能：通信制御(非動作プログラム実行用)
;-------------------------------- 
IF mode_ctype==mode_tcp THEN
;TCPポート接続、再接続
CALL tcp_open(0,.ret)
END
CALL getcmd(.$prm[],.num,.ret)
IF .ret==0 THEN
;コマンド受信有り
.$res = ""
;コマンドを取得する
FOR .i = 1 TO .num
$ope_parampc[.i] = .$prm[.i]
END
CALL check_exec_cmd(VAL(.$prm[0]),.flg_exec_cmd)
IF .flg_exec_cmd==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccompc() Result of judgement by check_exec_cmd() is not authorizing."
END
.ret = err_robotmode
CALL sendresp(VAL(.$prm[0]),"",.ret)
GOTO 10
END
IF (robot_mode==mode_direct) AND (VAL(.$prm[0])==cmd_exe_restart) THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccompc() CAN NOT ACCEPT COMMAND.BECAUSE ROBOT-MODE IS DIRECT-TEACH-MODE."
END
.ret = err_robotmode
CALL sendresp(VAL(.$prm[0]),"",.ret)
GOTO 10
END
IF (SIG(extin_teach_tgl)==OFF) AND (SIG(extin_repeat_tg)==ON) AND ((VAL(.$prm[0])==cmd_exe_restart) OR (VAL(.$prm[0])==cmd_exe_robotmo)) THEN
IF debug.prt.com==TRUE THEN
PRINT "pccompc()-> (SIG(EXTIN_TEACH_TGLSW)==OFF) AND (SIG(EXTIN_REPEAT_TGLSW)==ON) AND ((VAL(.$prm[0])==CMD_EXE_RESTART) OR (VAL(.$prm[0])==CMD_EXE_ROBOTMODE))"
END
.ret = err_robotmode
CALL sendresp(VAL(.$prm[0]),"",.ret)
GOTO 10
END
ope_commandpc = VAL(.$prm[0])
;非動作命令系のみ実行する
IF cmd_exec_type[ope_commandpc]==cmd_type_monpg THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccompc() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
END
GOTO 10
END
;プログラムを実行要否判定後に自動的にプログラムを実行する
IF (ope_commandpc==cmd_exe_restart) OR (ope_commandpc==cmd_exe_robotmo) THEN
IF g_last_error<>err_no_error THEN
.ret = g_last_error
CALL sendresp(VAL(.$prm[0]),"",.ret)
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccompc()-> Cannot execute command=",ope_commandpc,",G_LAST_ERROR=",g_last_error
END
GOTO 10
ELSE
IF ope_commandpc==cmd_exe_restart THEN
CALL exec_pg(.ret)
IF .ret<>err_no_error THEN
CALL sendresp(ope_commandpc,"",.ret)
GOTO 10
END
END
END
END
;コマンド実行
CALL cmdmain(ope_commandpc,$ope_parampc[],.$res,.ret)
CALL sendresp(ope_commandpc,.$res,.ret)
END
10
.END
.PROGRAM rdyboot(.flg_motor,.ret)
;-------------------------------- 
;動作プログラム実行(再起動)準備、モータ停止状態遷移
;引数：準備にモータ電源ON処理含む(TRUE/FALSE)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;エラー状態を一旦解除する
g_last_error = err_no_error
IF SIG(sig_emg_output)==ON THEN
PRINT "->RdyBoot() Need to clear EMG-STOP button."
.ret = err_emg_on
CALL update_error(.ret)
RETURN
END
;状態監視プログラム(status_check関数)でエラーが発生しないようにフラグ変更
CALL chk_robot_stop_
IF SWITCH(REPEAT ,1)==OFF OR SWITCH(REPEAT ,2)==OFF THEN
PRINT "->RdyBoot() Need to change repeat mode."
.ret = err_repeat
CALL update_error(.ret)
RETURN
END
IF SWITCH(TEACH_LOCK ,1)==ON OR SWITCH(TEACH_LOCK ,2)==ON THEN
PRINT "->RdyBoot() Need to unlock teach-lock button."
.ret = err_teach_lock
CALL update_error(.ret)
RETURN
END
CALL exec_alone(.ret)
IF .ret<>err_no_error THEN
PRINT "RdyBoot()-> Error ocured,When called exec_alone(.ret)-function"
RETURN
END
UTIMER .@nowtime = 0
DO
MC HOLD 
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT stop main program."
.ret = err_main_stop
CALL update_error(.ret)
RETURN
END
UNTIL ((SWITCH(CS ,1)==OFF) AND ((TASK(1)==0) OR (TASK(1)==2)))
IF debug.prt.core==TRUE THEN
PRINT "->RdyBoot() Kill pg for Robot 1:."
END
MC KILL 
UTIMER .@nowtime = 0
DO
MC HOLD 2:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT stop main program."
.ret = err_main_stop
CALL update_error(.ret)
RETURN
END
UNTIL ((SWITCH(CS ,2)==OFF) AND ((TASK(2)==0) OR (TASK(2)==2)))
IF debug.prt.core==TRUE THEN
PRINT "->RdyBoot() Kill pg for Robot 2:."
END
MC KILL 2: 
;エラーOFF 
UTIMER .@nowtime = 0
DO
MC ERESET 1:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT error reset."
.ret = err_errreset
CALL update_error(.ret)
RETURN
END
UNTIL (SWITCH(ERROR ,1)==OFF)
IF .flg_motor==TRUE THEN
UTIMER .@nowtime = 0
DO
MC ZPOW 1: ON 
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT motor-on."
.ret = err_poweron
CALL update_error(.ret)
RETURN
END
UNTIL (SWITCH(POWER ,1)==ON)
END
UTIMER .@nowtime = 0
DO
MC ERESET 2:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT error reset."
.ret = err_errreset
CALL update_error(.ret)
RETURN
END
UNTIL (SWITCH(ERROR ,2)==OFF)
IF .flg_motor==TRUE THEN
UTIMER .@nowtime = 0
DO
MC ZPOW 2: ON 
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT motor-on."
.ret = err_poweron
CALL update_error(.ret)
RETURN
END
UNTIL (SWITCH(POWER ,2)==ON)
END
COLRON 1: 
COLRJON 1: 
COLRON 2: 
COLRJON 2: 
.END
.PROGRAM rebootsystem()
;-------------------------------- 
;機能：再起動管理、エラーチェック用常時起動プログラム
;引数：無し
;戻値：無し
;-------------------------------- 
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
flg_tglsw_repea = TRUE
ELSE
flg_tglsw_repea = FALSE
END
flg_cycle_time = FALSE
IF kroset==TRUE THEN
SIGNAL -ix_cycle_time
END
WHILE (TRUE) DO
IF flg_start_reboo==TRUE THEN
CALL resetsystem
END
IF flg_start_killp==FALSE THEN
IF TASK(1005)<>1 OR TASK(1006)<>1 THEN
IF debug.prt.reboo==TRUE THEN
PRINT "rebootsystem()->.......TASK(1005)<>1 OR TASK(1006)<>1"
END
flg_start_reboo = TRUE
END
END
IF flg_main_run==TRUE OR flg_direct_run==TRUE THEN
;ロボット状態監視
CALL status_check(.ret)
END
IF SIG(sig_ext_reboot)==TRUE THEN
CALL exec_pg(.ret)
END
;ランプ制御
CALL extout_ctl
;K-ROSET用(サイクルタイム計測)
IF kroset==TRUE THEN
CALL chk_cycle_time
END
END
.END
.PROGRAM recv(.$str,.ret)
;-------------------------------- 
;機能：UDP受信処理(動作プログラム用)
;引数：なし
;戻値：受信文字列、成否
;-------------------------------- 
.$str = ""
.$cmd[1] = ""
.ret = -1
.timeout = tcp_timeout
;受信先選択
CALL get_cominfo(type_recv,.nouse,.sid,nouse,.port)
IF (.sid==-1) OR ((TASKNO==1005) AND (tcp_reconnect_b[0]==TRUE)) OR ((TASKNO==1006) AND (tcp_reconnect_b[1]==TRUE)) THEN
IF (tcp_reconnect_b[0]==TRUE) OR (tcp_reconnect_b[1]==TRUE) THEN
PRINT "recv()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
END
RETURN
END
;受信処理開始
IF mode_ctype==mode_udp THEN
UDP_RECVFROM .ret,.port,.$cmd[1],.len,.timeout,ip[0],255
ELSE
IF .sid!=-1 THEN
TCP_RECV .ret,.sid,.$cmd[1],.num,.timeout,255
END
END
IF .ret==0 THEN
IF .$cmd[1]=="" THEN
.ret = -1
ELSE
.$str = .$cmd[1]
IF debug.prt.sock==TRUE THEN
CALL check_disp_sock(.$cmd[1],.flg_disp)
IF .flg_disp==TRUE THEN
PRINT "TASKNO=",TASKNO," recv()->.sid=",.sid," port=",.port,",.$cmd[1]=",.$cmd[1]
END
END
END
END
.END
.PROGRAM resetctrllinfo()
;-------------------------------- 
;制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
flg_main_run = FALSE
flg_tablet_run[1] = FALSE
flg_tablet_run[2] = FALSE
flg_direct_run = FALSE
flg_master_move = FALSE
flg_slave_move = FALSE
flg_req_mamode = FALSE
flg_slave_rdy = FALSE
flg_slave_paral = FALSE
tcp_reconnect_b[0] = FALSE
tcp_reconnect_b[1] = FALSE
flg_wait_end = FALSE
flg_gravityadj_ = FALSE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL -extout_start_bu,-extout_stop_but
;暫定スロースタート機能制御
flg_slowlimit = FALSE
flg_exec_first_ = TRUE
.END
.PROGRAM resetstartinfo()
;-------------------------------- 
;初回起動時だけ実行する制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
;メッセージOFF=パフォーマンス対策
;MESSAGE OFF
;外部制御盤入力設定=実機
extin_start_but = real_start_butt
extin_stop_butt = real_stop_butto
extin_teach_tgl = real_teach_tgls
extin_repeat_tg = real_repeat_tgl
;K-ROSET
tcp_listen_port[0] = real_tcp_port[0]
tcp_listen_port[1] = real_tcp_port[1]
kroset = false
;/K-ROSET
ELSE
;アーム間干渉チェック機能無効化
ZINTFCHK OFF
;K-ROSET
IF kroset THEN
ZINTFCHK ON
END
;/K-ROSET
;衝突・衝撃検知機能無効化
ZCOLDISABLE 1:  ON
ZCOLDISABLE 2:  ON
;外部制御盤入力設定=シミュレータ
extin_start_but = sim_start_butto
extin_stop_butt = sim_stop_button
extin_teach_tgl = sim_teach_tglsw
extin_repeat_tg = sim_repeat_tgls
;K-ROSET
IF kroset THEN
tcp_listen_port[0] = sim_tcp_port[0]
tcp_listen_port[1] = sim_tcp_port[1]
END
;/K-ROSET
END
flg_start_killp = FALSE
tcp_listen_lock = FALSE
flg_start_reboo = TRUE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL -extout_start_bu,-extout_stop_but
;ティーチロック無効化
ZTPDISCON  ON
;暫定スロースタート機能制御
flg_slowlimit = FALSE
flg_exec_first_ = TRUE
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
.END
.PROGRAM resetsystem()
;-------------------------------- 
;システムリセット 
;引数：無し
;戻値：無し
;-------------------------------- 
;ロボット状態初期化
CALL resetctrllinfo
;エラー状態を一旦解除する
g_last_error = err_no_error
;PCプログラムは必ず起動する(停止しない)
CALL bootpcprogram(.ret)
IF debug.prt.core==TRUE THEN
PRINT "->ResetSystem() System change to READY status."
END
flg_start_reboo = FALSE
;制御電源投入直後のロボット状態を通知する
CALL status_check(.ret)
.END
.PROGRAM rpy2oat(.#xyzrpy,.#xyzoat)
;-------------------------------- 
;機能：座標変換(RPY->OAT)
;引数：RPY
;戻値：OAT
;-------------------------------- 
;外部軸
;.xyzoat[7]=.xyzrpy[7]
DECOMPOSE .xyzrpy[1] = .#xyzrpy
;XYZRPY
.sx = SIN(.xyzrpy[4])
.sy = SIN(.xyzrpy[5])
.sz = SIN(.xyzrpy[6])
.cx = COS(.xyzrpy[4])
.cy = COS(.xyzrpy[5])
.cz = COS(.xyzrpy[6])
.mat[0,0] = .cy*.cz
.mat[0,1] = -.cy*.sz
.mat[0,2] = .sy
.mat[0,3] = .xyzrpy[1]
.mat[1,0] = .sx*.sy*.cz+.cx*.sz
.mat[1,1] = -.sx*.sy*.sz+.cx*.cz
.mat[1,2] = -.sx*.cy
.mat[1,3] = .xyzrpy[2]
.mat[2,0] = -.cx*.sy*.cz+.sx*.sz
.mat[2,1] = .cx*.sy*.sz+.sx*.cz
.mat[2,2] = .cx*.cy
.mat[2,3] = .xyzrpy[3]
.mat[3,0] = 0e+00
.mat[3,1] = 0e+00
.mat[3,2] = 0e+00
.mat[3,3] = 0e+00
;XYZOAT
.p = SQRT(.mat[0,2]*.mat[0,2]+.mat[1,2]*.mat[1,2])
.xyzoat[1] = .mat[0,3]
.xyzoat[2] = .mat[1,3]
.xyzoat[3] = .mat[2,3]
.xyzoat[5] = ATAN2(-.mat[2,2],.p)
IF ABS(.p)>1e-06 THEN
.xyzoat[4] = ATAN2(.mat[0,2],-.mat[1,2])
.xyzoat[6] = ATAN2(.mat[2,1],-.mat[2,0])
ELSE
.xyzoat[4] = ATAN2(.mat[1,1],.mat[0,1])
.xyzoat[6] = 0e+00
END
.xyzoat[4] = .xyzoat[4]-90
.xyzoat[5] = .xyzoat[5]+90
FOR .i = 1 TO 3
IF .xyzoat[.i+3]>180 THEN
.xyzoat[.i+3] = .xyzoat[.i+3]-360
END
IF .xyzoat[.i+3]<-180 THEN
.xyzoat[.i+3] = .xyzoat[.i+3]+360
END
END
POINT .#xyzoat = #PPOINT(.xyzoat[1],.xyzoat[2],xyzoat[3],.xyzoat[4],.xyzoat[5],.xyzoat[6])
.END
.PROGRAM savmod()
;-------------------------------- 
;ダイレクトティーチ用プログラム
;引数：無し
;戻値：無し
;--------------------------------
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
flg_direct_run = TRUE
PRINT "Booted DIrect-teach program. This program name is SAV."
IF (robot_mode<>mode_direct) OR (robot_mode_flg==FALSE) THEN
RETURN
END
IF TASKNO==robot_master THEN
GETULIMIT 1: .#ulim
GETLLIMIT 1: .#llim
ELSE
GETULIMIT 2: .#ulim
GETLLIMIT 2: .#llim
END
FOR .i = 1 TO 4;本体軸のみ
.ulim[.i] = DEXT(.#ulim,.i)
.llim[.i] = DEXT(.#llim,.i)
.lim[.i] = ABS(.ulim[.i])+ABS(.llim[.i])-1;上下限の絶対値の和をそのまま使うと、下アームのJT1のみ本体異常となる場合があり、念のため全軸1引いた値にしておく
END
SADEGREE .lim[1],.lim[2],.lim[3],.lim[4]
SAENVCHKOFF
SAGAIN 1,1,1,1
SASTART
WAIT ((robot_mode<>mode_direct) OR (robot_mode_flg==FALSE));プログラム終了後status_check関数が反応してエラー状態に遷移する
SAEND
SAENVCHKON
flg_direct_run = FALSE
.END
.PROGRAM selfcheck(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：呼び出しTASKと作業データのロボット種別比較
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_bad_rno
IF (TASKNO==pg_master) AND (data_robottype[.l2num,.l3num]==robot_master) THEN
.ret = err_no_error
END
IF (TASKNO==pg_slave) AND (data_robottype[.l2num,.l3num]==robot_slave) THEN
.ret = err_no_error
END
.END
.PROGRAM send(.$str,.ret)
;-------------------------------- 
;機能：UDP送信処理(動作プログラム専用)
;引数：送信文字列
;戻値：成否
;-------------------------------- 
.ret = -1
.$buf[1] = .$str
.timeout = tcp_timeout
;送信先選択
CALL get_cominfo(type_send,.nouse,.sid,nouse,.port)
IF (.sid==-1) OR ((TASKNO==1005) AND (tcp_reconnect_b[0]==TRUE)) OR ((TASKNO==1006) AND (tcp_reconnect_b[1]==TRUE)) THEN
IF (tcp_reconnect_b[0]==TRUE) OR (tcp_reconnect_b[1]==TRUE) THEN
PRINT "send()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
END
RETURN
END
;送信処理開始
IF mode_ctype==mode_udp THEN
UDP_SENDTO .ret,ip[0],.port,.$buf[1],1,.timeout
ELSE
;CALL tcp_open(1,.ret)
IF .sid!=-1 THEN
TCP_SEND .ret,.sid,.$buf[1],1,.timeout
ELSE
IF debug.prt.sock==TRUE THEN
PRINT "send NG .sid=-1"
END
END
END
IF debug.prt.sock==TRUE THEN
CALL check_disp_sock(.$buf[1],.flg_disp)
IF .flg_disp==TRUE THEN
PRINT "TASKNO=",TASKNO," send()->.sid=",.sid," port=",.port,",.$buf[1]=",.$buf[1],".ret=",.ret
END
END
.END
.PROGRAM sendresp(.cmd,.$res,.ret)
;-------------------------------- 
;機能：コマンド応答
;引数：成否
;戻値：なし
;-------------------------------- 
IF .$res<>"" THEN
.$str = $ENCODE(.cmd)+","+$ENCODE(.ret)+","+.$res+",1234"
ELSE
.$str = $ENCODE(.cmd)+","+$ENCODE(.ret)+",1234"
END
CALL send(.$str,.ret)
.END
.PROGRAM setgrav(.rno,.ret)
;-------------------------------- 
;重力補償自動調整実行ﾌﾟﾛｸﾞﾗﾑ
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
NOEXIST_SET_R grav_retry = 30
NOEXIST_SET_R grav_init[1] = -25
NOEXIST_SET_R grav_init[2] = -25
NOEXIST_SET_R grav_chk_lim = 0.5
NOEXIST_SET_R grav_chk_tim = 3
NOEXIST_SET_R grav_deg = 3
NOEXIST_SET_R grav_pul = 5
NOEXIST_SET_R grav_ret_pul = 1
GETULIMIT .rno: .#ulim
GETLLIMIT .rno: .#llim
DECOMPOSE .rno: .ulim[1] = .#ulim
DECOMPOSE .rno: .llim[1] = .#llim
DECOMPOSE .rno: .ho[1] = #HOME(1)
.retry = 0;ﾘﾄﾗｲ回数ﾘｾｯﾄ
.jt3grav = grav_init[.rno];重力補償値初期値設定
.jt3pos = (.ulim[3]+.llim[3])/2;3軸初期位置
.flg_pul = 5;重力補償値きざみﾌﾗｸﾞ初期化
.jt3gravpul = grav_pul;重力補償値きざみ値
.flg_finish = FALSE;重力補償設定最終段階ﾌﾗｸﾞ
IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで適切な位置へ移動処理を入れる
JMOVE #grav_pos[.rno]
BREAK
END
;
retry:
COLROFF .rno: 
COLRJOFF .rno: 
PRINT TASKNO,.jt3grav
ZSAGRAV .rno: 3,.jt3grav
DECOMPOSE .jt[1] = #S_HERE(.rno)
SPEED 200 MM/S
ZL3LMOVE #PPOINT(.jt[1],.jt[2],.jt3pos,.jt[4],.jt[5],.jt[6]),1,1
BREAK
;
SADEGREE ,,grav_deg
SAENVCHKOFF
SAGAIN 100,100,1,100,100,100
.pre_jt3 = DEXT(#S_HERE(.rno),3)
UTIMER .@tim = 0
SASTART
TWAIT 0.5
DO
.now_jt3 = DEXT(#S_HERE(.rno),3)
IF UTIMER(.@tim)>=60 OR .retry>=grav_retry THEN ;60秒以上経過orﾘﾄﾗｲ上限を越えた
.ret = err_gravityadj
SAEND
COLRON .rno: 
COLRJON .rno: 
SPEED 200 MM/S
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
PRINT "TASKNO=",TASKNO,",ZSAGRAV Set NOT complete."
RETURN
END
IF (SACHK:.rno)==0 OR (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)>grav_chk_lim) THEN ;3軸が指定動作範囲を超えたor指定時間経過後に指定角度以上3軸が動いている
SAEND
.retry = .retry+1
IF .jt3pos-DEXT(#S_HERE(.rno),3)>0 THEN
IF .flg_pul==FALSE THEN
.jt3gravpul = grav_ret_pul
END
.jt3grav = .jt3grav-.jt3gravpul
.flg_pul = TRUE
ELSE
IF .flg_pul==TRUE THEN
.jt3gravpul = grav_ret_pul
END
.jt3grav = .jt3grav+.jt3gravpul
.flg_pul = FALSE
END
GOTO retry
END
TWAIT 0.016
UNTIL (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)<grav_chk_lim) ;指定時間以上経過しても3軸が指定値以上動いていない
SAEND
.jt3gravpul = grav_ret_pul
IF .flg_finish<>TRUE THEN
CASE .jt3pos OF
VALUE (.ulim[3]+.llim[3])/2:
.jt3pos = .llim[3]+1
GOTO retry
VALUE (.llim[3]+1):
.jt3pos = .ulim[3]-1
GOTO retry
VALUE (.ulim[3]-1):
.jt3pos = 75
.flg_finish = TRUE
GOTO retry
END
END
grav_init[.rno] = .jt3grav
grav_cur_val[.rno-1] = .jt3grav
COLRON .rno: 
COLRJON .rno: 
IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで初期位置に戻す。
JMOVE #grav_pos[.rno]
BREAK
END
SPEED 200 MM/S
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
PRINT "TASKNO=",TASKNO,",ZSAGRAV Set complete."
RETURN
.END
.PROGRAM setparam(.cmd,.$prm[],.ret)
;-------------------------------- 
;機能：変数設定コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL(.$prm[1])
CASE .cmd OF
VALUE cmd_set_sp:
;This protcol will delete soon.
VALUE cmd_set_pitch:
data_teachrot = VAL(.$prm[2])
data_teachpitch = VAL(.$prm[3])
data_exttype[robot_master] = VAL(.$prm[4])
data_exttype[robot_slave] = VAL(.$prm[5])
VALUE cmd_set_tnum:
tool_data_num[.rno] = VAL(.$prm[2])
VALUE cmd_set_tool:
;カレントツールは変更しないでデータ格納のみ実行する
.mode = VAL(.$prm[2]);モードは無効、後日削除
;重量、重心(XYZイナーシャXYZ)は未対応のため無視
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
POINT def_tool[.rno,VAL(.$prm[3])] = TRANS(VAL(.$prm[4]),VAL(.$prm[5]),VAL(.$prm[6]),0,0,0)
POINT temp_tool = def_tool[.rno,VAL(.$prm[3])]
;動作コマンド実行時は異なるツール番号の時だけ更新する
;同じツール番号で設定変更した場合はここで即時更新する
DECOMPOSE .toolprm[1] = def_tool[.rno,VAL(.$prm[3])]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdsetparam() CHANGE TOOL(DEF_TOOL) TO .rno=",.rno," .tno[]=",VAL(.$prm[3])
PRINT "->cmdsetparam() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
END
IF .rno==1 THEN
ZL3LINKX 1: .toolprm[1]
ZL3LINKX2 1: .toolprm[2]
ZL3LINKH1 1: .toolprm[3]
ELSE
ZL3LINKX 2: .toolprm[1]
ZL3LINKX2 2: .toolprm[2]
ZL3LINKH1 2: .toolprm[3]
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdsetparam() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
END
VALUE cmd_set_cord:
data_teachcoord = VAL(.$prm[2])
VALUE cmd_set_home:
.homeno = VAL(.$prm[2])
IF .homeno!=1 && .homeno!=2 THEN
.ret = err_bad_homeno
RETURN
END
;.$prm[3]-.$prm[7]=JT1-JT6,.$prm[8]=精度
;タブレット送信データ並び順=JT1,JT2,JT3,JT4,Ext1
POINT .#buf = #PPOINT(VAL(.$prm[3]),VAL(.$prm[4]),VAL(.$prm[5]),VAL(.$prm[6]),0,0)
POINT #robot_home[.rno,.homeno] = .#buf
robot_hacc[.rno,.homeno] = VAL(.$prm[8])
IF .homeno==1 THEN
IF .rno==robot_all THEN
SETHOME robot_master: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
SETHOME robot_slave: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
ELSE
SETHOME .rno: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
END
ELSE
IF .rno==robot_all THEN
SET2HOME robot_master: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
SET2HOME robot_slave: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
ELSE
SET2HOME .rno: robot_hacc[.rno,.homeno],#robot_home[.rno,.homeno]
END
END
VALUE cmd_set_signame:
IF VAL(.$prm[2])<0 THEN
.ret = err_bad_tableno
RETURN
END
IF VAL(.$prm[3])<0 THEN
.ret = err_bad_tableno
RETURN
END
$data_io_num[VAL(.$prm[2])] = .$prm[3]
$data_io_name[VAL(.$prm[2])] = .$prm[4]
VALUE cmd_set_signum:
IF VAL(.$prm[2])<0 THEN
.ret = err_bad_tableno
RETURN
END
data_io_tablenu = VAL(.$prm[2])
VALUE cmd_set_l2exetb:
IF VAL(.$prm[3])<0 THEN
.ret = err_bad_tableno
RETURN
END
data_l2tbl_sign[VAL(.$prm[2]),VAL(.$prm[3])] = VAL(.$prm[4])
data_l2tbl_stat[VAL(.$prm[2]),VAL(.$prm[3])] = VAL(.$prm[5])
VALUE cmd_set_handio:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
data_hand_type[.rno] = VAL(.$prm[2])
data_hand_io[.rno,1] = VAL(.$prm[3])
data_hand_io[.rno,2] = VAL(.$prm[4])
data_hand_io[.rno,3] = VAL(.$prm[5])
data_hand_io[.rno,4] = VAL(.$prm[6])
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_vtb:
.vtblno = VAL(.$prm[2])
IF .vtblno<=0 THEN
.ret = err_bad_tableno
RETURN
END
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
data_vs_cam_num[.vtblno] = VAL(.$prm[4])
data_vs_calc_nu[.vtblno] = VAL(.$prm[5])
data_vs_cam_typ[.vtblno] = VAL(.$prm[6])
data_vs_hold_ty[.vtblno] = VAL(.$prm[7])
data_vs_calc_po[.vtblno] = VAL(.$prm[8])
$data_vs_name[.vtblno] = .$prm[9]
data_vs_robot[.vtblno] = VAL(.$prm[10])
;ビジョンID変換
CALL convert_vid(mode_add,data_vs_calc_po[.vtblno],VAL(.$prm[3]),data_vs_vid[.vtblno])
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_vtbnum:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
data_vs_tbnum = VAL(.$prm[2])
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_lowspar:
IF VAL(.$prm[2])<=0 OR VAL(.$prm[2])>=5 THEN
.ret = err_bad_areano
RETURN
END
;取得ASコマンドが存在しないためGETコマンド用に暫定保持
areaslow_locati[VAL(.$prm[2]),1] = VAL(.$prm[3])
areaslow_locati[VAL(.$prm[2]),2] = VAL(.$prm[4])
areaslow_locati[VAL(.$prm[2]),3] = VAL(.$prm[5])
areaslow_locati[VAL(.$prm[2]),4] = VAL(.$prm[6])
areaslow_rate[VAL(.$prm[2])] = VAL(.$prm[7])
ZAREASLOWSET VAL(.$prm[2]): VAL(.$prm[3]),VAL(.$prm[4]),VAL(.$prm[5]),VAL(.$prm[6])
ZAREASLOWRATE VAL(.$prm[2]): VAL(.$prm[7])
VALUE cmd_set_lowspse:
;取得ASコマンドが存在しないためGETコマンド用に暫定保持
areaslow_mode = VAL(.$prm[2])
IF VAL(.$prm[2])==OFF THEN
ZAREASLOWMODE OFF
ELSE
ZAREASLOWMODE ON
END
VALUE cmd_set_zeroing:
CALL cmdzero(.rno,VAL(.$prm[2]),VAL(.$prm[3]),.ret)
VALUE cmd_set_colchkm:
;ダイレクトティーチモード及びタブレットティーチモード中は実行禁止 15/11/27 add Y.Fujimoto
IF robot_mode==mode_tablet AND robot_mode_flg==FALSE THEN
.flg = VAL(.$prm[2])
CALL chg_colcalflg(.flg)
END
VALUE cmd_set_slowlim:
slowlimit_speed = VAL(.$prm[2])
slowlimit_time = VAL(.$prm[3])
VALUE cmd_set_iftblnu:
data_ifcontblnu = VAL(.$prm[2])
VALUE cmd_set_ifconnu:
.iftbl_no = VAL(.$prm[2])
;設定タイミングの自由度を上げるために上限チェックはしない
IF .iftbl_no<=0 THEN
.ret = err_bad_tableno
RETURN
END
data_ifconnum[VAL(.$prm[2])] = VAL(.$prm[3])
VALUE cmd_set_iftbl:
.iftbl_no = VAL(.$prm[2])
IF .iftbl_no<=0 THEN
.ret = err_bad_tableno
RETURN
END
.ifcon_no = VAL(.$prm[3])
;設定タイミングの自由度を上げるために上限チェックはしない
IF .ifcon_no<=0 THEN
.ret = err_bad_tableno
RETURN
END
;カウンタ、不等号、常にTRUE
data_ifcontype[.iftbl_no,.ifcon_no] = VAL(.$prm[4])
;符号、不等号
data_ifconsign[.iftbl_no,.ifcon_no] = VAL(.$prm[5])
;カウンタ番号、信号番号、TRUE状態
data_ifconval[.iftbl_no,.ifcon_no] = VAL(.$prm[6])
IF data_ifcontype[.iftbl_no,.ifcon_no]==ifcon_cnt THEN
;カウンタ比較値
data_ifconcnt[.iftbl_no,.ifcon_no] = VAL(.$prm[7])
END
ANY :
.ret = err_bad_ptype
END
.END
.PROGRAM setstep(.$prm[],.ret)
;-------------------------------- 
;機能：作業情報の設定コア
;引数：実数配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL(.$prm[2])
.l3num = VAL(.$prm[3])
.l3type = VAL(.$prm[4])
NOEXIST_SET_S .$prm[10] = "0"
.sp = VAL(.$prm[10])
IF .l3type==l3type_move AND (.sp<=0 OR .sp>100) THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
$data_l3name[.l2num,.l3num] = .$prm[5]
data_l3type[.l2num,.l3num] = .l3type    ; @@@ ADD 20140926 A.kobayashi
data_robottype[.l2num,.l3num] = VAL(.$prm[1])
;.prm[5]以降が設定データ
CASE .l3type OF
VALUE l3type_move:
data_vision_sta[.l2num,.l3num] = VAL(.$prm[6])
;ビジョンID変換(引数順でID割当番号)
data_vision_id1[.l2num,.l3num] = VAL(.$prm[7])
CALL convert_vid(mode_add,type_pos,VAL(.$prm[8]),data_vision_id2[.l2num,.l3num])
CALL convert_vid(mode_add,type_pos,VAL(.$prm[9]),data_vision_id3[.l2num,.l3num])
data_repspeed[.l2num,.l3num] = VAL(.$prm[10])
data_postype[.l2num,.l3num] = VAL(.$prm[11])
data_wait_befor[.l2num,.l3num] = VAL(.$prm[12])
data_wait_after[.l2num,.l3num] = VAL(.$prm[13])
VALUE l3type_io_wait:
data_signum[.l2num,.l3num] = VAL(.$prm[6])
data_sigstatus[.l2num,.l3num] = VAL(.$prm[7])
data_wait_befor[.l2num,.l3num] = VAL(.$prm[8])
data_wait_after[.l2num,.l3num] = VAL(.$prm[9])
data_wait_timeo[.l2num,.l3num] = VAL(.$prm[10])
VALUE l3type_io_chang:
data_signum[.l2num,.l3num] = VAL(.$prm[6])
data_sigstatus[.l2num,.l3num] = VAL(.$prm[7])
data_wait_befor[.l2num,.l3num] = VAL(.$prm[8])
data_wait_after[.l2num,.l3num] = VAL(.$prm[9])
data_keep_wait[.l2num,.l3num] = VAL(.$prm[10])
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend,l3type_return:
;No need parameters for this commands.
VALUE l3type_vision,l3type_calvisio:
data_vision_cal[.l2num,.l3num] = VAL(.$prm[7])
;ビジョンID変換
CALL convert_vid(mode_add,VAL(.$prm[7]),VAL(.$prm[6]),data_vision_id[.l2num,.l3num])
VALUE l3type_l2reset:
data_l2resetnum[.l2num,.l3num] = VAL(.$prm[6])
VALUE l3type_hand_cha:
data_hand_ctl[.l2num,.l3num] = VAL(.$prm[6])
VALUE l3type_colchk:
data_colchk[.l2num,.l3num] = VAL(.$prm[6])
VALUE l3type_ifgoto:
data_l3ifgoto_i[.l2num,.l3num] = VAL(.$prm[6])
$data_l3ifgoto_l[.l2num,.l3num] = .$prm[7]
VALUE l3type_iflabel:
$data_l3label[.l2num,.l3num] = .$prm[6]
VALUE l3type_cntup:
data_cntid[.l2num,.l3num] = VAL(.$prm[6])
VALUE l3type_cntset:
data_cntid[.l2num,.l3num] = VAL(.$prm[6])
data_cntval[.l2num,.l3num] = VAL(.$prm[7])
ANY :
.ret = err_bad_l3type
END
.END
.PROGRAM setsteppos(.$prm[],.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL(.$prm[2])
.l3num = VAL(.$prm[3])
data_mode[.l2num,.l3num] = VAL(.$prm[4])
data_tool[.l2num,.l3num] = VAL(.$prm[5])
;並び替え
IF data_mode[.l2num,.l3num]==mode_jt THEN
data_pos1[.l2num,.l3num] = VAL(.$prm[5+1]);JT1
data_pos2[.l2num,.l3num] = VAL(.$prm[5+2]);JT2
data_pos3[.l2num,.l3num] = VAL(.$prm[5+3]);JT3
data_pos4[.l2num,.l3num] = VAL(.$prm[5+4]);JT4
data_pos5[.l2num,.l3num] = 0;固定
data_pos6[.l2num,.l3num] = 0;固定
ELSE
data_pos1[.l2num,.l3num] = VAL(.$prm[5+1]);X
data_pos2[.l2num,.l3num] = VAL(.$prm[5+2]);Y
data_pos3[.l2num,.l3num] = VAL(.$prm[5+3]);Z
data_pos4[.l2num,.l3num] = VAL(.$prm[5+4]);R1
data_pos5[.l2num,.l3num] = 0;固定
data_pos6[.l2num,.l3num] = 0;固定
END
.END
.PROGRAM shift_pos(.rno,.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
;-------------------------------- 
;機能：教示点加算
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
.ret = err_no_error
IF debug.prt.pos==TRUE THEN
FOR .i = 1 TO 6
PRINT "shift_pos()-> .offsetpos[]=",.offsetpos[.i]
END
END
DECOMPOSE .inpos[1] = .#inpos
DECOMPOSE .offsetpos[1] = .#offsetpos
IF disable_avetool==FALSE THEN
IF (.rno==robot_all) AND (.mode==mode_xyzr1ext1) AND (.shift_type==mode_tool) THEN
;inposは無視して、現在値ベースで加算する
POINT .inpos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
;中心位置にオフセット加算
CALL getcurrentpos(robot_master,.mode,.#pos_m,.ret)
DECOMPOSE .pos_m[1] = .#pos_m
POINT .pos_m = TRANS(.pos_m[1],.pos_m[2],.pos_m[3],.pos_m[4])
CALL getcurrentpos(robot_slave,.mode,.#pos_s,.ret)
DECOMPOSE .pos_s[1] = .#pos_s
POINT .pos_s = TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4])
POINT .pos_ave = AVE_TRANS(.pos_m,.pos_s)
POINT .pos_diff = -.pos_m+.pos_ave
;マスター位置に換算
POINT .pos = .pos_ave+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])-.pos_diff
DECOMPOSE .outpos[1] = .pos
POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
RETURN
END
END
CALL shift_poscore(.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
.END
.PROGRAM shift_poscore(.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
;-------------------------------- 
;機能：教示点加算コア処理
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
.ret = err_no_error
DECOMPOSE .inpos[1] = .#inpos
DECOMPOSE .offsetpos[1] = .#offsetpos
CASE .mode OF
VALUE mode_jt:
;OFFSET値は各軸とする(ビジョン補正の加算演算はロボットBC判断で対応不要とのこと)
POINT .#pos = #PPOINT(.inpos[1]+.offsetpos[1],.inpos[2]+.offsetpos[2],.inpos[3]+.offsetpos[3],.inpos[4]+.offsetpos[4])
DECOMPOSE .outpos[1] = .#pos
VALUE mode_xyzr1ext1:
CASE .shift_type OF
VALUE mode_tool:
POINT .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])
DECOMPOSE .outpos[1] = .pos
VALUE mode_base:
POINT .pos = TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])+TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
DECOMPOSE .outpos[1] = .pos
END
ANY :
.ret = err_bad_mode
RETURN
END
POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
IF debug.prt.pos==TRUE THEN
FOR .i = 1 TO 6
PRINT "shift_poscore()-> .inpos[]=",.inpos[.i]
END
FOR .i = 1 TO 6
PRINT "shift_poscore()-> .outpos[]=",.outpos[.i]
END
END
.END
.PROGRAM slave_run(.timeout,.ret)
;-------------------------------- 
;機能：スレーブ動作実行
;引数：
;戻値：成否
;-------------------------------- 
.ret = err_no_error
UTIMER .@nowtime = 0
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() Slave robot moved to TARGET-POSITION."
END
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "->movepos() WAITING Slave robot move to TARGET-POSITION. TIME=",UTIMER(.@nowtime),"/LIMIT=",.timeout
END
END
IF UTIMER(.@nowtime)>.timeout THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() TIMEOUT ERROR.Slave robot NOT move to TARGET-POSITION."
END
.ret = err_cmd_timeout
RETURN
END
IF g_last_error<>err_no_error THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() Detected error. g_last_error=",g_last_error
END
.ret = err_srobot_erro
RETURN
END
END
.END
.PROGRAM status_check(.ret)
;-------------------------------- 
;機能：ロボット状態監視
;引数：なし
;戻値：成否(err_no_error:正常、0以外:異常)
;-------------------------------- 
.ret = err_no_error
IF (flg_start_reboo==FALSE) AND (flg_main_run==TRUE OR flg_direct_run==TRUE) AND (SWITCH(POWER ,1)==OFF OR SWITCH(POWER ,2)==OFF) THEN
IF g_last_error<>err_motor_off THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(POWER,1)==OFF OR SWITCH(POWER,2)==OFF)"
END
END
.ret = err_motor_off
END
IF (flg_start_reboo==FALSE) AND (((flg_main_run==TRUE) AND (flg_tablet_run[1]==TRUE) AND (flg_tablet_run[2]==TRUE)) OR flg_direct_run==TRUE) AND ((SWITCH(CS ,1)==OFF) OR (SWITCH(CS ,2)==OFF)) THEN
IF (SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON) THEN
IF (flg_master_move==TRUE) OR (flg_master_move==TRUE) OR ((robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE)) OR ((robot_mode==mode_direct) AND (robot_mode_flg<>FALSE)) THEN
IF g_last_error<>err_cs_off THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(CS,1)==OFF) OR (SWITCH(CS,2)==OFF)"
END
END
.ret = err_cs_off
END
END
END
IF (flg_start_reboo==FALSE) AND (flg_main_run==TRUE OR flg_direct_run==TRUE) AND (g_last_error<>err_no_error) THEN
IF (SWITCH(POWER ,1)!=OFF AND SWITCH(POWER ,2)!=OFF) THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (G_LAST_ERROR<>err_no_error)"
END
.ret = g_last_error
END
END
;動作範囲外エラーや干渉回避エラーなどが発生
IF (SWITCH(ERROR ,1)==ON) OR (SWITCH(ERROR ,2)==ON) THEN
IF (SYSDATA(ERROR.CODE,1)<>OFF) AND (SYSDATA(ERROR.CODE,2)<>OFF) THEN;2台同時にエラーコード有り
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF AND SYSDATA(ERROR.CODE,2)<>OFF"
END
.ret = err_roboterror[0];ロボット本体異常発生中（2台同時発生中）
ELSE
IF SYSDATA(ERROR.CODE,1)<>OFF THEN;マスタロボットで発生中
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF == ON"
END
.ret = err_roboterror[1];下アーム異常発生中
ELSE
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,2.)<>OFF == ON"
END
.ret = err_roboterror[2];上アーム異常発生中
END
END
END
;即応答コマンド実行中等にエラーが発生した場合はここから即応答する
;pccom関数内だと自動リセット後で判定できない可能性有
IF .ret<>err_no_error THEN
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
;1台ロボットが停止した場合を考慮してHOLDする
MC HOLD 1:
MC HOLD 2:
IF data_execute==TRUE THEN
CALL update_holdpos
END
CALL update_error(.ret)
IF (flg_master_move==TRUE) THEN
IF cmd_wait_type[ope_command]==cmd_type_wait THEN
CALL sendresp(ope_command,"",.ret)
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> Detected robot-error while moving robot.so execute sendresp()."
END
END
END
CALL chk_robot_stop_
END
.END
.PROGRAM sub()
;---------------------------------
;機能：動作プログラム(スレーブ)
;引数：無し
;戻値：無し
;-------------------------------- 
.ret = g_last_error
.$res = ""
IF TASKNO==pg_slave THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Booted sub program. This program working in ROBOT-MASTER."
END
ELSE
PRINT "sub()-> Booted sub program in BAD-TASK. TASKNO=",TASKNO
RETURN
END
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Done sub program. ROBOT_MODE=",robot_mode,",ROBOT_MODE_FLG=",robot_mode_flg
END
GOTO 10
END
CALL exec_alone(.ret)
;ダイレクトティーチモード強制解除
SAEND
SAENVCHKON
999
;初期化：共通処理
CALL chg_sp(100,.ret)
ACCURACY 0.1 ALWAYS
;初期化：ロボット別
flg_tablet_run[2] = TRUE
flg_slave_rdy = FALSE
flg_slave_move = FALSE
;マスターロボット動作準備完了待ち
IF flg_tablet_run[1]==FALSE THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>wait_maste_time THEN
GOTO 10
END
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",WAITING... MASTER-ROBOT still not booted."
END
UNTIL (flg_tablet_run[1]==TRUE)
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 1"
END
ELSE
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 2"
END
END
;コマンド実行指示待ち
DO
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
;プログラム終了後status_check関数が反応してエラー状態に遷移する
IF debug.prt.sub==ON THEN
PRINT "sub()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
END
GOTO 10
END
;マスター動作プログラム終了に併せてスレーブロボットの動作を終了する
IF flg_tablet_run[1]==FALSE THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> MSTER ROBOT IS NOT BOOTING...OPE_COMMAND=",ope_command
END
GOTO 10
END
UNTIL (flg_slave_move==TRUE)
;コマンド実行
;実行タイミングはMASTERが指示、エラー処理はMASTERで実行
CASE ope_command OF
VALUE cmd_exe_gen:
;原点番号設定
.home_no = VAL($ope_param[3])
;ロボット番号設定
.rno = robot_slave
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
BREAK
VALUE cmd_exe_start,cmd_exe_move,cmd_exe_teach,cmd_exe_l2exe,cmd_exe_restart:
IF flg_slave_paral==FALSE THEN
;動作コマンドのみサポート、その他(IO待ち、変更など）はMASTERで実行
CALL submove(.ret)
CALL update_error(.ret)
ELSE
;並列スレーブロボット連続作業実行
.l2num = gs_l2num
.l3num = gs_l3num
IF .l2num==0 AND .l3num==0 THEN
IF debug.prt.sub==ON THEN
PRINT "sub()->.l2num and .l3num are Zero for SLAVE ROBOT!."
END
flg_slave_con = FALSE
GOTO 10
END
;マスターが実行済み部分をスキップして処理開始
IF flg_slave_con==TRUE THEN
CALL l2exec(.l2num,.l3num,.ret)
CALL update_error(.ret)
ELSE
FOR .l2num = gs_l2num TO data_l2num
CALL l2exec(.l2num,.l3num,.ret)
IF .ret<>err_no_error THEN
IF .ret==err_slave_acten THEN
;正常終了処理
.ret = err_no_error
GOTO 10
ELSE
;異常終了処理
CALL update_error(.ret)
GOTO 10
END
END
;途中作業以降は先頭から実行
.l3num = 1
END
END
END
VALUE cmd_exe_gravity:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_GRAVITYADJ"
END
.mode = gs_gravity_mode
.setval = gs_gravity_setv
CALL gravityadj_core(robot_slave,.mode,.setval,.ret)
CALL update_error(.ret)
VALUE cmd_exe_vscalib:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VSCALIB"
END
.rno = gs_rno
.camno = gs_camno
.calno = gs_calno
.camtype = gs_camtype
POINT .target = gs_posxyzr1
.len = gs_len
.height = gs_height
POINT .tool_p = gs_toolp
CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
CALL update_error(.ret)
ANY :
IF debug.prt.sub==ON THEN
PRINT "sub()-> Error occuerd. You try to execute unsupport command.OPE_COMMAND=",ope_command
END
.ret = err_cmd_type
END
10
;終了処理
;マスタープログラム終了検知までsubプログラムを終了しない(sub関数先頭ループ処理に検知実装有)
IF flg_main_run<>FALSE THEN
GOTO 999
ELSE
flg_slave_move = FALSE
END
flg_tablet_run[2] = FALSE
flg_main_run = FALSE
.END
.PROGRAM submove(.ret)
;---------------------------------
;機能：スレーブロボット専用指定位置移動
;引数：無し
;戻値：成否
;メモ：動作に必要な情報はマスター側で生成する
;---------------------------------
.ret = err_no_error
ACCEL data_acc ALWAYS
DECEL data_dec ALWAYS
.sp = gs_sp
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
RETURN
END
;同期モード動作
IF flg_req_mamode==TRUE THEN
IF debug.prt.sub==TRUE THEN
PRINT "->submove() SLAVE ROBOT ....................."
END
JMOVE #HERE
;マスタ側にスレーブが協調モードに入ることを通知する
;協調動作に入った後のハンドシェイクはASシステムが行うので考慮不要とのこと
flg_slave_rdy = TRUE
SLAVE
;協調動作
ALONE
RETURN
END
;ツール変換値設定
IF gs_mode<>mode_jt THEN
IF data_toolcur[robot_slave]<>gs_tool THEN
DECOMPOSE .toolprm[1] = def_tool[robot_slave,gs_tool]
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
IF debug.prt.sub==TRUE THEN
PRINT "->sub() CHANGE TOOL(DEF_TOOL) TO .rno=",robot_slave," .tno[]=",gs_tool
PRINT "->sub() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,2)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,2)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,2))
END
ZL3LINKX 2: .toolprm[1]
ZL3LINKX2 2: .toolprm[2]
ZL3LINKH1 2: .toolprm[3]
data_toolcur[robot_slave] = gs_tool
IF debug.prt.sub==TRUE THEN
PRINT "->sub() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,2)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,2)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,2))
END
END
END
;移動動作
IF gs_type==mode_jmove THEN
IF gs_mode==mode_jt THEN
JMOVE #g_mpos
ELSE
DECOMPOSE .p[1] = g_mpos
.p[6] = g_ext1
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
JMOVE .#tpos;変換値指定はできない
END
ELSE
IF gs_mode==mode_jt THEN
ZL3LMOVE #g_mpos,1,1;引数は各軸値
ELSE
DECOMPOSE .p[1] = g_mpos
.p[6] = g_ext1
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
ZL3LMOVE .#tpos,1,1;引数は各軸値
END
END
;終了フラグ先読み防止で相互終了同期有
BREAK
.END
.PROGRAM tcp_check(.num,.ret)
;---------------------------------------------------
;機能:TCP接続状態の確認
;引数:なし
;戻値:接続数、成否
;---------------------------------------------------
.ret = err_no_error
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF debug.prt.sock==TRUE THEN
PRINT "TCP_STATUS .num=",.num
IF .num>0 THEN
FOR .i = 0 TO .num-1
PRINT ".port_no[",.i,"]=",.port_no[.i]," .sid[",.i,"]=",.sid[.i]," .ecode[",.i,"]=",.ecode[.i]," .scode[",.i,"]=",.scode[.i]
END
END
END
.END
.PROGRAM tcp_close()
;---------------------------------------------------
;機能:TCP/IP 通信終了（サーバ側）
;引数:.sock_id
;戻値:.port
;---------------------------------------------------
.ret = err_no_error
;ポート閉処理
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_STATUS .num=",.num
END
IF .num<=0 THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_CLOSE <no connection>"
END
RETURN
ELSE
FOR .i = 0 TO .num-1
;LISTENポートは閉じない
IF (.sid[.i]<>tcp_listen_sid[0]) AND (.sid[.i]<>tcp_listen_sid[1]) THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_CLOSE .sid=",.sid[.i]
END
TCP_CLOSE .ret,.sid[.i]
IF .ret<0 THEN
.ret = -1
ELSE
CALL updatetcpinfo(.sid[.i])
END
END
END
END
.END
.PROGRAM tcp_open(.timeout,.ret)
;---------------------------------------------------
;機能:TCP/IP通信開始（サーバ側)(動作命令用ポートオープン)
;　　 同時接続数1でクライアント側任意のタイミングで接続切断繰返しに対応
;引数:タイムアウト
;戻値:成否
;---------------------------------------------------
.ret = err_no_error
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF tcp_listen_lock==FALSE AND .num==0 THEN
tcp_connected[0] = FALSE
tcp_sid[0] = -1
tcp_sid_port[0] = -1
tcp_connected[1] = FALSE
tcp_sid[1] = -1
tcp_sid_port[1] = -1
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->TCP_LISTEN START port_tcp[0]=",tcp_listen_port[0]
PRINT "tcp_open()->TCP_LISTEN START port_tcp[1]=",tcp_listen_port[1]
END
TCP_LISTEN .ret,tcp_listen_port[0]
TCP_LISTEN .ret,tcp_listen_port[1]
tcp_listen_lock = TRUE
;LISTENポートの保存
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
FOR .i = 0 TO .num-1
IF .port_no[.i]==tcp_listen_port[0] THEN
tcp_listen_sid[0] = .sid[.i]
PRINT "tcp_open()->TCP_LISTEN_PORTSID[0]=",tcp_listen_sid[0]
END
IF .port_no[.i]==tcp_listen_port[1] THEN
tcp_listen_sid[1] = .sid[.i]
PRINT "tcp_open()->TCP_LISTEN_PORTSID[1]=",tcp_listen_sid[1]
END
END
END
;オープン先選択
CALL get_cominfo(type_open,.port,.nouse,.idnum,.nouse)
;オープン受付処理開始
TCP_ACCEPT .sid[0],.port,.timeout,ip[0]
IF .sid[0]<0 THEN
.ret = -1
RETURN
ELSE
IF .port==tcp_listen_port[0] THEN
tcp_reconnect_b[0] = TRUE
ELSE
tcp_reconnect_b[1] = TRUE
END
;初期接続、もしくは再接続
tcp_connected[.idnum] = TRUE
;ポート入替対策、再接続中のsend()/recv()エラー対策
FOR .i = 0 TO 1
IF tcp_sid_port[.i]==.port THEN
PRINT "tcp_open()->DELETE TCP-PORT SETTINGS FOR RECONNECT. i=",.i
tcp_connected[.i] = FALSE
END
END
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->NEW TCP_ACCEPT .sid[0]=",.sid[0]," .port=",.port
END
;TCP_STATUSで取得できないのでSIDに対応するポート仮記録
.new_port = .port
;ACCEPTした新しいSIDを仮記録
.new_sid = .sid[0]
;前回ACCEPTしたポートを閉じる
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
FOR .i = 0 TO .num-1
;LISTENポートはCLOSEしない
;SIDチェック
IF (.sid[.i]<>tcp_listen_sid[0]) AND (.sid[.i]<>tcp_listen_sid[1]) THEN
;開きなおし対象ポート検索
;SIDチェック
FOR .j = 0 TO 1
IF (.sid[.i]==tcp_sid[.j]) THEN
IF .new_port==tcp_sid_port[.j] THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->CLOSING .sid[i]=",.sid[.i]," .new_port=",.new_port
END
TCP_CLOSE .ret,.sid[.i]
IF .ret<0 THEN
.ret = -1
ELSE
CALL updatetcpinfo(.sid[.i])
GOTO 10
END
END
END
END
END
END
10
;ACCEPTした新しいSIDの仮記憶をグローバル変数のSIDに上書き
PRINT "tcp_open()->NEW->.port=",.new_port,",.sid=",.new_sid
tcp_sid[.idnum] = .new_sid
;TCP_STATUSで取得できないのでSIDに対応するポート記録
tcp_sid_port[.idnum] = .new_port
IF .port==tcp_listen_port[0] THEN
tcp_reconnect_b[0] = FALSE
ELSE
tcp_reconnect_b[1] = FALSE
END
END
.END
.PROGRAM update_error(.ret)
;---------------------------------
;機能：エラー状態、表示更新
;引数：エラーコード
;戻値：無し
;---------------------------------
g_last_error = .ret
.END
.PROGRAM update_holdpos()
;-------------------------------- 
;機能：位置データの記録
;引数：無し
;戻値：無し
;--------------------------------
;停止位置記憶有効フラグ
IF disable_readj_p==FALSE THEN
flg_enable_stop = TRUE
END
POINT #rec_holdpos[1] = #S_HERE(1)
POINT #rec_holdpos[2] = #S_HERE(2)
IF debug.prt.func==TRUE THEN
FOR .j = 1 TO 2
DECOMPOSE .buf[1] = #rec_holdpos[.j]
FOR .i = 1 TO 6
PRINT "TASKNO=",TASKNO,"update_holdpos()-> Element of REC_HOLDPOS[",.j,"]:[",.i,"]=",.buf[.i]
END
END
END
.END
.PROGRAM update_vspos(.l2num,.l3num,.#inpos,.#outpos,.ret)
;-------------------------------- 
;機能：ビジョン計測結果反映
;引数：入力変換値配列
;戻値：出力変換値配列,成否
;-------------------------------- 
.ret = err_no_error
DECOMPOSE .inpos[1] = .#inpos
POINT .#outpos = .#inpos
;補正なしの場合は入力値はそのまま返すために出力値を入力値で初期化する
FOR .i = 1 TO 6
.outpos[.i] = .inpos[.i]
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)==2 THEN
RETURN
END
;ビジョン補正設定有効・無効判定確認
CALL check_vsl3data(.l2num,.l3num,.ret)
IF .ret<>TRUE THEN
;ビジョン補正設定無効
RETURN
END
;補正演算
;DATA_VISION_ID1、DATA_VISION_ID2、DATA_VISION_ID3=装置補正用ビジョンID、ワーク位置補正用ビジョンID、ツール位置補正用ビジョンIDの順番固定とする
POINT .in = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
CALL vcorrect(.&in,data_vision_id2[.l2num,.l3num],data_vision_id3[.l2num,.l3num],.&pos)
DECOMPOSE .outpos[1] = .pos
POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
.END
.PROGRAM updatel2l3info(.flg_disp,.l2num,.l3num,.flg_full)
;-------------------------------- 
;機能：作業実行状態更新、内部制御用変数更新
;引数：タブレット用情報更新フラグ(ON/OFF)、第2階層番号(マイナス値の場合更新無し)、第3階層番号(マイナス値の場合更新無し)、完全初期化フラグ
;戻値：無し
;--------------------------------
IF .flg_full==TRUE THEN
;完全初期化
data_cur_l2disp = 0
data_cur_l3disp = 0
FOR .i = 1 TO 2
data_cur_l2rec[.i] = 0
data_cur_l3rec[.i] = 0
END
flg_master_con = FALSE
flg_slave_con = FALSE
RETURN
END
IF TASKNO==pg_master THEN
.rno = robot_master
ELSE
.rno = robot_slave
END
IF .l2num>=0 THEN
data_cur_l2rec[.rno] = .l2num
IF (.flg_disp==TRUE) AND (.rno==robot_master) THEN
data_cur_l2disp = .l2num
END
END
IF .l3num>=0 THEN
data_cur_l3rec[.rno] = .l3num
IF (.flg_disp==TRUE) AND (.rno==robot_master) THEN
data_cur_l3disp = .l3num
END
END
IF .l2num==0 AND .l3num==0 THEN
IF .flg_disp==TRUE THEN
IF .rno==robot_master THEN
flg_master_con = FALSE
ELSE
flg_slave_con = FALSE
END
END
END
.END
.PROGRAM updatetcpinfo(.sid)
;---------------------------------------------------
;機能:TCP接続情報の初期化
;引数:SID
;戻値:なし
;---------------------------------------------------
FOR .j = 0 TO 1
IF tcp_sid[.j]==.sid THEN
IF tcp_sid_port[.j]==tcp_listen_port[0] THEN
PRINT "updateTCPInfo()->TCP_CLOSE port=",tcp_listen_port[0],",.sid=",.sid
tcp_connected[0] = FALSE
tcp_sid[0] = -1
tcp_sid_port[0] = -1
ELSE
PRINT "updateTCPInfo()->TCP_CLOSE port=",tcp_listen_port[1],",.sid=",.sid
tcp_connected[1] = FALSE
tcp_sid[1] = -1
tcp_sid_port[1] = -1
END
END
END
.END
.PROGRAM vcalib_comp(.cam_no,.ret); キャリブレーション完了
; FUNCTION: キャリブ完了処理(フレーム作成)
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
.$vsend = "CAE,"+$ENCODE(/I1,.cam_no)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション完了エラー"
.ret = 4063
END
.END
.PROGRAM vcalib_exe(.robot,.cam_no,.mes_no,.handeye,.&target,.dist,.nige,.&tool_p,.ret); キャリブレーション実行
; FUNCTION: キャリブレーション
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .cam_no  カメラ番号
;           .mes_no  計測番号
;           .handeye ハンドアイ:1, 固定:0
;           .target  ターゲット位置
;           .dist    移動距離
;           .nige    逃げ高さ
;           .tool_p  ツール位置
;           .ret     計測結果
;
.ret = err_no_error;
; ----------------------------------------------------
;   キャリブ原点はダイレクトティーチで教えておくこと
; ----------------------------------------------------
POINT vcalib_o[.cam_no] = S_HERE(.robot); ダイレクトティーチの点を原点とする
;
; ----------------------------------------------------
;   K-VFinderへキャリブレーション開始を伝える
; ----------------------------------------------------
CALL vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
IF .ret!=err_no_error GOTO end
;
; -------------------------------------------
;   原点へ移動（変換値：フランジ位置を記憶）
; -------------------------------------------
JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
JMOVE vcalib_o[.cam_no]; O計測点
BREAK
;
; ----------------------
;   原点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,1,.ret); 原点計測
IF .ret!=err_no_error GOTO end
JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
;  
; -----------------------------------------------------
;   ツールX+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
POINT vcalib_x[.cam_no] = vcalib_o[.cam_no]+TRANS(.dist); 変換値の計算(X+)
JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
JMOVE vcalib_x[.cam_no]; X+計測点
BREAK
;
; ----------------------
;   X点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,2,.ret); X点計測
IF .ret!=err_no_error GOTO end
JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
;
; -----------------------------------------------------
;   ツールY+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
POINT vcalib_y[.cam_no] = vcalib_o[.cam_no]+TRANS(,.dist); 変換値の計算(Y+)
JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
JMOVE vcalib_y[.cam_no]; Y+計測点
BREAK
;
; ----------------------
;   Y点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,3,.ret); Y点計測
IF .ret!=err_no_error GOTO end
JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
;
; ---------------------------------------------------------------
;   K-VFinderにキャリブレーション完了を伝え、フレームを作成する
; ---------------------------------------------------------------
CALL vcalib_comp(.cam_no,.ret); キャリブレーション完了
IF .ret!=err_no_error GOTO end
;
IF .handeye==OFF THEN
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
ELSE
; ----------------------------------------------------------------------------------------------
;   カメラツール位置の生成(ハンドアイ）
; ----------------------------------------------------------------------------------------------
POINT vcalh[.cam_no] = .target
POINT .v = vcalh[.cam_no]+.tool_p; ツール込みでのターゲット位置
POINT vcam_o[.cam_no] = -vcalib_o[.cam_no]+.v
POINT vcam_x[.cam_no] = -vcalib_x[.cam_no]+.v
POINT vcam_y[.cam_no] = -vcalib_y[.cam_no]+.v
POINT vcam_tool[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]);
END
;
end:
;
.END
.PROGRAM vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
; FUNCTION: キャリブ開始処理
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
.$vsend = "CAS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+","+$ENCODE(/F5.2,.dist)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション開始エラー"
.ret = 4061;
END
.END
.PROGRAM vcalib_vis(.cam_no,.count,.ret); キャリブレーション計測
; FUNCTION: キャリブ計測処理
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
.$vsend = "CAL,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I1,.count)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション計測エラー"
.ret = 4062;
END
.END
.PROGRAM vchk_pc_start(.res,.task_no)
; FUNCTION: ＰＣプログラム起動確認
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF TASK(.task_no)==1 GOTO next
TWAIT ascycle;                           ＰＣプログラム起動待ち
UNTIL UTIMER(.@vtime)>=vpc_start_time;     タイムアウトするまで
next:
DO;                                        条件ループ開始
IF SIG(-ix_pc_start) GOTO end
TWAIT ascycle;                           ＰＣプログラム起動確認信号ＯＦＦ待ち
UNTIL UTIMER(.@vtime)>=vpc_start_time;     タイムアウトするまで
.res = -1
end:
.END
.PROGRAM vchk_sig_change(.res,.sig_no,.timeout)
; FUNCTION: タイムアウト付き信号状態変更待ち
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(.sig_no) GOTO end
TWAIT ascycle;                           信号の状態変更待ち
UNTIL UTIMER(.@vtime)>=.timeout;           タイムアウトするまで
.res = -1
end:
.END
.PROGRAM vcom_init(); ビジョン変数初期化
; FUNCTION: ビジョン変数初期化
; NOTE    : ver1.0.0[15/10/02]
; ---------------------------------------------------
;   変数定義されていない場合のみパラメータを設定する
;   変更したい場合は変数を直接変更する
; ---------------------------------------------------
;
NOEXIST_SET_R vlog = 1;                                  ログ保存モード[0:保存なし,1:エラーログ保存,2:全ログ保存]
NOEXIST_SET_R vlog_max = 1000;                           ログ最大数
FOR .i = 1 TO 2
NOEXIST_SET_R vlog_cnt[.i] = 1;                        ログカウンタ
END
;
NOEXIST_SET_R ascycle = 0.016;                           ASサイクル待ち時間
NOEXIST_SET_R vsend_port = 50003;                        送信ポート番号
NOEXIST_SET_R vrecv_port = 50002;                        受信ポート番号
NOEXIST_SET_R vsend_ip[0] = 192;                         送信先IPアドレス
NOEXIST_SET_R vsend_ip[1] = 168
NOEXIST_SET_R vsend_ip[2] = 0
NOEXIST_SET_R vsend_ip[3] = 10
NOEXIST_SET_R vsend_num = 1;                             送信文字列数
NOEXIST_SET_R vrecv_str_num = 32;                        受信文字列長
NOEXIST_SET_R vsend_timeout = 0.5;                       送信タイムアウト時間(sec)
NOEXIST_SET_R vrecv_timeout = 1;                         受信タイムアウト時間(sec)
NOEXIST_SET_R ix_vcomm_start = 2101;                     通信開始信号
NOEXIST_SET_R ix_vcomm_busy = 2102;                      通信中信号
NOEXIST_SET_R ix_vcomm_comp = 2103;                      通信完了信号
NOEXIST_SET_R ix_vcomm_error = 2104;                     通信エラー信号
NOEXIST_SET_R ix_vrecv_start = 2105;                     受信開始信号
NOEXIST_SET_R ix_vrecv_comp = 2106;                      受信完了信号
NOEXIST_SET_R ix_pc_start = 2107;                        ＰＣプログラム起動確認信号
NOEXIST_SET_R ix_vsend_only = 2108;                      通信時送信のみ(受信なし)信号
NOEXIST_SET_R ix_vrecv_only = 2109;                      通信時受信のみ(送信なし)信号
NOEXIST_SET_R vpc_start_time = 1;                        ＰＣプログラム起動待ちタイムアウト(sec)
NOEXIST_SET_R vhandshake_time = 0.5;                     ハンドシェイクタイムアウト(sec)
NOEXIST_SET_R vretry_max = 1;                            リトライ回数
NOEXIST_SET_R vretry_wait = 0.2;                         リトライ前の待ち時間(sec)
NOEXIST_SET_R verr_ok = 0;                               通信結果(ＯＫ, "0"以外はＮＧ)
NOEXIST_SET_R verr_onlymode = 88;                        通信結果(片方向通信モードエラー)
NOEXIST_SET_R verr_unknown = 89;                         通信結果(不明なエラー)
NOEXIST_SET_R verr_init = 90;                            通信結果(初期値, 未計測)
NOEXIST_SET_R verr_send = 91;                            通信結果(送信エラー)
NOEXIST_SET_R verr_recv = 92;                            通信結果(受信エラー)
NOEXIST_SET_R verr_timeout1 = 93;                        通信結果(受信開始待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout2 = 94;                        通信結果(受信完了待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout3 = 95;                        通信結果(受信ＰＧ起動待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout4 = 96;                        通信結果(送信ＰＧ起動待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout5 = 97;                        通信結果(通信完了(実行中)待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout6 = 98;                        通信結果(送信ＰＧ実行待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout7 = 99;                        通信結果(通信完了待ちタイムアウトエラー)
NOEXIST_SET_R vis_init = -99999;                         検出結果初期値
NOEXIST_SET_R vis_err_vid = 2;                           検出結果(K-VFinderのエラーコード[2:画像取込エラー])
NOEXIST_SET_R vis_err_num = 6;                           検出結果(K-VFinderのエラーコード[6:検出個数0個エラー])
.END
.PROGRAM vcommand(.$command); ビジョンコマンド送信
; FUNCTION: ビジョンコマンド送信[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vget_resultと合わせて使用する
; --------------------------------
;
IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
CALL vcom_init;                          ビジョン変数初期化
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
HALT;                                  停止(送信ＰＧ起動待ちタイムアウトエラー)
END
END
SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
HALT;                                      停止(通信完了待ちタイムアウトエラー)
start:
$vsend_data[0] = .$command;送信データ作成
CALL vinit;                                計測結果クリア
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
IF .chk!=0 THEN
CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
HALT;                                    停止(送信ＰＧ実行待ちタイムアウトエラー)
END
.END
.PROGRAM vcorrect(.&base_pos,.id2,.id3,.&adj_pos); 補正位置作成
; FUNCTION: 補正位置作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: 補正前の教示位置,ビジョンID2,ビジョンID3,補正後の教示位置(返却値)
;           ビジョンID2,3はタブレットに準拠
;
IF .id2<>0 AND .id3<>0 THEN; id2とid3両方にIDが割り振られていた場合(固定カメラ把持ワーク(id2)＋ハンドアイカメラ置きワーク(id3))
.result2 = vwork_res[.id2,1]; 結果番号(固定)
.result3 = vwork_res[.id3,1]; 結果番号(ハンドアイ)
;
POINT .have_m = .base_pos+v_master[.id2,.result2]; ティーチ位置でベースから見たマスターワーク把持位置
POINT .rslt_m = -v_master[.id3,.result3]+.have_m; マスターハンドアイ計測結果から見たマスターワーク把持位置
;
POINT .valfa = vwork[.id3,.result3]+.rslt_m; 現在ハンドアイ計測結果から見たマスターワーク把持位置
POINT .adj_pos = .valfa-vwork[.id2,.result2]; 現在ワーク位置に対するロボット位置(ツール先端)
ELSE
IF .id2==0 THEN
.id = .id3; id3だけIDが割り振られていた場合
ELSE
.id = .id2; id2だけIDが割り振られていた場合
END
;
.result = vwork_res[.id,1];   結果番号
IF vc_handeye[.id]<>OFF THEN; ハンドアイフラグ(ハンドアイ:1, 固定:0)
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; ハンドアイカメラ・把持あり
POINT .valfa = v_master[.id,.result]-vwork[.id,1]; マスターと現在のワーク位置差分
POINT .adj_pos = .base_pos+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
ELSE
; ハンドアイカメラ・把持なし
POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
ELSE
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; 固定カメラ・把持あり
POINT .valfa = .base_pos+v_master[.id,.result]; ティーチ位置でベースから見たマスターワーク把持位置
POINT .adj_pos = .valfa-vwork[.id,1]; 現在ワーク位置に対するロボット位置(ツール先端)
ELSE
; 固定カメラ・把持なし
POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
END
END
.END
.PROGRAM vcorrect_table(.&base_pos,.id,.&adj_pos); 装置間補正
; FUNCTION: 装置間補正
; NOTE    : ver1.0.0[15/10/02]
;
; 1点目と2点目の装置IDを取得
CALL convert_vid(mode_add,1,.id,.equip_id1)
CALL convert_vid(mode_add,2,.id,.equip_id2)
;
POINT vtable_m = FRAME(v_master[.equip_id1,1],v_master[.equip_id2,1],TRANS(,,100)+v_master[.equip_id1,1],v_master[.equip_id1,1])
POINT vtable_m = vtable_m+RX(-90); マスター穴で作成したフレーム
;
POINT/Z vwork[.equip_id1,1] = v_master[.equip_id1,1]
POINT/Z vwork[.equip_id2,1] = v_master[.equip_id2,1]
POINT vtable_w = FRAME(vwork[.equip_id1,1],vwork[.equip_id2,1],TRANS(,,100)+vwork[.equip_id1,1],vwork[.equip_id1,1])
POINT vtable_w = vtable_w+RX(-90); 現在の穴で作成したフレーム
;
POINT .valfa = -vtable_m+.base_pos; マスターフレームから見た教示位置
POINT .adj_pos = vtable_w+.valfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
.a = DEXT(.adj_pos,4)
.t = DEXT(.adj_pos,6)
POINT/OAT .adj_pos = TRANS(,,,.a+.t,,0)
;
.END
.PROGRAM vget_result(); ビジョン結果取得
; FUNCTION: ビジョン結果取得
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vcommandと合わせて使用する
; --------------------------------
;
v.error_cnt = 0;                           エラーカウント初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
start:
DO;                                        条件ループ開始
IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
GOTO end
check:
IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
CALL vstr_decode($vrecv_data[0]);        文字列分解
$vres = $vst[0];                         計測結果代入
SCASE $vres OF
SVALUE "OK":;                           ビジョン結果ＯＫ
v.err = verr_ok
SVALUE "NG":;                           ビジョン計測ＮＧ
v.err = VAL($vst[1]);                  エラーコード取得
PRINT /X2,"ビジョンＮＧ : v.err = ",v.err
SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
ANY :;                                  不明なＮＧ
CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
END
ELSE;                                      通信ＮＧ
$vres = $vcom_res
v.err = v.com_err
END
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vinit()
; FUNCTION: ビジョン計測結果クリア
; NOTE    : ver1.0.0[12/10/18]
$vres = ""
v.err = verr_init;                         計測結果クリア[90:未計測, 0:OK, 0<>:NG]
v.num = 0;                                 検出個数クリア
POINT vision[1] = TRANS(vis_init,vis_init);検出結果クリア
POINT vpos[1] = vision[1]
.END
.PROGRAM vision(.cam_no,.mes_no); ビジョン計測
; FUNCTION: ビジョン計測[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: カメラ番号, 計測番号
;
IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
CALL vcom_init;                          ビジョン変数初期化
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
HALT;                                  停止(送信ＰＧ起動待ちタイムアウトエラー)
END
END
SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
HALT;                                      停止(通信完了待ちタイムアウトエラー)
start:
$vsend_data[0] = "VIS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+",";送信データ作成
v.cam_no = .cam_no;                        カメラ番号代入
v.mes_no = .mes_no;                        計測番号代入
CALL vinit;                                計測結果クリア
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
IF .chk!=0 THEN
CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
HALT;                                    停止(送信ＰＧ実行待ちタイムアウトエラー)
END
.END
.PROGRAM vision_exe(.cam_no,.mes_no,.robot,.handeye,.have,.teach,.id,.calpos,.ret); ビジョン計測プログラム
; FUNCTION: ビジョン計測プログラム
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .cam_no  カメラ番号
;           .mes_no  計測番号
;           .robot   ロボット番号 下アーム:1, 上アーム:2
;           .handeye ハンドアイ:1, 固定:0
;           .have    把持あり:0, 把持なし:1
;           .teach   ティーチング用計測:1, 通常計測:0
;           .id      ビジョンID
;           .calpos  位置補正用計測:0, 装置補正1点目:1, 装置補正2点目:2
;           .ret     計測結果
;
; ---------------------------------------------------------------------------------------
;   ※ビジョン計測プログラム実行条件（ロボット計測位置）
;   // 固定カメラ・把持なし      ：固定カメラ視野内にロボットがいないこと
;   // 固定カメラ・把持あり      ：把持ワークがカメラ視野内に写っている位置
;   // ハンドアイカメラ・把持なし：カメラ視野内にワークが写る位置
;   // ハンドアイカメラ・把持あり：位置不問・ワークを把持して視野内にワークがあること
; ---------------------------------------------------------------------------------------
;
.ret = err_no_error
; ------------
;   計測実施
; ------------
.vid = .id
CALL vision(.cam_no,.mes_no);                     ビジョン計測
CALL vset_pos(.robot,.handeye,.have,.teach,.vid); 計測完了待兼補正位置作成
IF v.err<>0 THEN; 計測結果チェック
PRINT /X2,"ビジョン計測エラー"
.ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
RETURN; ビジョン計測エラー
END
;
IF .teach<>OFF THEN
; -----------------------------
;   ティーチ時はマスター登録
; -----------------------------
IF v.num<>1 THEN
PRINT /X2,"計測個数が複数あります"
.ret = 4020; マスター登録時複数認識
RETURN; ビジョン計測エラー
END
;
; ------------------------------
;   計測位置（フランジ）を記憶
; ------------------------------
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT vis_point[.cam_no,.mes_no] = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
;
; ---------------------------------------
;   1個目の計測結果をマスターとして登録
; ---------------------------------------
.res_no = v.result_no[1]; 結果番号
;
IF .handeye<>OFF THEN
IF .have==OFF THEN
; ハンドアイカメラ・把持あり
POINT v_master[.vid,.res_no] = vcam_tool[.cam_no]+vision[1]; フランジから見たワーク位置
ELSE
; ハンドアイカメラ・把持なし
POINT v_master[.vid,.res_no] = vis_point[.cam_no,.mes_no]+vcam_tool[.cam_no]+vision[1]; ベースから見たワーク位置
END
ELSE
IF .have==OFF THEN
; 固定カメラ・把持あり
POINT v_master[.vid,.res_no] = -vis_point[.cam_no,.mes_no]+vision_frm[.cam_no]+vision[1]; フランジから見たワーク把持位置
ELSE
; 固定カメラ・把持なし
POINT v_master[.vid,.res_no] = vision_frm[.cam_no]+vision[1]; ベースから見たワーク位置
END
END
;
; --------------------
;   補正番号に紐付け
; --------------------
vc_cam[.vid] = .cam_no
vc_mes[.vid] = .mes_no
vc_rob[.vid] = .robot
vc_handeye[.vid] = .handeye
vc_have[.vid] = .have
ELSE
; 装置補正用計測実行フラグ
IF .calpos==1 THEN
vequip_flg[.id] = ON
ELSE
IF .calpos==2 THEN
vequip_flg[.id] = ON
END
END
END
;
.END
.PROGRAM vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;引数：ロボット番号、カメラ番号、計測番号、カメラ種類、ターゲット位置(XYZR1)、移動距離、移動前逃げ高さ、ツール(XY)
;　　※引数が多すぎ、もしくは文字列長過ぎてエラーになるため配列で受け取り(11個上限？)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .calno=",.calno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camtype=",.camtype
DECOMPOSE .buf1[1] = .target
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_x=",.buf1[1]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_y=",.buf1[2]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_z=",.buf1[3]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_o(r1)=",.buf1[4]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_a=",.buf1[5]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_t=",.buf1[6]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .len=",.len
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .height=",.height
DECOMPOSE .buf2[1] = .tool_p
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_x=",.buf2[1]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_y=",.buf2[2]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_z=",.buf2[3]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_o=",.buf2[4]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_a=",.buf2[5]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_t=",.buf2[6]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .ret=",.ret
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)==2 THEN
TWAIT 2
RETURN
END
; calib実行
CALL vcalib_exe(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
.END
.PROGRAM vision_main(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
;-------------------------------- 
;機能：ビジョン実行
;引数：ロボット番号、ビジョンID、カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、マスター登録フラグ
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "vision_main()->.rno=",.rno
PRINT "vision_main()->.id=",.id
PRINT "vision_main()->.camno=",.camno
PRINT "vision_main()->.calno=",.calno
PRINT "vision_main()->.camtype=",.camtype
PRINT "vision_main()->.holdtype=",.holdtype
PRINT "vision_main()->.calpos=",.calpos
PRINT "vision_main()->.recflg=",.recflg
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)==2 THEN
POINT vision_shift[.rno,.id] = TRANS(0,0,0,0,0,0)
RETURN
END
CALL vision_exe(.camno,.calno,.rno,.camtype,.holdtype,.recflg,.id,.calpos,.ret)
IF .recflg==OFF THEN
POINT vision_shift[.rno,.id] = -v_master[.id,1]+vwork[.id,1]
ELSE
;マスター登録時はシフト量0
POINT vision_shift[.rno,.id] = TRANS(0,0,0,0,0,0)
END
DECOMPOSE .buf[1] = vision_shift[.rno,.id]
IF debug.prt.visio==TRUE THEN
PRINT "vision_main()->XYR1(TRANS)=",$ENCODE(.buf[1]),",",$ENCODE(.buf[2]),",",$ENCODE(.buf[3]),",",$ENCODE(.buf[4]),",",$ENCODE(.buf[5]),",",$ENCODE(.buf[6])
END
.END
.PROGRAM vset_error(.err,.$res,.$print)
; FUNCTION: エラーコード＆内容セット
; NOTE    : ver1.0.0[13/02/08]
v.err = .err
$vres = .$res
PRINT /X2,.$print;                         エラー内容表示
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM vset_pos(.robot,.handeye,.have,.teach,.id)
; FUNCTION: 補正位置データ作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .teach ティーチ時 -1, その他 -1以外
;
v.error_cnt = 0;                           エラーカウント初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
start:
DO;                                        条件ループ開始
IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
GOTO end
check:
IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
CALL vstr_decode($vrecv_data[0]);        文字列分解
$vres = $vst[0];                         計測結果代入
SCASE $vres OF
SVALUE "OK":;                           ビジョン計測ＯＫ
v.err = verr_ok
GOTO ok
SVALUE "NG":;                           ビジョン計測ＮＧ
v.err = VAL($vst[1]);                  エラーコード取得
PRINT /X2,"ビジョン計測ＮＧ : v.err = ",v.err
IF v.err==vis_err_vid OR v.err==vis_err_num GOTO ng;K-VFinderのエラーコード[2:画像取込エラー, 6:検出個数0個エラー]
SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
ANY :;                                  不明なＮＧ
CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
END
GOTO end
ok:; 計測ＯＫの場合補正データ作成
v.num = VAL($vst[1]);                    検出個数取得
IF v.num>0 THEN
FOR .i = 1 TO v.num;                     検出個数分繰り返す
CALL vstr_decode($vrecv_data[.i]);   文字列分解
.vres_no = VAL($vst[0]);             結果番号
.vpos_x = VAL($vst[1]);              Ｘ座標
.vpos_y = VAL($vst[2]);              Ｙ座標
.vpos_t = 0
.vpos_t = VAL($vst[3]);              θ
v.result_no[.i] = .vres_no;          結果番号代入
POINT vision[.i] = TRANS(.vpos_x,.vpos_y,0,.vpos_t); ビジョン座標値(mm)
;
IF .teach==OFF THEN;                 補正位置計算
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT .h = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
IF .handeye<>OFF THEN
IF .have==OFF THEN
POINT vwork[.id,.i] = vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持あり・フランジから見たワーク位置
ELSE
POINT vwork[.id,.i] = .h+vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持なし・ベースから見たワーク位置
END
ELSE
IF .have==OFF THEN
POINT vwork[.id,.i] = -.h+vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持あり・フランジから見たワーク把持位置
ELSE
POINT vwork[.id,.i] = vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持なし・ベースから見たワーク位置
END
END
vwork_res[.id,.i] = v.result_no[.i]; 結果番号
END
END
END
ELSE;                                      通信ＮＧ
$vres = $vcom_res
v.err = v.com_err
END
GOTO end
ng:; 計測ＮＧ[v.err=2(画像取込エラー) or v.err=6(検出個数0個エラー)]の場合リトライ処理
v.error_cnt = v.error_cnt+1;               送受信エラーカウントアップ
IF v.error_cnt>=vretry_max+1 THEN;         エラー回数確認
PRINT /X2,"リトライ回数上限エラー"
SIGNAL ix_vcomm_error;                   エラー信号ＯＮ
GOTO end;                                リトライ回数上限超えの為終了
ELSE
PRINT /X2,"計測リトライ : "+$ENCODE(/I2,v.error_cnt)+" 回目"
SIGNAL -ix_vcomm_comp;                   通信完了信号ＯＦＦ
TWAIT vretry_wait;                       リトライ前待ち
SIGNAL ix_vcomm_start;                   通信開始信号ＯＮ
GOTO start;                              通信完了待ち
END
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vstr_decode(.$data)
; FUNCTION: 文字列データ分解(区切り文字 [,])
; NOTE    : ver1.0.0[12/10/18]
.$strings = .$data;                        文字列データ代入
IF .$strings=="" GOTO end;                 文字列データが無い為終了
.i = 0;                                    分解した個数クリア
DO;                                        条件ループ開始
$vst[.i] = $DECODE(.$strings,",",0);     ","までの文字列を取り出す
IF .$strings=="" GOTO end;               文字列データが無くなれば終了
.$temp = $DECODE(.$strings,",",1);       ","を取り出す
.i = .i+1;                               分解した個数カウントアップ
UNTIL .$strings=="";                       文字列データが無くなるまで
end:
vdecode_num = .i;                          分解した個数代入
.END
.PROGRAM wait_chg_sp(.rno,.sp,.ret)
;-------------------------------- 
;機能：速度変更確認
;引数：ロボット番号、動作速度(.sp)
;戻値：成否(±1%以内で成功)
;-------------------------------- 
.ret = err_no_error
UTIMER .@nowtime = 0
WHILE (1) DO
IF .rno==robot_slave THEN
IF debug.prt.cmd==TRUE THEN
PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED2),"---->TARGET_SP=",$ENCODE(.sp)
END
IF MSPEED2>.sp-1 AND MSPEED2<.sp+1 THEN
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED),"---->TARGET_SP=",$ENCODE(.sp)
END
IF MSPEED>.sp-1 AND MSPEED<.sp+1 THEN
RETURN
END
END
IF UTIMER(.@nowtime)>0.1 THEN
.ret = err_chg_sp
RETURN
END
END
.END
.TRANS
def_tool[1,1] 360.000000 400.000000 0.000000 0.000000 0.000000 0.000000
def_tool[1,2] 360.000000 400.000000 0.000000 0.000000 0.000000 0.000000
def_tool[2,1] 360.000000 400.000000 0.000000 0.000000 0.000000 0.000000
def_tool[2,2] 360.000000 400.000000 0.000000 0.000000 0.000000 0.000000
.END
.REALS
ascycle = 0.016
boot_timeout = 10
cmd_exe_abort = 1506
cmd_exe_con = 1601
cmd_exe_gen = 1502
cmd_exe_gravity = 1517
cmd_exe_hand = 1513
cmd_exe_hold = 1505
cmd_exe_io = 1508
cmd_exe_l2exe = 1512
cmd_exe_monsp = 1511
cmd_exe_move = 1507
cmd_exe_one = 1602
cmd_exe_reset = 1501
cmd_exe_resetio = 1514
cmd_exe_restart = 1509
cmd_exe_robotmo = 1516
cmd_exe_start = 1504
cmd_exe_teach = 1503
cmd_exe_vision = 1510
cmd_exe_vscalib = 1518
cmd_exe_waitend = 1515
cmd_exec_type[1001] = 0
cmd_exec_type[1002] = 0
cmd_exec_type[1003] = 0
cmd_exec_type[1004] = 0
cmd_exec_type[1005] = 0
cmd_exec_type[1006] = 0
cmd_exec_type[1007] = 0
cmd_exec_type[1008] = 0
cmd_exec_type[1009] = 0
cmd_exec_type[1010] = 0
cmd_exec_type[1011] = 0
cmd_exec_type[1012] = 0
cmd_exec_type[1013] = 0
cmd_exec_type[1014] = 0
cmd_exec_type[1015] = 0
cmd_exec_type[1016] = 0
cmd_exec_type[1017] = 0
cmd_exec_type[1018] = 0
cmd_exec_type[1019] = 0
cmd_exec_type[1020] = 0
cmd_exec_type[1021] = 0
cmd_exec_type[1022] = 0
cmd_exec_type[1023] = 0
cmd_exec_type[1024] = 0
cmd_exec_type[1025] = 0
cmd_exec_type[1026] = 0
cmd_exec_type[1027] = 0
cmd_exec_type[1028] = 0
cmd_exec_type[1029] = 0
cmd_exec_type[1030] = 0
cmd_exec_type[1031] = 0
cmd_exec_type[1101] = 0
cmd_exec_type[1102] = 0
cmd_exec_type[1103] = 0
cmd_exec_type[1104] = 0
cmd_exec_type[1105] = 0
cmd_exec_type[1106] = 0
cmd_exec_type[1107] = 0
cmd_exec_type[1108] = 0
cmd_exec_type[1109] = 0
cmd_exec_type[1110] = 0
cmd_exec_type[1111] = 0
cmd_exec_type[1112] = 0
cmd_exec_type[1113] = 0
cmd_exec_type[1114] = 0
cmd_exec_type[1115] = 0
cmd_exec_type[1116] = 0
cmd_exec_type[1117] = 0
cmd_exec_type[1118] = 0
cmd_exec_type[1119] = 0
cmd_exec_type[1120] = 0
cmd_exec_type[1201] = 0
cmd_exec_type[1202] = 0
cmd_exec_type[1203] = 0
cmd_exec_type[1301] = 0
cmd_exec_type[1302] = 0
cmd_exec_type[1401] = 0
cmd_exec_type[1402] = 0
cmd_exec_type[1501] = 1
cmd_exec_type[1502] = 1
cmd_exec_type[1503] = 1
cmd_exec_type[1504] = 1
cmd_exec_type[1505] = 0
cmd_exec_type[1506] = 0
cmd_exec_type[1507] = 1
cmd_exec_type[1508] = 0
cmd_exec_type[1509] = 0
cmd_exec_type[1510] = 0
cmd_exec_type[1511] = 0
cmd_exec_type[1512] = 1
cmd_exec_type[1513] = 0
cmd_exec_type[1514] = 0
cmd_exec_type[1515] = 0
cmd_exec_type[1516] = 0
cmd_exec_type[1517] = 1
cmd_exec_type[1518] = 1
cmd_exec_type[1601] = 1
cmd_exec_type[1602] = 1
cmd_get_colchkm = 1027
cmd_get_cord = 1007
cmd_get_gravity = 1026
cmd_get_hand = 1018
cmd_get_handio = 1019
cmd_get_home = 1012
cmd_get_ifconnu = 1030
cmd_get_iftbl = 1031
cmd_get_iftblnu = 1029
cmd_get_info = 1001
cmd_get_infoex = 1017
cmd_get_io = 1011
cmd_get_l1info = 1002
cmd_get_l2exetb = 1016
cmd_get_l2info = 1003
cmd_get_l3info = 1004
cmd_get_lowspar = 1024
cmd_get_lowspse = 1025
cmd_get_monsp = 1015
cmd_get_pitch = 1006
cmd_get_pos = 1010
cmd_get_robotmo = 1023
cmd_get_signame = 1013
cmd_get_signum = 1014
cmd_get_slowlim = 1028
cmd_get_sp = 1005
cmd_get_step = 1301
cmd_get_steppos = 1302
cmd_get_tnum = 1008
cmd_get_tool = 1009
cmd_get_vresult = 1022
cmd_get_vtb = 1020
cmd_get_vtbnum = 1021
cmd_set_colchkm = 1116
cmd_set_cord = 1103
cmd_set_handio = 1110
cmd_set_home = 1106
cmd_set_ifconnu = 1119
cmd_set_iftbl = 1120
cmd_set_iftblnu = 1118
cmd_set_l1info = 1201
cmd_set_l2exetb = 1109
cmd_set_l2info = 1202
cmd_set_l3info = 1203
cmd_set_lowspar = 1113
cmd_set_lowspse = 1114
cmd_set_pitch = 1102
cmd_set_signame = 1107
cmd_set_signum = 1108
cmd_set_slowlim = 1117
cmd_set_sp = 1101
cmd_set_step = 1401
cmd_set_steppos = 1402
cmd_set_tnum = 1104
cmd_set_tool = 1105
cmd_set_vtb = 1111
cmd_set_vtbnum = 1112
cmd_set_zeroing = 1115
cmd_type_monpg = 1
cmd_type_no_wai = 0
cmd_type_pcpg = 0
cmd_type_wait = 1
cmd_wait_type[1001] = 1
cmd_wait_type[1002] = 1
cmd_wait_type[1003] = 1
cmd_wait_type[1004] = 1
cmd_wait_type[1005] = 1
cmd_wait_type[1006] = 1
cmd_wait_type[1007] = 1
cmd_wait_type[1008] = 1
cmd_wait_type[1009] = 1
cmd_wait_type[1010] = 1
cmd_wait_type[1011] = 1
cmd_wait_type[1012] = 1
cmd_wait_type[1013] = 1
cmd_wait_type[1014] = 1
cmd_wait_type[1015] = 1
cmd_wait_type[1016] = 1
cmd_wait_type[1017] = 1
cmd_wait_type[1018] = 1
cmd_wait_type[1019] = 1
cmd_wait_type[1020] = 1
cmd_wait_type[1021] = 1
cmd_wait_type[1022] = 1
cmd_wait_type[1023] = 1
cmd_wait_type[1024] = 1
cmd_wait_type[1025] = 1
cmd_wait_type[1026] = 1
cmd_wait_type[1027] = 1
cmd_wait_type[1028] = 1
cmd_wait_type[1029] = 1
cmd_wait_type[1030] = 1
cmd_wait_type[1031] = 1
cmd_wait_type[1101] = 1
cmd_wait_type[1102] = 1
cmd_wait_type[1103] = 1
cmd_wait_type[1104] = 1
cmd_wait_type[1105] = 1
cmd_wait_type[1106] = 1
cmd_wait_type[1107] = 1
cmd_wait_type[1108] = 1
cmd_wait_type[1109] = 1
cmd_wait_type[1110] = 1
cmd_wait_type[1111] = 1
cmd_wait_type[1112] = 1
cmd_wait_type[1113] = 1
cmd_wait_type[1114] = 1
cmd_wait_type[1115] = 1
cmd_wait_type[1116] = 1
cmd_wait_type[1117] = 1
cmd_wait_type[1118] = 1
cmd_wait_type[1119] = 1
cmd_wait_type[1120] = 1
cmd_wait_type[1201] = 1
cmd_wait_type[1202] = 1
cmd_wait_type[1203] = 1
cmd_wait_type[1301] = 1
cmd_wait_type[1302] = 1
cmd_wait_type[1401] = 1
cmd_wait_type[1402] = 1
cmd_wait_type[1501] = 1
cmd_wait_type[1502] = 0
cmd_wait_type[1503] = 0
cmd_wait_type[1504] = 0
cmd_wait_type[1505] = 1
cmd_wait_type[1506] = 1
cmd_wait_type[1507] = 0
cmd_wait_type[1508] = 1
cmd_wait_type[1509] = 1
cmd_wait_type[1510] = 1
cmd_wait_type[1511] = 0
cmd_wait_type[1512] = 0
cmd_wait_type[1513] = 1
cmd_wait_type[1514] = 0
cmd_wait_type[1515] = 1
cmd_wait_type[1516] = 1
cmd_wait_type[1517] = 0
cmd_wait_type[1518] = 0
cmd_wait_type[1601] = 0
cmd_wait_type[1602] = 0
data_acc = 100
data_cur_l2disp = 0
data_cur_l2rec[1] = 0
data_cur_l2rec[2] = 0
data_cur_l3disp = 0
data_cur_l3rec[1] = 0
data_cur_l3rec[2] = 0
data_dec = 100
data_execute = 0
data_exttype[0] = 0
data_exttype[1] = 0
data_exttype[2] = 0
data_hand_cur[1] = 0
data_hand_cur[2] = 0
data_hand_io[1,1] = 49
data_hand_io[1,2] = 50
data_hand_io[1,3] = 0
data_hand_io[1,4] = 0
data_hand_io[2,1] = 65
data_hand_io[2,2] = 66
data_hand_io[2,3] = 0
data_hand_io[2,4] = 0
data_hand_type[1] = 1
data_hand_type[2] = 1
data_io_tablenu = 0
data_l2num = 0
data_monspeed[0] = 100
data_monspeed[1] = 100
data_monspeed[2] = 100
data_teachcoord = 0
data_teachpitch = 5
data_teachrot = 5
data_toolcur[1] = 1
data_toolcur[2] = 1
data_vs_tbnum = 3
debug.prt.act = 0
debug.prt.cmd = 0
debug.prt.com = 0
debug.prt.core = 0
debug.prt.extio = 0
debug.prt.func = 0
debug.prt.gen = 0
debug.prt.l2exe = 0
debug.prt.main = 0
debug.prt.move = 0
debug.prt.pos = 0
debug.prt.proc = 0
debug.prt.reboo = 0
debug.prt.sock = 0
debug.prt.sub = 0
debug.prt.visio = 0
disable_avetool = 0
disable_continu = 0
disable_l2chk = 0
disable_readj_p = -1
disable_wcmd = 0
err_bad_areano = 2010
err_bad_axesno = 2009
err_bad_handio = 3016
err_bad_homeno = 3014
err_bad_l3type = 3007
err_bad_mode = 3003
err_bad_name = 3005
err_bad_num = 3006
err_bad_positio = 2011
err_bad_ptype = 3004
err_bad_rno = 3008
err_bad_signo = 3013
err_bad_speed = 3015
err_bad_tableno = 3014
err_bad_visionn = 3020
err_cant_conver = 2000
err_chg_sp = 3019
err_cmd_prmnum = 3001
err_cmd_timeout = 3009
err_cmd_type = 3000
err_cs_off = 1012
err_direct_teac = 3017
err_emg_on = 2004
err_exe_name = 2003
err_extio_disab = 1017
err_gravityadj = 2012
err_l3_actend = 5002
err_main_stop = 1014
err_motor_off = 1011
err_no_error = 0
err_pccom_start = 1007
err_poweron = 1001
err_repeat = 1003
err_robot_busy = 1000
err_robot_cmon = 3018
err_roboterror[0] = 1020
err_roboterror[1] = 1021
err_roboterror[2] = 1022
err_robotmode = 1015
err_sig_timeout = 2002
err_slave_acten = 5001
err_srobot_erro = 3011
err_srobot_time = 3010
err_still_worki = 3021
err_teach_lock = 1002
err_vis_cam = 4002
err_vis_cmd = 4001
err_vis_lesspos = 4050
err_vis_measure = 4004
err_vis_nocalib = 4005
err_vis_recog0 = 4006
err_vis_recv = 4092
err_vis_send = 4091
err_vis_setting = 4003
err_vis_tout1 = 4093
err_vis_tout2 = 4094
err_vis_tout3 = 4095
err_vis_tout4 = 4096
err_vis_tout5 = 4097
err_vis_tout6 = 4098
err_vis_tout7 = 4099
exout_start_fla = 0
exout_stop_flas = 0
extin_repeat_tg = 2020
extin_start_but = 2017
extin_stop_butt = 2018
extin_teach_tgl = 2019
extout_flashtim = 0.5
extout_start_bu = 17
extout_stop_but = 18
exttype_linear = 2
exttype_none = 0
exttype_rot = 1
flg_direct_run = 0
flg_enable_colc = 0
flg_exec_first_ = -1
flg_gravityadj_ = 0
flg_main_run = 0
flg_master_con = 0
flg_master_move = 0
flg_req_mamode = 0
flg_slave_con = 0
flg_slave_move = 0
flg_slave_paral = 0
flg_slave_rdy = 0
flg_slowlimit = 0
flg_start_killp = 0
flg_start_reboo = -1
g_last_error = 0
hand_close = 0
hand_double = 1
hand_open = 1
hand_single = 0
ifcon_cnt = 1
ifcon_flg = 3
ifcon_io = 2
ineq_sign_eq = 5
ineq_sign_gt = 1
ineq_sign_gteq = 3
ineq_sign_lt = 2
ineq_sign_lteq = 4
io_di = 1
io_do = 0
io_int = 2
io_unknown = 3
ip[0] = 0
ip[1] = 0
ip[2] = 0
ip[3] = 0
kroset = 0;K-ROSET
ix_cycle_time = 2001
l3type_calvisio = 10
l3type_cend = 4
l3type_cntset = 16
l3type_cntup = 15
l3type_colchk = 11
l3type_cstart = 3
l3type_hand_cha = 9
l3type_ifgoto = 13
l3type_iflabel = 14
l3type_io_chang = 1
l3type_io_wait = 0
l3type_l2reset = 8
l3type_move = 2
l3type_return = 12
l3type_vision = 5
l3type_wend = 7
l3type_wstart = 6
master_timeout = 10
max_cntnum = 10
max_visionid_nu = 1000
mfp_param1 = 0
mfp_param10 = 0
mfp_param11 = 0
mfp_param12 = 0
mfp_param13 = 0
mfp_param14 = 0
mfp_param15 = 0
mfp_param16 = 0
mfp_param17 = 0
mfp_param18 = 0
mfp_param19 = 0
mfp_param2 = 0
mfp_param20 = 0
mfp_param3 = 0
mfp_param4 = 0
mfp_param5 = 0
mfp_param6 = 0
mfp_param7 = 0
mfp_param8 = 0
mfp_param9 = 0
mode_add = 0
mode_base = 0
mode_ctype = 0
mode_customer = 0
mode_del = 1
mode_direct = 1
mode_jmove = 1
mode_jt = 0
mode_lin = 0
mode_lmove = 0
mode_none = -1
mode_rot = 1
mode_tablet = 0
mode_tcp = 0
mode_tool = 1
mode_udp = 1
mode_xyzr1ext1 = 1
offset_device1n = 1000
offset_device2n = 2000
ope_command = 1999
ope_commandpc = 1999
ope_param[1] = 0
ope_param[2] = 0
ope_param[3] = 0
ope_param[4] = 0
ope_param[5] = 0
ope_param[6] = 0
ope_param[7] = 0
ope_param[8] = 0
ope_param[9] = 0
ope_param[10] = 0
ope_param[11] = 0
ope_param[12] = 0
ope_param[13] = 0
ope_param[14] = 0
ope_param[15] = 0
ope_param[16] = 0
ope_param[17] = 0
ope_param[18] = 0
ope_param[19] = 0
ope_param[20] = 0
pg_com_act = 1005
pg_com_noact = 1006
pg_master = 1
pg_slave = 2
port_udp[0] = 60001
port_udp[1] = 60002
port_udppc[0] = 60003
port_udppc[1] = 60004
poslimit_gen = 1
poslimit_restar = 5
real_repeat_tgl = 1020
real_start_butt = 1017
real_stop_butto = 1018
real_teach_tgls = 1019
real_tcp_port[0] = 60001;K-ROSET
real_tcp_port[1] = 60003;K-ROSET
robot_all = 0
robot_hacc[1,1] = 10
robot_hacc[1,2] = 10
robot_hacc[2,1] = 10
robot_hacc[2,2] = 10
robot_master = 1
robot_mode = 0
robot_mode_flg = 0
robot_slave = 2
safty_lmove_sp = 120
safty_move_sp = 102
sig_emg_output = 2099
sig_ext_reboot = 2051
sig_r1gen1_outp = 2097
sig_r2gen1_outp = 2098
sim_repeat_tgls = 2020
sim_start_butto = 2017
sim_stop_button = 2018
sim_teach_tglsw = 2019
sim_tcp_port[0] = 60001;K-ROSET
sim_tcp_port[1] = 60003;K-ROSET
slave_timeout = 100
slowlimit_speed = 100
slowlimit_time = 5
status_hold = 2
status_move = 1
status_nomove = 0
tcp_connected[0] = 0
tcp_connected[1] = 0
tcp_listen_lock = 0
tcp_listen_port[0] = 60001
tcp_listen_port[1] = 60003
tcp_listen_sid[0] = 0
tcp_listen_sid[1] = 0
tcp_sid[0] = -1
tcp_sid[1] = -1
tcp_sid_port[0] = -1
tcp_sid_port[1] = -1
tcp_timeout = 0.5
tool_data_num[1] = 999
tool_data_num[2] = 999
type_device = 3
type_device1 = 1
type_device2 = 2
type_open = 0
type_pos = 0
type_recv = 1
type_send = 2
wait_extin_time = 1
wait_maste_time = 1
wait_slave_time = 1
.END
.STRINGS
$appli_ver_tbl = "ADU00002 2015/12/09"
$appli_ver_v = "ATBU0000"
$data_cur_l1name = "NO SETTING"
$data_pgname = "MAINEXE"
$revision_info = "b5db7150a871"
.END
